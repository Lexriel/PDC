%---------------------------------------------------------------------------
\svnidlong 
{$HeadURL: https://svn.fil.univ-lille1.fr/svn/sedoglav_PDC/trunk/Cours/01/01.tex $} 
{$LastChangedDate: 2011-09-12 16:54:44 +0200 (Mon, 12 Sep 2011) $} 
{$LastChangedRevision: 58 $} 
{$LastChangedBy: sedoglav $} 
\svnid{$Id: 01.tex 58 2011-09-12 14:54:44Z sedoglav $} 
%\section{Prol\'egon\`emes}
%\label{sec:Prolegomenes}
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Details pratiques}
  \begin{center}
    \'Equipe p\'edagogique~:
    \par\bigskip
    \begin{tabular}{lll}
      Francesco &  De Comit\'e & G~1 (info) \\
      Alexandre & Sedoglavic  & G~2 (info) \\
      Mika\"el & Salson & G~3 (info) \\
      Adrien & Poteaux & G~4 (info)\\
      Samy & Meftali & G~1 (miage) \\
      Jean-Fran\c{c}ois & Roos & G~2 (miage) \\	
   \end{tabular}
  \end{center}
    \par\medskip
    Toutes les informations (emploi du temps, semainier, documents, etc.) sont
    disponibles \`a l'url~:
    \par
    \texttt{http://www.fil.univ-lille1.fr/portail}
    \par
    \hfill Licence $\rightarrow$ S5 info $\rightarrow$ PDC.
\end{frame}
%------------------------------------------------------------------------------
\section{Quelques abstractions}%
%------------------------------------------------------------------------------
\subsection{Utilisateur}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Repr\'esentation de l'utilisateur par le syst\`eme}%
  Tout utilisateur --- consid\'er\'e comme une entit\'e connue par le
  syst\`eme d'exploitation --- est caract\'eris\'e par
  \begin{itemize}
  \item son \textit{login} i.e.\ le nom d'utilisateur~;
  \item son mot de passe~;
  \item un unique num\'ero d'identification (uid)~;
  \item un (ou des) num\'ero(s) de groupe(s) d'utilisateurs (guid) auquel
  il appartient~;
  \item un r\'epertoire i.e.\ son espace disque (\$HOME)~;
  \item le nom d'un programme d'interface entre l'utilisateur et le
  syst\`eme.
  \end{itemize}
  \par\medskip
  Par exemple pour le superutilisateur, on trouve les informations
  suivantes dans le fichier \texttt{/etc/passwd}~:
  \begin{verbatim}
root:x:0:0:root:/root:/bin/bash
\end{verbatim}
\index{Repr\'esentation utilisateur}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Fichier}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Fichier et informations utilisateur relatives}%
  \begin{center}
    {\bf Un fichier est l'abstraction d'un flux lin\'eaire d'octets.}
  \end{center}
  \par
  Aucune information sur l'organisation de  l'espace du support \`a ce
  niveau d'abstraction.   Pour manipuler les  fichiers, il  faut 
  pouvoir les identifier par leurs caract\'eristiques~:
  \begin{itemize}
  \item nom, type, taille du fichier~;
  \item propri\'etaire du fichier, son groupe~;
  \item date de cr\'eation, date de derni\`ere modification~;
  \item protection~: qui a droit de le lire et de le manipuler.
  \end{itemize}
  Au fichier foo.bar sont associ\'ees les informations
\begin{verbatim}
-rw-r--r--    1 sedoglav calforme 0 Aug 19 05:09 foo.bar
\end{verbatim}
  Ces informations correspondent dans l'ordre aux droits, nombre de
  liens, au propri\'etaire, \`a son groupe, \`a la taille, \`a la date
  de cr\'eation et au nom du fichier.
\end{frame}
%------------------------------------------------------------------------------
\subsection{Processus}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Notion de processus}%
  Un processus est l'abstraction d'un programme ex\'ecut\'e par la machine.
  \begin{center}
  \begin{tabular}{cc}
    programme sur le disque &  processus en m\'emoire \\
    \begin{tabular}{|c|}
      \hline
      Magic Number
      \\ \hline
      ent\^ete
      \\ \hline
      Code
      \\ \hline
      donn\'ees initialis\'ees
      \\ \hline
      table des symboles
      \\ \hline
    \end{tabular} &
     \begin{tabular}{|c|}
       \hline
       Pile d'ex\'ecution
       \\
       $\downarrow$
       \\ \hline
       $\uparrow$ \\
       tas (malloc)
       \\ \hline
       donn\'ees non
       initialis\'ees
       \\ \hline
       donn\'ees 
       initialis\'ees
       \\ \hline
       code
       \\ \hline
     \end{tabular}\\
     S\'epar\'e en bloc &
     S\'epar\'e en page
  \end{tabular}    
  \end{center}
  Comme exemple de \textit{magic number}, signalons qu'un fichier
  commen\c{c}ant par \verb?#!? est sens\'e \^etre un script pour un
  interpr\'eteur (ces~$2$ caract\`eres sont suivis par le chemin
  d'acc\`es \`a l'interpr\'eteur).
\end{frame}
%------------------------------------------------------------------------
\begin{frame}
  Tr\`es sch\'ematiquement (et artificiellement), on peut r\'epartir
  les \emph{processus} en deux grandes cat\'egories~:
  \begin{itemize}
  \item les processus {\bf d'applications} qui accomplissent des
    t\^aches souhait\'ees par l'utilisateur (calculs scientifique,
    base de donn\'ees, bureautique, etc.)~;
  \item les processus {\bf syst\`emes} qui permettent l'exploitation
    des ressources de l'ordinateur (processeurs, m\'emoire, terminaux,
    clavier, disques, coexistence/communication de plusieurs
    applications, etc).
  \end{itemize}
  \begin{center}
    \begin{tabular}{|c|l}
      \cline{1-1}
      \begin{tabular}{c|c|c}
        Utilisateur~$1$ & $\cdots$ & Utilisateur~$n$
      \end{tabular} \\ \cline{1-1}    
      \begin{tabular}{ccc}
        Calculs  & Base de donn\'ees & Bureautique
      \end{tabular}
      & $\Big\rbrace$ Applications  \\ \cline{1-1}    
      \begin{tabular}{cc}
        Compilateur & interpr\'eteur \\ 
        \multicolumn{2}{c}{Syst\`eme d'exploitation}
      \end{tabular}
      & $\Bigg\rbrace$ Syst\`eme  \\ \cline{1-1}
      \begin{tabular}{c}
        Langage machine \\ 
        Dispositif physique
      \end{tabular}
      & $\Bigg\rbrace$ Mat\'eriel \\ \cline{1-1}
    \end{tabular}
  \end{center}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  Le syst\`eme d'exploitation permet aux applications~:
  \begin{itemize}
  \item d'utiliser les ressources mat\'erielles de la machine~;
    \begin{itemize}
    \item d'ordonner leurs ex\'ecutions les unes par rapport aux
      autres (\'eviter l'occupation du processeur par une application
      endormie, d\'efinir des priorit\'es),
    \item de g\'erer des droits (ex\'ecution, lecture) \`a des fin de
      s\'ecurisation~;
    \end{itemize}
  \item de communiquer~:
    \begin{itemize}
    \item par l'interm\'ediaire de la m\'emoire vive,
    \item par l'interm\'ediaire de la m\'emoire persistente (disque),
    \item par des structures had hoc (files de messages, s\'emaphore
      pour la synchronisation, etc).
    \end{itemize}
  \end{itemize}
  Dans cette optique toute t\^ache complexe impliquant plusieurs
  applications doit \^etre cod\'ee et pr\'evue en bas niveau
  (langage~C par exemple) en utilisant la connaissance du syst\`eme.
  \par\smallskip
  Comment sans cela permettre \`a l'utilisateur d'utiliser les
  applications mises \`a sa disposition en les ``combinant'' au gr\`es
  de sa fantaisie et de ses besoins~?
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  La fa\c{c}on la plus simple (et primitive) d'envisager la
  communication entre applications est de consid\'erer ces
  derni\`eres comme des \emph{filtres}.  Comme tout processus, un
  filtre poss\`ede (au minimum)~$3$ fichiers d'entr\'ee-sortie~:
  \begin{itemize}
  \item~0 stdin est l'entr\'ee standard (par d\'efaut, le clavier)~;
  \item~1 stdout est la sortie standard (par d\'efaut, l'\'ecran)~;
  \item~2 stderr est la sortie des erreurs (par d\'efaut, l'\'ecran).
  \end{itemize}
  De plus, chaque processus retourne \`a son p\`ere (son processus
  cr\'eateur) un octet qui est un \emph{code de retour}.
  \par\smallskip
  Un filtre est une fonction invoqu\'ee par un identifiant
  (\externcom{ls}), des options (\externcom{-al}), des arguments
  (\path{/bin}) qui prend en param\`etre une suite d'octets depuis
  l'entr\'ee standard, retourne des octets dans ses sorties et produit
  un code de retour.
  \par\smallskip
  Une fonction a un \emph{effet lat\'eral} si elle modifie un \'etat
  autre que ses valeurs de retour.  Pour \^etre utile, les filtres ont
  des effets lat\'eraux divers (affichage, saisie, connexion \`a un
  serveur, cr\'eation/modification/destruction de fichiers, etc).
\end{frame}
%------------------------------------------------------------------------------
\section{Shell}
%------------------------------------------------------------------------------
\begin{frame}
%  \frametitle{Des processus particulier~: les shells}%
Un \textit{shell} est un processus qui sert d'interface avec le syst\`eme. Il
  \begin{itemize}
  \item ne fait pas partie du syst\`eme d'exploitation (c'est un
    processus comme les autres qui l'utilise)~;
  \item est une interface interactive entre l'utilisateur, les
    applications disponibles et l'OS. Il permet d'ex\'ecuter et 
    de combiner des filtres~;
\item En mode \textit{batch}, il offre un langage de programmation~:
les instructions sont d\'efinies dans un \textit{script} que le
shell interpr\`ete (pas de compilation).
  \end{itemize}
  Les suites d'instructions ne sont pas compil\'ees et sont donc  
  portables sur tout UNIX.  Il existe plusieurs interpr\'eteurs de commandes~:
\begin{itemize}
  \item d\'eriv\'es du Bourne shell (sh, AT\&T, 1977) comme ksh (korn
    shell), bash (Bourne again shell), zsh (zero shell), etc.~;
  \item d\'eriv\'es du~C shell (csh, BSD, 1979) comme tcsh (Tenex~C
    shell), etc.
  \end{itemize}
  \index{Shell}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Interface interactive du shell} 
  Le shell permet notamment de manipuler les
  abstractions courantes (fichiers, processus, etc).
  Pour ce faire, il propose une
  \emph{invite de commande} que nous d\'esignerons par \%.
  \begin{enumerate}
  \item Cette invite est associ\'ee \`a un \'editeur en ligne
    et \`a l'ensemble des possibilit\'es classiques
    (d\'eplacement, copi\'e coll\'e, etc).
  \item Un backslash (code \textsc{ascii}~$92$) suivi d'un retour
    chariot permet d'\'editer une commande sur plusieurs lignes.
  \item Un caract\`ere di\`ese (code \textsc{ascii}~$35$) d\'ebute un
    commentaire.
  \end{enumerate}
\begin{verbatim}
% # ceci est un commentaire
%  \
>  \
> # encore un commentaire avec \ au milieu
%
\end{verbatim}
  Les commandes shell sont de~$2$ types~: interne et externe. 
\end{frame}
%------------------------------------------------------------------------------
\subsection{Commande externe}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Commande externe}
  Un shell permet d'ex\'ecuter une commande externe~:
\begin{verbatim}
% <commande externe> [option(s)] [argument(s)]
\end{verbatim}
  i.e.\ un programme ex\'ecutable~; le shell se \emph{clone} puis se
  \emph{mute} en un processus associ\'e \`a l'ex\'ecutable.
  \par\medskip
  Par exemple, l'ex\'ecutable de la commande \texttt{ls} se trouve
  dans le r\'epertoire \texttt{/bin}~; il affiche les informations
  relatives \`a un fichier~:
\begin{verbatim}
% /bin/ls -l /usr/bin/man
-rwxr-xr-x  1 root root 46308 Apr  8  2005 /usr/bin/man
\end{verbatim}
  \begin{itemize}
  \item \texttt{/usr/bin/man} est un argument indiquant que l'on
    d\'esire un affichage concernant ce fichier~;
  \item \texttt{-l} est une option indiquant que l'on d\'esire un
    affichage de toutes les informations.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Quelques exemples de commandes externes}%
  L'outil fondamental est le manuel d'utilisation \texttt{man} et la
    premi\`ere chose  \`a  faire est de lire  l'aide  sur le manuel en
    utilisant la commande  \texttt{\% man man} dans votre interpr\'eteur
    de commandes favori.
    \begin{itemize}
  \item \texttt{\% man -a mount}  affiche  l'ensemble des  pages  d'aide
    contenant le mot mount. Entre autre~:
\begin{verbatim}
mount            (2)  - mount and unmount filesystems
mount            (8)  - mount a file system
\end{verbatim} 
  \item \texttt{\% man  -S8   mount} affiche  l'aide sur  \texttt{mount}
    issue de la section~$8$ du manuel.
  \end{itemize}
  On  peut aussi utiliser  l'utilitaire  \texttt{info} mais, bien  que
  plus \'evolu\'e (liens hypertext), il n'est pas forcement complet.
\end{frame}
\begin{frame}
  Ceci fait les ex\'ecutables disponibles n'auront plus de secrets pour vous~:
  \par
  \begin{tabular}{ll}
    chmod & changer les droits d'un fichier \\
    cp & copie de fichier \\
    find & rechercher un fichier \\
    grep & afficher les lignes des fichiers contenant une \\
    & cha\^\i{}ne  de caract\`eres \\
    kill & envoyer un signal \`a un processus \\
    less & afficher le contenu d'un fichier \\
    ls & affichage  des informations  relatives au contenu \\
    & d'un r\'epertoire \\
    mkdir & cr\'eer un r\'epertoire \\
    mv & d\'eplacement de fichier  \\
    passwd & cr\'eer ou changer de mot de passe \\
    ps &  afficher la liste des processus \\
    rm & d\'etruire un fichier \\
  \end{tabular}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Contr\^ole des processus}%
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Interpr\'etation s\'equentielle vs asynchrone}
  \begin{itemize}
  \item \expression{subexpr1} \optionnel{; \expression{subexpr2} ;
      \ldots} \index{Shell!Op\'erateur!;}
    \begin{itemize}
    \item l'op\'erateur~; permet de s\'eparer l'ex\'ecution de
      commandes~\externcom{\%cd /; ls ;}.  Par d\'efaut, les shells
      attendent la fin de l'ex\'ecution d'une commande avant de
      permettre la saisie et l'ex\'ecution d'une autre~;
    \item le code de retour de l'expression est celui de la derni\`ere
      sous-expression dans la liste.
    \end{itemize}
  \item \expression{subexpr}1 \& \optionnel{\expression{subexpr2} \&
      \ldots} \index{Shell!Op\'erateur!\&}
    \begin{itemize}
    \item les shells permettent aussi de lancer une application en
      \textit{t\^ache de fond} (dans un shell-fils) et ainsi
      l'ex\'ecution d'une autre (m\^eme si la premi\`ere n'est pas
      termin\'ee, dans le shell d'origine).  Pour ce faire, on termine
      l'expression par~\&~;
    \item si \stdin{} n'est pas pr\'ecis\'e et que
      \expression{subexpr1} n'est pas interactive, l'entr\'ee standard
      est \path{/dev/null}~;
    \item le code de retour d'une expression asynchrone est~$0$ dans
      tous les cas.
    \end{itemize}
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Pour d\'etruire un processus dont le shell attend la terminaison, on
  utilise le raccourci clavier \textsc{ctrl-c}.
  \par
  Pour interrompre sans d\'etruire un processus, on utilise le
  raccourci clavier \textsc{ctrl-z}~; pour le relancer~:
  \begin{itemize}
  \item en t\^ache de fond, on utilise la commande interne \verb?bg?~;
  \item en avant plan, on utilise la commande interne \verb?fg?.
  \end{itemize}
  \par\smallskip
  La commande externe \verb?ps? retourne dans \stdout{} les
  informations associ\'ees aux processus.
\begin{verbatim}
% ps -l
F S UID  PID PPID C PRI NI ADDR SZ WCHAN TTY     TIME CMD
0 S 613 2434 2426 0 75 0 -  954 rt_sig pts/1 00:00:00 bash
\end{verbatim}
  La commande externe \verb?kill -<Signal> <PID>? envoit un signal au
  processus d'identificateur~\verb?PID?. Les principaux signaux sont~:
  \par
  \begin{tabular}{c|l}
    Signal & Signification \\\hline{}
    15     & terminaison de processus \\
    9      & destruction inconditionnelle de processus (\textsc{ctrl-c})\\
    19     & suspension de processus (\textsc{ctrl-z})\\
    18     & reprise d'ex\'ecution d'un processus suspendu
  \end{tabular}
\end{frame}
%------------------------------------------------------------------------------
\section{Op\'erateurs}%
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Une expression entre parenth\`eses est interpr\'et\'ee par un
  shell-fils du shell courant et pas par ce dernier~:
\begin{verbatim}
%( exit )  # est bien diff\'erent de
% exit 
\end{verbatim}
    On dispose de~$2$ op\'erateurs conditionnels~:
    \begin{itemize}
    \item[] \verb?subexpr1 && subexpr2?~: subexpr2 est ex\'ecuter si,
      et seulement si, subexpr1 retourne~0~;
    \item[] \verb?subexpr1 || subexpr2?~: subexpr2 est ex\'ecuter si,
      et seulement si, subexpr1 retourne un code non nul.
    \end{itemize}
  Ces deux r\`egles sont appliqu\'ees par le shell lorsqu'une suite de
  commandes contient plusieurs op\'erateurs \verb+&&+ et \verb+||+.
  Ces deux op\'erateurs ont la m\^eme priorit\'e et leurs
  \'evaluations s'effectue de gauche \`a droite.
  \par\medskip
  Le code de retour des expressions ainsi construites est le code de
  retour de la derni\`ere sous-expression ex\'ecut\'ee.
\end{frame}
%------------------------------------------------------------------------------
\subsection{Les op\'erateurs de redirection}%
%------------------------------------------------------------------------------
\begin{frame}
  Les filtres sont associ\'ees \`a des flux d'octets depuis le fichier
  standard \stdin{} vers les fichiers standards \stdout{} et
  \stderr{}.  Ces flux peuvent \^etre redirig\'es par les
  op\'erateurs~:
  \begin{itemize}
  \item[]$n>$foo~: fichier standard de descripteur~$n(=1,2)$ dans le
    fichier foo (cr\'eation ou \'ecrasement)~;
  \item[]$n>>$foo~: fichier standard de descripteur~$n(=1,2)$ dans le
    fichier foo (cr\'eation ou ajout)~;
  \item[]$n<$foo~: le fichier foo est envoy\'e dans le fichier de
    descripteur~$n(=0,1,2)$~;
  \item[]$n<<$ \textsc{eof} (texte \textsc{eof})~: insertion de texte
    dans le fichier de descripteur~$n(=0,1,2)$~;
  \item[]$|$~: tube de communication entre~$2$ filtres~;
  \item[]$n>$\&m~: r\'eoriente le flux de sortie du fichier de
    descripteur~$n$ dans celui de descripteur~$m$~;
  \item[]$n<$\&m~: r\'eoriente le flux d'entr\'ee du fichier de
    descripteur~$n$ dans celui de descripteur~$m$.
  \end{itemize}
  Si l'entier~$n$ est omis, la redirection concerne \stdout{} pour les
  sorties et \stdin{} pour les entr\'ees.
  % \par\smallkip
  % If more than one redirection operator is specified with a command,
  % the order of evaluation is from beginning to end.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Quelques illustrations des redirections}%
\begin{verbatim}
% ls /bin 1> /tmp/foo ; grep sh 0< /tmp/foo # correct
% ls /ntn /bin 1>/dev/null 2> /tmp/err # correct
% grep sh 0< ls  # incorrect car il n'y pas pas de fichier ls
% ls 1> grep sh  # incorrect car cr\'ee le fichier grep
% (ls /ntn /bin 2>&1) 1>/tmp/foo# manipule 2 filres, ls et sh
\end{verbatim}
  Un exemple d'insertion de texte o\`u le filtre \externcom{grep} prend
  son entr\'ee depuis le clavier jusqu'\`a la saisie de pourfinir~:
\begin{verbatim}
% grep tata << pourfinir
? abcd
? abcdtata
? pourfinir
abcdtata
\end{verbatim}
  Les commandes suivantes sont \'equivalentes~:
\begin{verbatim}
% ls /bin>/tmp/foo;grep sh</tmp/foo>&result;
% ls /bin | grep sh >& result # >& redirige stdout et stderr
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Les pipelines (tubes de communication)}%
  Un tube est une suite d'une ou plusieurs expressions s\'epar\'ee par
  l'op\'erateur~$|$~:
  \begin{itemize}
  \item \optionnel{!} subexpr1 \optionnel{$|$ subexpr2 \ldots}
    \par
    La sortie standard de tous --- sauf le dernier -- les filtres
    associ\'es aux sous-expressions est redirig\'ee vers l'entr\'ee
    standard du suivant~;
  \item l'op\'erateur~$|$ est prioritaire sur les autres
    redirections~;
  \item si le pipeline n'est pas lanc\'e en t\^ache de fond, le shell
    attend la fin de la derni\`ere commande du pipe avant de rendre
    l'invite de commande~;
  \item le code de retour de l'expression et celui de la derni\`ere
    commande du pipe.
  \end{itemize}
  Dans ce cas, l'op\'erateur~! est une n\'egation du code de retour
  i.e.~${!0=1}$ et si~${n\not =0}$ alors~${!n=0}$.
  \par
  Le~! est aussi utilis\'e par la commande interne \interncom{history}.
  \end{frame}
%------------------------------------------------------------------------------
\section{Commandes internes et variables}%
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Commande interne}
  Une commande interne est un filtre implant\'e dans le shell et ne
  correspond (en th\'eorie) \`a aucun fichier ex\'ecutable. L'objectif
  \'etant~:
  \begin{itemize}
  \item d'augmenter les performences de filtres tr\`es fr\'equement
    utilis\'e~;
  \item de permettre des fonctionnalit\'es difficiles \`a mettre en
    \oe{}uvre avec un code ind\'ependant du shell.
  \end{itemize}
  Dans le GNU-bash-3.0, les commandes \externcom{false},
  \externcom{true}, \externcom{kill}, \externcom{pwd} et
  \externcom{newgrp} sont externes bien que la norme les consid\`ere
  comme internes.
  \par\smallskip
  La commande interne \interncom{type} retourne dans \textsc{stdout}
  des informations sur les commandes (sont elles internes, externes,
  etc).
  \par\smallskip
  La commande externe \externcom{which foo} retourne dans
  \textsc{stdout} le chemin d'acc\`es \`a la commande externe
  \externcom{foo} si elle le trouve.
\end{frame}
%------------------------------------------------------------------------------
\subsection{Exemples de commande interne}%
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  La commande interne \verb+alias+ \'etablit une correspondance entre~$2$
  cha\^\i{}nes de caract\`eres. Par exemple, 
\begin{verbatim}
%alias ll='echo "Affichage long";ls -l'
\end{verbatim}
  L'interpr\'eteur substituera le membre de gauche (\verb+ll+) par le
  membre de droite (\verb+ls -l+) lorsqu'il appara\^\i{}t comme
  premier mot d'une commande. 
\begin{verbatim}
% cd /bin/ ; ll ls
Affichage long
-rwxr-xr-x   1 root  root  77964 Feb 13  2003 /bin/ls
\end{verbatim}
  De plus, il maintient une liste des alias qui peuvent \^etre
  supprim\'es par la commande interne \verb+unalias+.
  \par  
  Les alias sont g\'en\'eralement d\'efinis dans le fichier de
  configuration (\verb+.bashrc+ ou \verb+.cshrc+ suivant le shell
  utilis\'e) qui est ex\'ecut\'e par l'interpr\'eteur \`a son
  d\'emarrage.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Commandes internes sp\'eciales}
  Les commandes internes suivantes
\begin{verbatim}
 break, colon, continue, dot, eval, exec, exit, export,
 readonly, return, set, shift, times, trap, unset
\end{verbatim}
  sont qualifi\'ees de sp\'eciales car~:
  \begin{itemize}
  \item une erreur de syntaxe dans leurs usages peut causer la
    destruction du shell~;
  \item l'affectation des variables (voir plus loin) au cours de
    l'ex\'ecution de ces commandes reste valide apr\`es leurs
    terminaisons.
  \end{itemize}
  Ce n'est pas le cas des autres commandes (internes ou externes).
  \par\medskip
  Les autres commandes internes sont~:
\begin{verbatim}
alias, bg, cd, command, false, fc, fg, getopts, jobs, 
kill, newgrp, pwd, read, true, umask, unalias, wait
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Param\`etres du shell}
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Param\`etres du shell}
  \begin{itemize}
  \item un \emph{param\`etre} du shell peut \^etre identifi\'e par un
    nombre, un caract\`ere sp\'ecial (cf.\ section suivantes) ou un
    nom (une cha\^\i{}ne de caract\`eres alphanum\'erique qui n'est ni
    un nombre ni un caract\`ere sp\'ecial)~;
  \item une \emph{variable} du shell est un param\`etre identifi\'e
    par un nom~;
  \item un \emph{param\`etre de position} est un param\`etre qui n'est
    ni sp\'ecial ni une variable.
  \end{itemize}
  Un param\`etre est affect\'e s'il poss\`ede une \emph{valeur} (null
  est une valeur).
  \par\medskip
  Une variable ne peut \^etre d\'esaffect\'ee que par la commande
  interne \interncom{unset}.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Param\`etres sp\'eciaux et de position}%
  \begin{itemize}
  \item \verb|0| : le nom de la commande en cours~;
  \item \verb|#| : son nombre de param\`etres de position~;
  \item \verb|*|, \verb|@| : tous ses param\`etres de position~;
  \item \verb|1| \`a \verb|9| : ses~$9$ premiers param\`etres de
    position~;
  \item \verb|x| : le param\`etre de position~$x(>9)$~;
  \item \verb|$| : le pid de la commande courante~;
  \item \verb|_| : le dernier param\`etre manipul\'e (non
    normalis\'e)~;
  \item \verb|-| : les drapeaux (options) de la commande courante~;
  \item \verb|?| : toutes les commandes ont un code de retour ---
    cod\'e sur un octet --- (\emph{exit-status}) i.e.\ une valeur
    enti\`ere qui fournie une information sur le d\'eroulement de la
    derni\`ere commande ex\'ecut\'ee.
    \begin{itemize}
    \item d\'eroulement normal $\Rightarrow{}$ \verb|?| = 0,
    \item d\'eroulement anormal $\Rightarrow{}$ \verb|?| $\neq$ 0~;
    \end{itemize}
    Nous verrons en~C comment renvoyer le code de retour~;
  \item \verb|$!| : le pid du dernier processus lanc\'e en arri\`ere
    fond.
  \end{itemize}
  \index{Shell!variables!pr\'ed\'efinies}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Les param\`etres sp\'eciaux peuvent s'utiliser tels quels dans un
  shell~:
\begin{verbatim}
% false ; echo $0 $$ ; ps | grep bash
1 bash 2977
2977 pts/3    00:00:00 bash
\end{verbatim}
  En mode interactif, on les affecte avec la commande interne
  \interncom{set}~:
\begin{verbatim}
% echo $# # nous verrons plus tard le sens du $
0
% set foo bar ; echo $# $1 $2
2 foo bar
\end{verbatim}
  La commande interne \verb|shift| permet le d\'ecalage des
  param\`etres num\'erot\'es (\verb|1| est perdu et~\verb+#+ est mis
  \`a jour).
\begin{verbatim}
% shift ; echo $# $@
1 bar
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Variables}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Le shell dispose de variables que la commande interne \texttt{set}
  permet d'afficher~:
\begin{verbatim}
% set
USER=sedoglav
LOGNAME=sedoglav
HOME=/home/enseign/sedoglav
PATH=/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin
MAIL=/var/mail/sedoglav
SHELL=/bin/csh
HOSTTYPE=i586-linux
PWD=/home/enseign/sedoglav
GROUP=enseign
LANG=fr_FR
SYSFONT=lat0-16
TMP=/home/enseign/sedoglav/tmp
HOSTNAME=lxt2
\end{verbatim}
  \index{Shell!variables}%
  La commande \interncom{set} permet aussi de manipuler les options du
  shell. Par exemple, \interncom{\%set -o vi} permet de passer en mode
  d'\'edition~vi.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Les variables}%
  \textbf{D\'efinition et affectation~:} une variable est d\'efinie
  d\`es qu'elle est affect\'ee. En~sh, %
  \verb+% FOO="Bonjour le monde"+. En csh,
\begin{verbatim}
% set FOO="Bonjour le monde"
\end{verbatim}
  La commande interne \texttt{echo} permet d'afficher l'argument qui
  lui est fourni~:
\begin{verbatim}
% echo FOO
FOO
\end{verbatim}
  Pour \'evaluer une variable, il faut pr\'efixer son nom par \$.
\begin{verbatim}
% echo $FOO
Bonjour le monde
\end{verbatim}
  En~sh, la commande interne \texttt{export} \'etend la port\'e d'une
  variable~: par d\'efaut, cette derni\`ere n'est connue que par le
  processus courant~; apr\`es coup, cette variable est connue par tous
  les processus fils de ce dernier. En~csh, on utilise~:
\begin{verbatim}
% setenv FOO "Bonjour le monde"
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Quelques variables d'environnement}%
  Les variables d\'efinies dans les fichiers \texttt{/etc/profile} et
  \texttt{\~{}/profile} sont cr\'e\'ees lors de l'ouverture d'une
  session.
  \par\medskip
  \begin{tabular}{ll}
    PATH & les r\'epertoires dans lesquels sont cherch\'es les  \\
    &  ex\'ecutables des commandes externes \\ 
    HOME & votre r\'epertoire de travail \\
    TERM & le type de terminal \\
    PWD & le r\'epertoire courant \\
    DISPLAY & cette variable est utilis\'ee par l'interface graphique \\
    & pour savoir o\`u se fait l'affichage\\
    PS1 & l'invite de commande
  \end{tabular}
  \par\medskip
  Ces variables d'environnement peuvent \^etre utilis\'ees depuis un
  programme~C (fonction getenv) lanc\'e depuis le shell.
  \index{Shell!variables!exemples}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Typage, \'evaluation}%
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Dans un shell, \textbf{tout n'est que cha\^\i{}ne de caract\`eres}.
  \par\smallskip
  Chaque commande est une cha\^\i{}ne que le shell \'evalue. On peut
  influer sur cette \'evaluation gr\^ace aux d\'elimiteurs suivants~:
  \begin{itemize}
  \item les quotes \verb?' '? bloquent l'\'evaluation~;
  \item les guillemets \verb?" "? forment une cha\^\i{}ne apr\`es
    \'evaluation des composantes~;
  \item les backquotes \verb?` `? forment une cha\^\i{}ne \'evalu\'ee
    comme une commande.
  \end{itemize}
\begin{verbatim}
% echo '$FOO'
$FOO
% echo "echo '$FOO'"
echo 'Bonjour le monde'
% set BAR="n\'importe quoi" ; echo $BAR
n\'importe quoi
% set BAR=`n\'importe quoi`
n'importe: Command not found.                
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Manipulation d'entiers}%
  Pour utiliser l'arithm\'etique de base, il faut \'evaluer des
  cha\^\i{}nes de caract\`eres codant des expressions arithm\'etiques
  gr\^ace \`a la commande externe \texttt{expr}~:
\begin{verbatim}
% set i=12;set i=`expr $i + 1`
% echo $i $?
13 0
% expr 2 \* 2
4
\end{verbatim}
  Le code de retour de la commande \verb|expr| est~:
  \begin{itemize}
  \item[0] si le r\'esultat est diff\'erent de~$0$ ;
  \item[1] si le r\'esultat est \'egal \`a~$0$ ;
  \item[2] si un argument est non num\'erique.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\section{Compl\'ements} 
%------------------------------------------------------------------------------
\subsection{Expressions r\'eguli\`eres}
%------------------------------------------------------------------------------
\begin{frame}
  Les emph{expressions r\'eguli\`eres} d\'ecrivent des propri\'et\'es de
  construction de cha\^\i{}nes de caract\`eres. Pour ce faire, on
  utilise en shell les \emph{m\'etacaract\`eres}~:
  \begin{itemize}
  \item le point d'interrogation \texttt{?}\ correspond \`a n'importe
    quel caract\`ere (sauf EOL).  L'expression r\'eguli\`ere
    \texttt{b?l} repr\'esente les cha\^\i{}nes \textit{bal} et
    \textit{bol} et toutes les autres combinaisons comme
    \textit{bwl}~;
  \item la paire de crochet \texttt{[ ]} permet de sp\'ecifier plus
    restrictivement un ensemble de caract\`eres. L'expression
    r\'eguli\`ere \texttt{dupon[dt]} ne repr\'esente que les
    cha\^\i{}nes \textit{dupond} et \textit{dupont}. L'expression
    \texttt{dupon[d-t]} repr\'esente les cha\^\i{}nes commen\c{c}ant
    par \textit{dupon} et se terminant par une lettre comprise entre
    \textit{d} et~\textit{t}. L'expression \texttt{dupon[\^{}dt]}
    repr\'esente les cha\^\i{}nes commen\c{c}ant par \textit{dupon} et
    ne se terminant ni par~\textit{d} ni par~\textit{t}~;
  \item l'\'etoile \texttt{*} d\'esigne~$0,1$ ou plusieurs
    caract\`eres quelconques.  Ainsi, \texttt{*} repr\'esente toutes
    les cha\^\i{}nes.
  \end{itemize}
  Le pr\'efixe~$\backslash$ (antislash) transforme un
  m\'etacaract\`ere en caract\`ere.  
  \index{Shell!expression r\'eguli\`ere}
\end{frame}
%------------------------------------------------------------------------------
\subsection{Raccourci clavier}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Raccourci clavier et quelques caract\`eres sp\'eciaux
    utiles} La liste des raccourcis clavier est affichable par des
  commandes internes~:
  \begin{itemize}
  \item \verb?bind -p? pour bash~;
  \item \verb?bindkey? pour csh.
  \end{itemize}
  \par\medskip
  Retenons pour m\'emoire~:
  \begin{center}
    \begin{tabular}{ll}
      \textsc{ctrl}-d & caract\`ere fin de fichier \\
      \textsc{ctrl-}\verb?\? & stop la commande en cours
    \end{tabular}
  \end{center}
  Pour approfondir l'usage d'un interpr\'eteur de commande, la
  procha\^\i{}ne \'etape consiste \`a \'etudier la syntaxe et la
  grammaire induite par les op\'erateurs et les commandes,
  l'\'evaluation associ\'ee, les expressions (simples et compos\'ees),
  les instructions de contr\^ole, les fonctions et le passage de
  param\`etres, etc.
\end{frame}
%------------------------------------------------------------------------------
% That's all folks
