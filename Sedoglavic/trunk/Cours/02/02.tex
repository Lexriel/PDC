%---------------------------------------------------------------------------
\svnidlong 
{$HeadURL: https://svn.fil.univ-lille1.fr/svn/sedoglav_PDC/trunk/Cours/02/02.tex $} 
{$LastChangedDate: 2012-11-20 17:19:55 +0100 (Tue, 20 Nov 2012) $} 
{$LastChangedRevision: 83 $} 
{$LastChangedBy: sedoglav $} 
\svnid{$Id: 02.tex 83 2012-11-20 16:19:55Z sedoglav $} 
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Details pratiques}
  \begin{center}
    \'Equipe p\'edagogique~:
    \par\bigskip
    \begin{tabular}{lll}
      Francesco &  De Comit\'e & G~1 (info) \\
      Alexandre & Sedoglavic  & G~2 (info) \\
      Mika\"el & Salson & G~3 (info) \\
      Adrien & Poteaux & G~4 (info)\\
      Samy & Meftali & G~1 (miage) \\
      Jean-Fran\c{c}ois & Roos & G~2 (miage) \\	
   \end{tabular}
  \end{center}
    \par\medskip
    Toutes les informations (emploi du temps, semainier, documents, etc.) sont
    disponibles \`a l'url~:
    \par
    \texttt{http://www.fil.univ-lille1.fr/portail}
    \par
    \hfill Licence $\rightarrow$ S5 info $\rightarrow$ PDC.
\end{frame}
%------------------------------------------------------------------------------
  \section{Maximes~; le premier programme et sa compilation}%
\begin{frame}
  Con\c{c}u aux laboratoires Bell par D.\ Ritchie pour d\'evelopper le
  syst\`eme d'exploitation \textsc{unix} (des langages~A et~B ont exist\'e mais
  ne sont plus utilis\'es)~:
  \begin{itemize}
  \item C n'est li\'e \`a aucune architecture particuli\`ere~;
  \item C est un langage typ\'e qui fournit toutes les instructions
    n\'ecessaires \`a la programmation structur\'ee~;
  \item C est un langage compil\'e.
  \end{itemize}
  En~$1983$, l'\textsc{ansi} d\'ecida de normaliser ce langage et d\'efinit la
  norme \textsc{ansi}~C en~$1989$.  Elle fut reprise int\'egralement en~$1990$
  par l'\textsc{iso}.
  \par\smallskip
  Les principes historiques de~C sont~:
  \begin{enumerate}
  \item Trust the programmer.
  \item Make it fast, even if it is not guaranteed to be portable.
  \item Keep the language small and simple.
  \item Don't prevent the programmer from doing what needs to be done.
  \item Provide (preferably) only one (obvious) way to do an operation.
  \end{enumerate}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Trust the programmer}%
  Le langage~C n'a pas \'et\'e con\c{c}u pour faciliter sa lecture
  (contrairement \`a Ada par exemple).
  \par 
  Un concours annuel (International Obfuscated C Code Contest ---
  www.ioccc.org) r\'ecompense d'ailleurs le programme le plus
  illisible. 
  \par\bigskip
  \begin{overprint}
\onslide<1>
  Par exemple, le cru~$2001$ pr\'esentait le programme
  suivant~:
\begin{verbatim}
m(char*s,char*t) { 
return *t-42?*s?63==*t|*s==*t&&m(s+1,t+1):
          !*t:m(s,t+1)||*s&&m(s+1,t); 
}
main(int c,char **v) { return!m(v[1],v[2]); }
\end{verbatim}
\onslide<2>
Un autre exemple de~$1999$~:
\begin{verbatim}
#include <stdio.h>
int O,o,i;char*I="";
main(l){O&=l&1?*I:~*I,*I++||(l=2*getchar(),i+=O>8
?o:O?0:o+1,o=O>9,O=-1,I="t8B~pq`",l>0)?main(l/2):
printf("%d\n",--i);}
\end{verbatim}
\onslide<3>
\begin{center}
  \underline{\textsf{Vous ne validerez pas cet enseignement}}
  \par
  \underline{\textsf{si vous suivez ces exemples.}}
  \par
\end{center}
\par\medskip
  Par contre, vous l'aurez r\'eussi si vous les comprenez sans
  probl\`emes.
  \end{overprint}
\end{frame}
%------------------------------------------------------------------------------
%\begin{frame}
%  \section{Un petit dernier pour la route}%
%\begin{verbatim}
%#define n ((e[++a]-42)/9-f[d+1])?
%#define o printf("%c",c[" 01./:;|\\"]);

%char e[]="**3<HRZcir+3@OXakt;=GOXds*\?HRZcir*7HNZ`i19JS\\p*H[m1:CJSz*>H[`mr25\
%\?Hx,P,B2Gs-KTfzRdv1SeyCR-ISeu.<Ev+9+P,z,4PfzIdvO2*HRZcir6GPis=MU*3HRZcir*HZi\
%1JS\\epy*>H[m1JSey*DH[m*3<HZiu-@P*3HZi<N]q1JS\\epy:[m1CJSeny06I[m*4\?HRZcir,\
%\?*6HRZcir1J]q2K*H[m2K*H[m2@K]qtO@M2DK]q,]q1JS\\epy[m1:JSey+[m*3<HRZcir13Gt,\
%=GVs*3<HRZcir1J]qz*HF*AH2;DK]qua0=G2:K]q]q1CJS\\pDVu1:JS*D!+3:BIOSY`egilqtxz\
%\177.0249<==>EJMUY`ejov#$59@CJOXYZbfhlnrxy&+.57=@IMR[``bcfmnq!#),@",*f;

%int main(int j,char *k[]) {
%  int a,b,c,d,g,h,i=19;
%  printf("       ");
%  for(g=0[f=(char *)calloc(80+(h=atoi(1[k])),1)]=1; g<=h; g++) {
%    if ((g>30)&&(f[i-2]+f[i-1]!=0)) i++;
%    for(d=c=0; d<i; d++) {
%    o f[d]=(e[b=c*9,b+=(c=d[f]),(((a=e[345+b]+b/19*85-33-b/40*12-b/80*4)[e]
%                -42)/9-f[d+1])?n n n n n n n n 0:a:a:a:a:a:a:a:a:a]-42)%9; }
%    o if (0[f]-1) printf("\n%6i ",g); else printf("\n       "); }
%}$
%\end{verbatim}
%\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Make it fast, even if it is not guaranteed to be
    portable.}%
  Les compilateurs tra\^\i{}tent les commandes~C en fonction des
  sp\'ecificit\'es de l'architecture (implantation des types au plus
  efficace).

  De plus, on peut faire appel \`a l'assembleur pour des t\^aches
  critiques. Par exemple, dans le code du noyau Linux~:
\begin{verbatim}
static inline int flag_is_changeable_p(u32 flag){ u32 f1,f2;
        asm("pushfl\n\t"
            "pushfl\n\t"
            "popl %0\n\t"
            "movl %0,%1\n\t"
            "xorl %2,%0\n\t"
            "pushl %0\n\t"
            "popfl\n\t"
            "pushfl\n\t"
            "popl %0\n\t"
            "popfl\n\t"
            : "=&r" (f1), "=&r" (f2)
            : "ir" (flag)); return ((f1^f2) & flag) != 0;
}
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Keep the language small and simple}%
  \begin{overprint}
    \onslide<1>
    Les~$32$ mots-clefs de l'\textsc{ansi}~C
    \begin{itemize}
    \item les sp\'ecificateurs de type~:
      \begin{tabular}{llllll}
        \textbf{char} & \textbf{double} &  \textbf{enum} & \textbf{float} &
        \textbf{int} & \textbf{long} \\ \textbf{short} & \textbf{signed} &
        \textbf{struct} & \textbf{union} & \textbf{unsigned}& \textbf{void}
      \end{tabular} 
    \item les qualificateurs de type~: \hfill \quad \textbf{const}\qquad
      \textbf{volatile}
    \item les instructions de contr\^ole~:
      \begin{tabular}{llllll}
        \textbf{break}&\textbf{case} &  \textbf{continue} & \textbf{default} &
        \textbf{do} & \textbf{else} \\ \textbf{for} & \textbf{goto} &
        \textbf{if} & \textbf{switch} & \textbf{while}
      \end{tabular} 
    \item sp\'ecificateurs de stockage~:
    \begin{tabular}{ccccc}
    \textbf{auto}& \textbf{register}&
      \textbf{static} & \textbf{extern} & \textbf{typedef}
    \end{tabular}
    \item autres~: \hfill \quad\textbf{return} \qquad \textbf{sizeof}
    \end{itemize}
    \onslide<2>
    Les~$40$ op\'erateurs de l'\textsc{ansi}~C
    \begin{itemize}
    \item les op\'erateurs
      \par
      \begin{tabular}{ccccc}
        (\ ) & [\ ]  & -$>$ & !   & \~{} \\
        ++ & $--$ & - & (type) & *() \\
        \&() &sizeof & ,    & $*$ & /    \\
        \% & + & - & $>>$& $<<$\\
        $>$  & $<$   &$<$=  &$>$= & ==   \\
        $<<$= & \& & \^{} & $|$ & \&\& \\
        $||$ & ?:    & +=   & -=  & *=   \\
        /=&\%=& \^{}= & $!$= & $>>$= 
      \end{tabular}
    \end{itemize}    
    \par\bigskip
    Et c'est tout~!!!
  \end{overprint}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Don't prevent the programmer from doing what needs to be done~: C est un  langage de \textit{bas niveau}}%
  \begin{overprint}
    \onslide<1> 
    Il n'est pas rare d'entendre dire que~C est un
    assembleur de haut niveau i.e.\ un assembleur typ\'e qui offre des
    structures de contr\^ole \'elabor\'ees et qui est --- relativement
    --- portable (et port\'e) sur l'ensemble des architectures.
	\par\medskip
Ce langage est pens\'e comme un \emph{assembleur portable}~: son pouvoir d'expression est une \emph{projection} des fonctions \'el\'ementaires d'un microprocesseur id\'ealis\'e et suffisament simple pour \^etre une abstraction des architectures r\'eelles. 
    \onslide<2>
    C est un langage de bas niveau, il
    \begin{itemize}
    \item permet de manipuler des donn\'ees au niveau du processeur
      (sans recourir \`a l'assembleur)~;
    \item ne g\`ere pas la m\'emoire (ramassage de miettes)~;
    \item ne pr\'evoit pas d'instruction traitant des objets compos\'es
      comme des cha\^\i{}nes de caract\`eres, des structures, etc.
      (pour comparer deux cha\^\i{}nes, il faut utiliser une fonction)~;
    \item ne fournit pas d'op\'eration d'entr\'ee-sortie dans le
      langage.
    \end{itemize}
    C utilise des biblioth\`eques pour ces t\^aches.
  \end{overprint}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Pratique du~C dans le cursus de formation}%
  L'ambition du cours est de se comprendre \`a plusieurs niveaux (dans
  l'ordre chronologique)~:
  \begin{enumerate}
  \item C comme langage de programmation.
  \item Relations entre~C et architecture.
  \item Relations entre~C et \textsc{os}.
  \end{enumerate}
  sans pour autant faire les cours se trouvant dans la m\^eme
  fili\`ere informatique du \textsc{lmd} \`a Lille~:
  \begin{center}
  \par
  \begin{tabular}{|cc|}
    \hline
    Architecture \'el\'ementaire & (info 202) 
    \\ \hline
    Pratique du~C & (info 301) 
    \\ \hline
    Pratique des syst\`emes & (info 305)
    \\ \hline
  \end{tabular}
  \par
  \end{center}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Le premier programme et sa compilation}%
  En fin de cours, les d\'etails du code suivant seront
  limpides~:
\begin{verbatim}
/* ceci est un commentaire */
#include <stdio.h>       
int 
main
(int argc, char **argv) 
{
 printf("Salut le monde \n") ; 
 return 0 ; /* valeur de retour (0 i.e. EXIT_SUCCESS) */
}
\end{verbatim}
\begin{overprint}
\onslide<1>
\begin{itemize}
\item \texttt{include} est une directive au pr\'eprocesseur pour
  incorporer ce qui permet l'usage de la fonction \texttt{printf} de
  la biblioth\`eque standard~;
\item les instructions se terminent par un point-virgule~;
\end{itemize}
\onslide<2>
\begin{itemize}
\item la fonction \texttt{main} est impos\'ee pour produire un
  ex\'ecutable (qui commence par ex\'ecuter \texttt{main}).  Elle est
  d\'efinie par l'en-t\^ete de la fonction~: type de retour, nom,
  argument~; les accolades contiennent les instructions composant la
  fonction.  L'instruction \texttt{return} est une instruction de
  retour \`a la fonction appelante~;
\item appel de la fonction \texttt{printf} --- d\'eclar\'ee dans
  \texttt{stdio.h} --- avec une cha\^\i{}ne en param\`etre.
\end{itemize}
\end{overprint}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Principe de la compilation \'el\'ementaire}%
\begin{enumerate}
\item \textbf{\'Edition du fichier source~:} fichier texte contenant
le programme --- n\'ecessite un \'editeur de texte (emacs, vi).
\item \textbf{Traitement par le pr\'eprocesseur~:} le fichier
source est trait\'e par un \textit{pr\'eprocesseur} qui fait des
transformations purement textuelles (remplacement de cha\^\i{}nes de
		caract\`eres, inclusion d'autres fichiers source, etc).
\item \textbf{La compilation~:} le fichier engendr\'e par le
pr\'eprocesseur est traduit en \textit{assembleur} i.e.\ en une
suite d'instructions associ\'ees aux fonctionnalit\'es du
microprocesseur (faire une addition, etc).
\item \textbf{L'assemblage~:} transforme le code assembleur en un
fichier \textit{objet} i.e.\ compr\'ehensible par le processeur
\item \textbf{L'\'edition de liens~:} afin d'utiliser des librairies
de fonctions d\'ej\`a \'ecrites, un programme est s\'epar\'e en
plusieurs fichiers source.  Une fois le code source assembl\'e, il
faut \textit{lier} entre eux les fichiers objets.  L'\'edition de
liens produit un fichier \textit{ex\'ecutable}.
\end{enumerate}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
\frametitle{Programmation sans filet $\Rightarrow$ ma\^\i{}trise indispensable du langage}%
En~C, le programmeur est cens\'e ma\^\i{}triser parfaitement le
langage et son fonctionnement.
\par\medskip
Les tests d'erreurs et de typages ne sont fait qu'au moment de la
compilation i.e.\ rien n'est test\'e lors de l'ex\'ecution (les
convertions de types, l'utilisation d'indices de tableau sup\'erieurs
\`a sa taille, etc).
\par\medskip
De plus, le compilateur est \texttt{laxiste}~: il vous laisse faire
tout ce qui a un sens (m\^eme t\'enu) pour lui.
\par\medskip
Un programme peut donc marcher dans un contexte (certaines
donn\'ees) et provoquer des erreurs dans un autre.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Outils utilis\'es en TP}%
Vous \^etes libres d'utiliser vos outils pr\'ef\'er\'es\ldots
\par
\begin{flushright}
\ldots\ \`a condition que ceux-ci soient~:
\end{flushright}
\begin{itemize}
\item \texttt{emacs} ou \texttt{vi} pour l'\'edition de vos
fichiers sources~;
\par\medskip
\item\texttt{gcc} pour la compilation. Il s'agit du gnu~C compiler
et on peut y adjoindre certains drapeaux. Par exemple,
\begin{verbatim}
% gcc -Wall -ansi -pedantic foo.c
\end{verbatim}
indique que vous d\'esirez voir s'afficher tous les avertissements
du compilateur (tr\`es recommand\'e)~;
\par\medskip
\item\texttt{gdb} pour l'ex\'ecution pas \`a pas et l'examen de la
m\'emoire (\texttt{ddd} est sa surcouche graphique).
\end{itemize}
\par\medskip
Une s\'eance sera consacr\'ee \`a la compilation s\'epar\'ee et \`a
certains outils de d\'eveloppement logiciels.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
 \section{Les constantes et identificateurs}%
   \frametitle{Les constantes num\'eriques}
   \textbf{Les entiers machines}~: on peut utiliser~$3$ types de
   notations~:
   \begin{itemize}
   \item la notation d\'ecimale usuelle ($66$,~$-2$)~;
   \item la notation octale (commen\c{c}ant par un~$0$ (en~C,
			   la constante $010$ est diff\'erente de~$10$))~;
   \item  la notation hexad\'ecimale  (commen\c{c}ant par un~$0x$ (en~C,
			   la constante $0x10$ est \'egale \`a~$16$))~;
   \end{itemize}
   \par\medskip
   \textbf{Les r\'eels machines}~: ne sont pas en pr\'ecision infinie
   et sont not\'es par~:
   \begin{itemize}
   \item\textit{mantisse} $-273.15$, $3.14$ et
   \item\textit{exposant}     indiqu\'e  par  la  lettre~\texttt{e}~:
   $1.4e10$, $10e-15$.
   \end{itemize}
   \end{frame}
%-----------------------------------------------------------------------------
   \begin{frame}[fragile]
   \frametitle{Les constantes (non) num\'eriques}
   \textbf{Les caract\`eres} se r\'epartissent en deux types~:
   \begin{itemize}
   \item\textit{imprimable}   sp\'ecifi\'e   par  \texttt{'}.  Ainsi,
   \texttt{'n'} correspond \`a l'entier~$110$ (et par le biais
	d'une table au caract\`ere n)~;
\item\textit{non imprimable} qui         sont       pr\'ec\'ed\'es
par~$\backslash$.  Ainsi, \texttt{'$\backslash$n'}  correspond \`a
un saut de ligne. 
\par
On  peut    aussi     utiliser    pour   ces   caract\`eres     la
notation~\texttt{'$\backslash\xi$'} avec~$\xi$  le code  \textsc{ascii} octal
associ\'e (cf.\ \verb+% man ascii+).
\end{itemize}
\index{Constante}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Identificateur~: un nom associ\'e \`a de l'espace
    m\'emoire}%
  Les identificateurs servent \`a manipuler les objets du langage
  i.e.\ manipuler de l'espace m\'emoire auquel on donne un nom.
  \par
  Ils d\'esignent de la m\'emoire contenant des donn\'ees (des
  variables, etc.)  ou de la m\'emoire contenant du code \`a
  ex\'ecuter (des fonctions).
  \par
  Ils ne peuvent pas commencer par un entier (mais peuvent les
  contenir).  C~distingue les majuscules des minuscules~: (x et X sont
  deux identificateurs diff\'erents).
  \par
  Certaines r\`egles de bon usage sont \`a respecter~;
  \begin{itemize}
  \item les caract\`eres non \textsc{ascii} --- i.e.\ non portables --- ne
    devraient pas \^etre utilis\'es (pas d'accent)~;
  \item les identificateurs d\'ebutant par un
    \textit{blanc\_soulign\'e} sont propres au syst\`eme
    d'exploitation et ne devraient pas \^etre utilis\'es par un
    programmeur en dehors de l'OS~;
  \item il vaut mieux choisir des identificateurs parlant.
  \end{itemize}
  \index{Identificateur}
\end{frame}
% ------------------------------------------------------------------------------
\section{Types~: tailles de la repr\'esentation des objets}%
\begin{frame}[fragile]
  \frametitle{Les entiers machines}
  \begin{overprint}
    \onslide<1> Il y a~$8$ types associ\'es aux entiers machines~:
    \begin{itemize}
    \item\texttt{int} est le type de base des entiers sign\'es et
      correspond au mot machine (historiquement~$16$ bits ou actuellement~$32$
      bits, bient\^ot~$64$).  Les entiers
      repr\'esentables sont donc dans
      l'intervalle~${[-2^{31},2^{31}[}$.
      \\
      Ce type est modifiable par un attribut \texttt{unsigned}
    \item\texttt{unsigned int} est le type de base des entiers non
      sign\'es cod\'es sur le m\^eme nombre d'octets (donc compris
      entre~${[0,2^{32}-1]}$).
    \end{itemize}
    \onslide<2> Ces types sont modifiables par les attributs
    \texttt{short} et \texttt{long}~:
    \begin{itemize}
    \item\texttt{short int} est un type plus \textsl{court} (cod\'e
      sur~$16$ bits) et repr\'esentant les entiers dans~${[-2^{7},
        2^{7}[}$.
    \item\texttt{long int} est un type plus \textsl{long} (cod\'e
      sur~$32$ bits --- pour des raisons historiques) et
      repr\'esentant les entiers dans~${[-2^{31}, 2^{31}[}$.
    \item\texttt{long long int} est un type encore plus \textsl{long}
      (cod\'e sur~$64$ bits) et repr\'esentant les entiers
      dans~${[-2^{63}, 2^{63}[}$.
    \end{itemize}
    \par\medskip
    La taille d\'epend de l'architecture de la machine et peut varier.
    \onslide<3> On indique comment typer une constante en utilisant
    les suffixes~:
    \begin{center}
      \begin{tabular}{cll}
        u ou U &  unsigned (int ou long) & 550u \\
        l ou L &  long &  123456789L \\
        ul ou UL & unsigned long & 12092UL
      \end{tabular}
    \end{center}
    On peut manipuler en~C des entiers plus grand en employant des
    repr\'esentations non sp\'ecifi\'ees par le langage (tableaux,
    listes cha\^\i{}n\'ees --- voir la librairie gnu multiprecision (\textsc{gmp}) par 
    exemple).  
    \onslide<4> Pour conna\^\i{}tre le nombre
    d'octets associ\'es \`a un type, on utilise le mot clef du langage
    \texttt{sizeof}. Par exemple,
\begin{verbatim}
int 
main
(void)
{ 
  return sizeof(long long int); 
}
\end{verbatim}
    est un programme qui retourne le nombre d'octets codant le type
    \texttt{long long int}.  \index{sizeof}
    \begin{verbatim}
    % # sur les machines de tp
    % gcc foo.c ; ./a.out
    % echo $?
    8
    %
    \end{verbatim}
  \end{overprint}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Le type \texttt{char}}%
  Le langage~C associe aux caract\`eres le type \texttt{char}
  g\'en\'eralement cod\'e sur~$1$ octet. Le type \texttt{char} est
  g\'en\'eralement sign\'e de~$-128$ \`a~$127$.
  \par\medskip
  Historiquement, le code \textsc{ascii} n\'ecessitait~$7$ bits.
  \par
  Le reste du monde utilisant des accents, l'\textsc{iso} d\'efinit
  une foultitude de codage sur~$1$ octet~: le code \textsc{ascii} de
  base jusqu'\`a~$127$ et le reste \`a partir de~$128$.
  \par
  Le type \texttt{char} est modifiable par l'attribut
  \texttt{unsigned} pour coder les entiers de~$0$ \`a~$255$.
  \par\medskip
  Il faut bien garder \`a l'esprit que le type \texttt{char}
  repr\'esente des entiers dont la correspondance avec des lettres de
  l'alphabet est fa\^\i{}te en dehors du langage par une table (voir 
  \verb+% man ascii+).
  \index{char}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Le type flottant (float) et les ``bool\'eens''}%
  Il existe deux types pour le codage des r\'eels en~C~:
  \begin{itemize}
  \item\texttt{float} pour les flottants simple pr\'ecision~$32$ bits
    g\'en\'eralement~;
  \item\texttt{double} pour les flottants double pr\'ecision~$64$ bits
    g\'en\'eralement.
  \end{itemize}
  \par\medskip
  On ne peut pas les modifier (\texttt{unsigned}, \texttt{short)
  }comme les autres types si ce n'est pour~:
  \begin{itemize}
  \item\texttt{long double} qui correspond \`a un codage sur~$12$
    octets.
  \end{itemize}
  \par\bigskip\bigskip
  Les bool\'eens sont --- s\'emantiquement --- repr\'esent\'es par les
  entiers~:
  \begin{itemize}
  \item valeur logique fausse~: valeur nulle {\tt 0}~;
  \item valeur logique vraie~: tout entier $\neq$ {\tt 0}.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\section{Variable et d\'eclaration de variable}%
\begin{frame}
Sch\'ematiquement, une variable correspond \`a un emplacement en
m\'emoire.  Dans le code source, ce dernier est manipul\'e
par l'entremise de l'identificateur de la variable.
\par
Avant utilisation, toutes les variables doivent \^etre~:
\begin{itemize}
\item soit {\em d\'efinies localement} ce qui correspond \`a
l'allocation d'une zone m\'emoire (segment de pile)~;
\item soit {\em d\'efinies globalement} ce qui correspond~:
\begin{itemize}
\item \`a la cr\'eation d'une entr\'ee dans la table des symboles~;
\item \`a l'allocation d'une zone m\'emoire (segment de donn\'ees)~;
\item au stockage de cette adresse dans la table~;
\end{itemize}
\item soit {\em d\'eclar\'ees} \texttt{extern} ce qui correspond \`a~:
\begin{itemize}
\item une variables d\'efinies dans un autre fichier source~;
\item la cr\'eation d'une entr\'ee dans la table des symboles~;
\item {\em mais pas \`a son allocation}~: l'adresse est inconnue
\`a l'assemblage~;
\item (l'adresse est r\'esolue \`a l'\'edition de liens).
\end{itemize}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
Pour d\'eclarer une variable, il faut faire suivre le nom
du type par un identificateur. Par exemple~:
\begin{verbatim}
int i;         /* pas tr\`es */
int j, k;      /* explicite  */
short int s;   /* ces identificateurs :-( */
float f;
double d1,d2;
\end{verbatim}
Bien qu'il soit vivement conseill\'e de d\'ecoupler d\'eclaration et
initialisation, on peut affecter des variables \`a la
d\'eclaration~:
\begin{itemize}
\item Caract\`ere~: \textbf{char} \texttt{nom} \textbf{='} \texttt{A}
\textbf{';}
\item Cha\^\i{}ne de caract\`eres~: \textbf{char *}\texttt{foo}
\textbf{="} \texttt{bar} \textbf{";}
\item Entier machine~: \textbf{int} \texttt{nom} \textbf{=} \texttt{666}
\textbf{;}

\item Flottant machine~: \textbf{float} \texttt{nom} \textbf{=}
\texttt{3.14} \textbf{;}
\end{itemize}
\par\medskip
Implicitement, nous venons de nous servir de~$2$ op\'erateurs~:
\begin{itemize}
\item la virgule permet de d\'efinir une suite~;
\item l'op\'erateur d'affectation \texttt{=}.
\end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Qualificatif pr\'ecisant le type}%
  On peut modifier les types en pr\'ecisant le codage machine \`a
  l'aide des mots-clefs \textbf{signed}, \textbf{unsigned},
  \textbf{short}, \textbf{long}.
  \par
  \begin{center}
    \begin{tabular}{ll}
      \textbf{short int} \hfill ${[-2^{7}, 2^{7}[}$ &
      \textbf{int} \hfill  ${[-2^{31},2^{31}[}$  \\
      \textbf{unsigned int} \hfill  ${[0,2^{32}[}$ &
      \textbf{long int} \hfill  ${[-2^{63},2^{63}[}$ \\ 
      \textbf{unsigned short int} \hfill ${[0,2^{8}[}$ &
      \textbf{unsigned long int} \hfill ${[0,2^{64}[}$ \\
    \end{tabular}
  \end{center}
  \par
  On peut aussi modifier les flottants par les mots-clefs
  \textbf{double} et \textbf{long double}.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \section{Construction d'expression en~C}%
  Une expression correspond \`a la composition d'identificateurs et
  d'op\'erateurs. Elle se termine par un point virgule.
  \par\smallskip
  L'action d'un op\'erateur sur un identificateur peut avoir~$2$ types
  de cons\'equences~:
  \begin{itemize}
  \item retourner la valeur de l'expression~;
  \item un effet lat\'eral portant sur l'identificateur.
  \end{itemize}
  \par\smallskip
  Par exemple, l'affectation \verb+foo = 2+ provoque~:
  \begin{itemize}
  \item l'effet lat\'eral~: l'entier~$2$ est affect\'e \`a la variable
    \verb+foo+~;
  \item et retourne la valeur qui vient d'\^etre affect\'ee.
  \end{itemize}
  On peut donc avoir une expression du type~:
\begin{verbatim}
bar = foo = 2 ;
\end{verbatim}
  L'op\'erateur \verb?++? provoque~:
  \begin{itemize}
  \item l'effet lat\'eral~: incr\'emente l'expression~;
  \item et retourne la valeur qui vient d'\^etre obtenue.
  \end{itemize}
\begin{verbatim}
foo = ++bar ;
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Comment d\'eterminer la s\'emantique d'une
    expression~?}%
  Il faut ma\^\i{}triser l'action des op\'erateurs~:
  \begin{itemize}
  \item op\'erateurs arithm\'etiques classiques~:
    \begin{tabular}{lll}
      $+$ addition & $-$  soustraction & $*$ multiplication \\
      $/$ division & \%  reste de la division
    \end{tabular}
  \item les op\'erateurs relationnels $>$, $<$, $<$=, $>$=, ==
  \item les op\'erateurs logiques bool\'eens\ \&\& et, \ $||$ ou, \ !
    non
  \item les op\'erateurs logique bit \`a bit \& et, $|$ ou inclusif,
    \~{} ou exclusif
  \item les op\'erateurs d'affectation compos\'ee $+$=, $-$=, /=,
    $*$=, \%{}=, etc.
  \item les op\'erateurs d'incr\'ementation et de d\'ecr\'ementation
  \item l'op\'erateur conditionnel ternaire foo = x$>$=0~? x~:-x.
  \item conversion de type char foo = (char) 48.14~;
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Priorit\'e et ordre d'\'evaluation des op\'erateurs}%
  L'instruction \verb?X *= Y + 1;?  n'est pas \'equivalente \`a
  \verb?X = X * Y + 1;?  {\tiny
    \begin{center}
      \begin{tabular}{c|l|c}
        16 &
        \verb+()+ 
        \hspace{3mm}
        \verb+[]+ 
        \hspace{3mm}
        \verb+->+
        \hspace{3mm}
        \verb+.+ 
        & G
        \\
        15 &
        \verb|++| 
        \hspace{3mm}
        \verb+--+ (postfix\'e)
        & D
        \\
        14 &
        \verb+!+ 
        \hspace{3mm}
        \verb+~+ 
        \hspace{3mm}
        \verb|++|
        \hspace{3mm}
        \verb+--+ (pr\'efix\'e) 
        \hspace{3mm}
        \verb+-+ (unaire) 
        & D
        \\
        & \verb+*+ (indirection)
        \hspace{3mm}
        \verb+&+ (adresse)
        \hspace{3mm}{\tt sizeof} 
        & D
        \\
        13 &
        \verb+*+ (multiplication)
        \hspace{3mm}
        \verb+/+ 
        \hspace{3mm}
        \verb+%+
        & G
        \\
        12 & 
        \verb|+| 
        \hspace{3mm}
        \verb+-+ 
        & G
        \\
        11 &
        \verb+<<+ 
        \hspace{3mm}
        \verb+>>+       
        & G
        \\
        10 &
        \verb+<+ 
        \hspace{3mm}
        \verb+<=+ 
        \hspace{3mm}
        \verb+>+ 
        \hspace{3mm}
        \verb+>=+ 
        & G
        \\
        9 &\verb+==+ \hspace{3mm}\verb+!=+ & G\\
        8 &\verb+&+ (et bit \`a bit) & G\\
        7 &\verb+^+ & G\\
        6 &\verb+|+ & G\\
        5 &\verb+&&+ & G\\
        4 &\verb+||+ & G\\
        3 &\verb+?:+ & D\\
        2 &\verb+=+ 
        \hspace{3mm}
        \verb|+=| 
        \hspace{3mm}
        \verb+-=+ 
        \hspace{3mm}
        \verb+*=+ 
        \hspace{3mm}
        \verb+/=+ 
        \hspace{3mm}
        \verb+%=+ 
        \hspace{3mm}
        \verb+>>=+ 
        \hspace{3mm}
        \verb+<<=+ 
        \hspace{3mm}
        \verb+&=+ 
        \hspace{3mm}
        \verb+^=+ 
        \hspace{3mm}
        \verb+|=+ 
        & D
        \\
        1 &
        \verb+,+ 
        &G
      \end{tabular}
    \end{center}
  } Pour l'op\'erateur~$\circ$, la priorit\'e~$G$ indique que
  l'expression~$
  \textup{exp}_{1}\circ\textup{exp}_{2}\circ\textup{exp}_{3}$ est
  \'evalu\'ee de gauche \`a droite.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \section{Conversion implicite et explicite}%
        Consid\'erons la situation suivante~:
\begin{verbatim}
  int foo = 2 ;
  unsigned char bar = 3 ;
  double var = foo +  bar ;
\end{verbatim}
        Les op\'erateurs ne pouvant agir que sur des donn\'ees de 
        types homog\`enes, il y a~$2$ conversions de type dans cet
         exemple~:
    \begin{itemize}
  \item l'op\'erateur~\texttt{+} provoque --- si n\'ecessaire --- la conversion 
        d'une des op\'erandes apr\`es son \'evaluation~;  
  \item l'op\'erateur~\texttt{=} provoque --- si n\'ecessaire --- la conversion 
        de l'op\'erande de droite dans le type de l'identificateur de gauche apr\`es son \'evaluation et avant son affectation 
        \`a cet identificateur.
  \end{itemize}
        \par\medskip
        En cas de doute, il faut utiliser la conversion de type explicite~:
\begin{verbatim}
  int foo = 2;
  unsigned char bar = 3 ;
  double var = foo / bar ; var = ((double) foo / (double) bar) ;
\end{verbatim}  
\end{frame}
%-----------------------------------------------------------------------------
\begin{frame}[fragile]
  \section{Op\'erateurs}
  \frametitle{Op\'erateurs arithm\'etiques usuels}
  Addition
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\tt +} \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item \'evaluation des expressions et calcul de l'addition~;
    \item retourne la valeur de l'addition~;
	\item ordre  ind\'etermin\'e d'\'evaluation des expressions~;
    \item conversion \'eventuelle d'une des op\'erandes apr\`es \'evaluation.
    \end{itemize}
  \end{itemize}
  Soustraction
  \begin{itemize}
  \item Syntaxe~:
    l'op\'{e}rateur peut \^{e}tre utilis\'{e} de mani\`{e}re unaire ou binaire~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt -} \hspace{3mm}{\it expression}\\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\tt -} \hspace{3mm}{\it expression\/$_2$}
  \end{itemize}
  \par\bigskip
  Multiplication
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\tt *} \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: voir addition.
  \end{itemize}
  \index{Arithm\'etique!enti\`ere}
  \index{Op\'erateurs!addition}
  \index{Op\'erateurs!soustraction}
  \index{Op\'erateurs!multiplication}
  \index{\verb?+?}
  \index{\verb?-?}
  \index{\verb?*?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Division
  \begin{itemize}
  \item Syntaxe~: \hspace*{10mm} $\Rightarrow$ 
    \hspace{3mm}{\it expression\/$_1$} \hspace{3mm}\verb+/+ \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: comme l'addition
    \begin{itemize}
    \item pas de distinction entre division enti\`ere ou r\'eelle~;
    \item division enti\`ere $\Leftrightarrow$ {\it expression\/$_1$}
      et {\it expression\/$_2$} enti\`eres~;
    \item cas de la division enti\`ere~:
      \begin{itemize}
      \item op\'erandes positives~: arrondi vers~$0$ (${13 / 2 = 6}$)~;
      \item une op\'erande n\'egative~: d\'epend de l'implantation~;\\
        \par\qquad  ${13 / -2 = -6}$ ou~$-7$.
      \end{itemize}
    \end{itemize}
  \end{itemize}    
  \par\smallskip
  Modulo
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}\verb+%+ \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item {\it expression\/$_1$} et {\it expression\/$_2$} enti\`eres~;
    \item reste de la division enti\`ere~;
    \item si un op\'erande n\'egatif~: signe du dividende en g\'en\'eral~;
    \item Assurer que \verb?b * (a / b) + a % b? soit \'egal \`a \verb?a?.
    \end{itemize}
  \end{itemize}
  \index{Arithm\'etique!enti\`ere}
  \index{Op\'erateurs!division}
  \index{Op\'erateurs!modulo}
  \index{\verb?/?}
  \index{\verb?%?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Op\'erateurs de comparaison}
  \begin{itemize}
  \item Syntaxe~:
    \\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\it op\'{e}rateur} \hspace{3mm}{\it expression\/$_2$}
    \\
    o\`{u} {\it op\'{e}rateur} est  l'un des symboles~:
    \begin{center}
      \begin{tabular}{cc}
        \begin{tabular}{c|c}
          op\'erateur &s\'emantique\\ \hline
          \verb+>+  &strictement sup\'erieur\\
          \verb+<+  &strictement inf\'erieur\\
          \verb+>=+ &sup\'{e}rieur ou \'egal\\
          \verb+<=+ &inf\'{e}rieur ou \'egal\\
          \verb+==+ &\'egal\\
          \verb+!=+ &diff\'erent
        \end{tabular}
      \end{tabular}
    \end{center}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item \'evaluation des expressions puis comparaison~;
    \item valeur rendue de type {\tt int} (pas de type bool\'een)~;
    \item vaut~$1$ si la condition est vraie~;
    \item vaut~$0$ si la condition est fausse~;
    \item Ne pas confondre~: 
      test d'\'egalit\'e ({\tt ==}) et affectation ({\tt =}).
    \end{itemize}
  \end{itemize}
  \index{Comparaison}
  \index{Op\'erateurs! de comparaison}
  % \indexvarDollar{\string\phmExclam =}
  % \indexvarDollar{==, <, >, <=, >=, \string\phmExclam =}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Op\'erateurs logiques}     
  Et logique
  \begin{itemize}
  \item Syntaxe~:\\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$}
    \hspace{3mm}\verb+&&+ \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: {\it expression$_1$} est \'{e}valu\'{e}e et~:
    \begin{enumerate}
    \item si valeur nulle~: l'expression \verb+&&+ rend  {\tt 0}~;
    \item si valeur non nulle~: {\it expression$_2$} est \'{e}valu\'{e}e
      et 
      \begin{enumerate}
      \item si valeur nulle~: l'expression \verb+&&+ rend  {\tt 0}~; 
      \item si valeur non nulle~: l'expression \verb+&&+ rend  {\tt 1}.
      \end{enumerate}
    \end{enumerate}
  \item Remarque~: \\
    \qquad  {\it expression\/$_2$} non \'evalu\'ee si {\it
      expression\/$_1$} fausse \\
    Utile~: \verb?(n != 0) && (N / n == 2)? 
    \par
    D\'esagr\'eable~: \verb?(0) && (j = j - 1)?.
  \end{itemize}
  \index{Logique}
  \index{Op\'erateurs!et logique}
  \index{implantation des bool\'eens}
  \index{\verb?&&?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Ou logique
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}\verb+||+ \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: {\it expression$_1$} est \'{e}valu\'{e}e et~:
    \begin{enumerate}
    \item si valeur non nulle~: l'expression \verb+||+ rend  {\tt 1}~;
    \item si valeur nulle~: {\it expression$_2$} est \'{e}valu\'{e}e
      et 
      \begin{enumerate}
      \item si valeur nulle~: l'expression \verb+||+ rend  {\tt 0}~; 
      \item si valeur non nulle~: l'expression \verb+||+ rend  {\tt 1}.
      \end{enumerate}
    \end{enumerate} 
  \item Remarque~: 
    \  {\it expression\/$_2$} non \'evalu\'ee si {\it
      expression\/$_1$} vraie
  \end{itemize}
  \par\bigskip
  Non logique
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}\verb+!+ \hspace{3mm}{\it expression}
  \item S\'{e}mantique~: {\it expression} est \'{e}valu\'{e}e et~:
    \begin{enumerate}
    \item valeur nulle~: l'op\'{e}rateur \verb+!+ d\'elivre {\tt 1}~;
    \item valeur non nulle~: l'op\'{e}rateur \verb+!+ d\'elivre {\tt 0}.
    \end{enumerate}
  \end{itemize}
  \index{Logique}
  \index{Op\'erateurs!ou logique}
  \index{Op\'erateurs!non logique}
  \index{\verb?||?}
  % \indexvarDollar{\string\phmExclam}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Op\'erateurs de traitement des bits}
  Non bit \`a bit
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}\verb+~+ \hspace{3mm}{\it expression}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item \'evaluation de {\it expression} $\Rightarrow$ type entier~;
    \item calcul du non bit \`a bit sur cette valeur~;
    \item rend une valeur enti\`ere.
    \end{itemize}
  \end{itemize}    
  \par\smallskip
  Et bit \`a bit
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$}
    \hspace{3mm}\verb+&+ \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: \'evaluation de {\it expression\/$_1$} et {\it
      expression\/$_2$} qui doivent \^etre de valeur enti\`ere.
  \end{itemize}
  \par\smallskip
  Ou bit \`a bit
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\tt |} \hspace{3mm}{\it expression\/$_2$}
  \end{itemize}
  \index{Traitement des bits}
  \index{Op\'erateurs!et bit \`a bit}
  \index{Op\'erateurs!non bit \`a bit}
  \index{Op\'erateurs!ou bit \`a bit}
  \index{\verb?&?}
  \index{\verb?~?}
  %% \indexvarDollar{\string\phmPipe}
  \par\smallskip Ou exclusif bit \`a bit
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} 
    \hspace{3mm}{\tt \verb?^?} \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: voir et bit \`a bit.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
  \begin{frame}[fragile]
    D\'ecalage \`a gauche
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$} \hspace{3mm}
    \verb?<<? \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item \'evaluation de {\it expression\/$_1$} et {\it
        expression\/$_2$}~;
    \item doivent \^etre de valeur enti\`ere, positive pour {\it
        expression\/$_2$}~;
    \item {\it expression\/$_1$} d\'ecal\'ee \`a gauche de 
      {\it expression$_2$} bits en remplissant les bits libres avec des
      z\'eros.
    \end{itemize}
  \end{itemize}
  \par\bigskip
  D\'ecalage \`a droite
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it expression\/$_1$}\hspace{3mm}
    \verb?>>? \hspace{3mm}{\it expression\/$_2$}
  \item S\'{e}mantique~: voir d\'ecalage \`a gauche~:
    \begin{itemize}
    \item si {\it expression\/$_1$} {\tt unsigned}~: d\'ecalage logique
      \\
      les bits rentrants \`a droite sont des z\'eros~;
    \item  si {\it expression\/$_1$} sign\'ee~: d\'ecalage arithm\'etique \\
      les bits rentrants \`a droite sont \'egaux au bit de signe.
    \end{itemize}
  \end{itemize}
  \index{Traitement des bits}
  \index{Op\'erateurs!ou exclusif bit \`a bit}
  \index{Op\'erateurs!de d\'ecalage}
  \index{\verb?^?}
  \index{\verb?>>?, \verb?<<?}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \section{Instructions usuelles}
  Instruction compos\'ee (du bon usage des accolades).
  \begin{itemize}
  \item Syntaxe~:
    {\it instruction-compos\'ee} :\\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}\verb+{+\\
      \hspace*{18mm}{\it liste-de-d\'{e}clarations$_{option}$}\\
      \hspace*{18mm}{\it liste-d'instructions$_{option}$}\\
      \hspace*{18mm}\verb+}+\par\medskip
    {\it liste-de-d\'{e}clarations} :\\
    \hspace*{10mm} $\Rightarrow$ {\it d\'eclaration} \\
    \hspace*{10mm} $\Rightarrow$ {\it liste-de-d\'{e}clarations} {\it d\'eclaration} 
    {\it liste-d'instructions} : \\
    \hspace*{10mm} $\Rightarrow$ {\it instruction} \\
    \hspace*{10mm} $\Rightarrow$ {\it liste-d'instructions} {\it instruction} 
    \par\medskip
    Une expression isol\'ee n'a pas de sens.
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  Attention \`a l'usage des instructions compos\'ees et des variables~:
\begin{verbatim}
#include <stdio.h>
char foo = 'c' ;
int main(void){
  printf(" %c ",foo) ;
  char foo = 'a' ; /*on n'utiliser qu'un nom de variable*/
  printf(" %c ",foo) ;
  {
  char foo = 'b' ; /*mais c'est une tr\`es mauvaise id\'ee*/
  printf(" %c ",foo) ;
  }
  printf(" %c \n",foo) ;
  return 0 ;
}
\end{verbatim}
\begin{verbatim}
% gcc InstructionsComposees.c ; a.out
 c a b a
\end{verbatim}
  De toutes fa\c{c}ons~:
\begin{verbatim}
%gcc -Wall -ansi -pedantic InstructionsComposees.c
InstructionsComposees.c: In function `main':
InstructionsComposees.c:9: warning: 
ISO C89 forbids mixed declarations and code
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \par\bigskip
\begin{itemize}
  \item S\'{e}mantique des instructions compos\'ees~: 2 objectifs
    \begin{enumerate}
    \item Grouper un ensemble d'instructions en une seule
      instruction~;
    \item D\'eclarer des variables accessibles seulement \`a l'int\'erieur de {\it
        instruction-compos\'ee} 
      \begin{quote}
        $\Rightarrow$ Structure classique de blocs
      \end{quote}
    \end{enumerate}
  \item Remarques
    \begin{itemize}
    \item pas de s\'eparateur dans {\it liste-d'instructions}~: 
      \begin{quote}
        le \verb?;? est un terminateur pour les expressions 
      \end{quote}
    \item accolades (\verb?{}?) correspondant au \verb?begin? \verb?end? de Pascal.
    \end{itemize}
  \end{itemize}
  \index{Bloc d'instructions}
  \index{Instructions!compos\'ees}
  \index{\verb?\{, \?}}
\end{frame}
%------------------------------------------------------------------------------
\section{Instructions de contr\^ole}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \begin{itemize}
  \item Syntaxe~:
    {\it instruction-conditionnelle} :\\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt if} 
    \hspace{3mm}{\tt (} \hspace{3mm}{\it expression} \hspace{3mm}{\tt )} 
    \hspace{3mm}{\it instruction\/$_1$}\\
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt if} 
    \hspace{3mm}{\tt (} \hspace{3mm}{\it expression} \hspace{3mm}{\tt )} 
    \hspace{3mm}{\it instruction\/$_1$}\\
    \hspace*{23mm}{\tt else} \hspace{3mm}{\it instruction\/$_2$}
  \item Remarques sur la syntaxe~:
    \begin{itemize}
    \item {\it expression} doit \^etre parenth\'es\'ee~;
    \item pas de mot cl\'e {\tt then}~;
    \item ambigu\"\i{}t\'e du {\tt else}~:
\begin{verbatim}
   if (a > b) if (c < d) u = v; else i = j;
\end{verbatim}
      R\`egle~: relier le {\tt else} au premier {\tt if} de m\^eme niveau
      d'imbrication n'ayant pas de {\tt else} associ\'e 
\begin{verbatim}
   if (a > b) { if (c < d) u = v; } else i = j;
\end{verbatim}
    \end{itemize}
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \begin{itemize}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item \'evaluation de {\it expression}~;
    \item si valeur non nulle~: ex\'ecution de {\it instruction\/$_1$}~;
    \item si valeur nulle~: ex\'ecution de {\it instruction\/$_2$} si
      elle existe.
    \end{itemize}
  \item Remarques sur la s\'emantique~:
    \begin{itemize}
    \item {\tt if}~: teste \'egalit\'e \`a z\'ero de {\it expression}~;
    \item {\it expression}~: pas forc\'ement une comparaison~;
    \item {\it expression}~: comparable \`a z\'ero~;
\begin{verbatim}
   if (a != 0) { ... }
   if (a) { ... }
\end{verbatim}
    \end{itemize}
  \end{itemize}
  \index{Instructions!conditionnelles}
  \index{\verb?if, if ... else?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Instruction \`a choix multiples}  
  Syntaxe~:
  \par\bigskip
  {\tt switch (} {\it expression} {\tt )} 
  \par
  \verb?{? 
    \par
    \qquad {\tt case} \hspace{3mm}{\it expr-cste\/$_1$} 
    \hspace{3mm}{\tt :} 
    \hspace{3mm}{\it liste-d'instructions$_{1 \hspace{1mm}option}$} \\
    \hfill{\tt break$_{option}$;}\\
    \qquad{\tt case} \hspace{3mm}{\it expr-cste\/$_2$} 
    \hspace{3mm}{\tt :} 
    \hspace{3mm}{\it liste-d'instructions$_{2 \hspace{1mm}option}$}  \\
    \hfill{\tt break$_{option}$;}\\
    \begin{center}
    {$\cdots$}       
    \end{center}
    \qquad{\tt case} \hspace{3mm}{\it expr-cste\/$_n$} 
    \hspace{3mm}{\tt :} 
    \hspace{3mm}{\it liste-d'instructions$_{n \hspace{1mm}option}$} \\
    \hfill{\tt break$_{option}$;}\\
    \qquad{\tt default} \hspace{3mm}{\tt :} 
    \hspace{3mm}{\it liste-d'instructions$_{\textrm{option}}$}\\
\verb+}+
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \begin{enumerate}
  \item \'Evaluation de {\it expression}~; 
  \item R\'esultat compar\'e avec 
    {\it expr-cste\/$_1$}, {\it expr-cste\/$_2$,} etc.~;
  \item Premi\`ere {\it expr-cste\/$_i$} \'egale \`a
    à {\it expression~}: ex\'ecution de  {\it liste-d'instructions}
    correspondante~; 
  \item Instruction {\tt break}~: termine l'ex\'ecution du {\tt switch}~;
  \item Si aucune {\it expr-cste\/$_i$} 
    \'egale \`{a} {\it expression}~:  ex\'ecution de 
    {\it liste-d'instructions} de l'alternative {\tt default} si celle-ci existe,
    sinon on ne fait rien.
  \end{enumerate}
  \index{Instructions!à choix multiple}
  \index{\verb?switch?}
  \index{\verb?break?}
  \index{\verb?case?}
  Remarques~:
  \begin{itemize}
  \item {\it expr-cste\/$_i$}~:  valeur connue \`a la compilation (constante)~;
  \item {\it expr-cste\/$_i$}~: pas deux fois la m\^eme valeur~;
  \item s'il n'y a pas de {\tt break} \`a la fin d'un {\tt case}~: 
    ex\'ecution des {\it
      liste-d'instruction} des {\tt case} suivants~;
  \item l'alternative {\tt default} est optionnelle.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Exemple utilisant le {\tt break}~:
  {\normalsize
\begin{verbatim}
   int nb = 1 ;
   switch(nb){
      case 1 : printf("un"); break;
      case 2 : printf("dos"); break;
      case 3 : printf("tres"); break;
      default : printf("erreur: pas dans la chanson\n");
   }
\end{verbatim}
  }
  Exemple n'utilisant pas le {\tt break}~:
  {\normalsize
\begin{verbatim}
   switch(c){
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9': nb_chiffres++; break;
      default: nb_non_chiffres++;
   }
\end{verbatim}
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Instructions it\'eratives}
  Trois instructions d'it\'eration~:
  {\it instruction-it\'erative} :\\
  \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it instruction-while}\\
  \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it instruction-do} \\ 
  \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it instruction-for} 
  \newpage 
  Instruction while
  \begin{itemize}
  \item Syntaxe~:
    $\Rightarrow$ \hspace{3mm}{\tt while} \hspace{3mm}{\tt (} \hspace{3mm}{\it expression} 
    \hspace{3mm}{\tt )}\hspace{3mm} {\it instruction}
  \item S\'emantique~: boucle avec test en d\'ebut d'it\'eration
    {\small
      \begin{center}
        \setlength{\unitlength}{.6mm}
        \begin{picture}(100,50)
          \put(25,12){\framebox(30,8){instruction}}
          % on ne peut pas mettre du texte dans l'ovale
          \put(45,36){\oval(48,10)}   %   le put est au centre
          \put(25,35){expression != 0 ?} 
          \put(68,36){\line(1,0){19}}
          \put(87,36){\vector(0, -1){4}}
          \put(72,26){fin du {\tt while}}
          \put(71,37){non}
          \put(42,27){oui}
          \put(40,32){\vector(0,-1){12}}
          \put(40,12){\line(0,-1){12}}
          \put(0,0){\line(1,0){40}}
          \put(0,0){\line(0,1){36}}
          \put(0,36){\vector(1,0){22}}
          \put(40,50){\vector(0,-1){10}}
        \end{picture}
      \end{center}
    }
  \item Exemple~: somme des~${n=10}$ premiers entiers
\begin{verbatim}
int n = 10; int i = 1; int somme = 0;
while (i <= n) { somme = somme+i; i = i+1; }
\end{verbatim}
  \end{itemize}
  \index{Instructions!d'it\'eration}
  \index{\verb?while?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Instruction do \ldots\ while
  \begin{itemize}
  \item Syntaxe~:
    $\Rightarrow$ \hspace{3mm}{\tt do} 
    \hspace{3mm}{\it instruction} \\ \qquad\hspace{3mm}{\tt while} 
    \hspace{3mm}{\tt (} \ {\it expression} \ {\tt )} 
    \hspace{3mm}{\tt ;}
  \item S\'emantique~: boucle avec test en fin d'it\'eration 
    \begin{center}
      {\small
        \setlength{\unitlength}{.6mm}
        \begin{picture}(100,50)
          \put(25,32){\framebox(30,8){instruction}}
          % on ne peut pas mettre du texte dans l'ovale
          \put(40,16){\oval(45,10)}   %   le put est au centre
          \put(20,15){expression != 0 ?} 
          \put(63,16){\line(1,0){20}}
          \put(83,16){\vector(0,-1){5}}
          \put(72,6){fin du {\tt do}}
          \put(66,17){non}
          \put(42,7){oui}
          \put(40,50){\vector(0,-1){10}}
          \put(40,32){\vector(0,-1){12}}
          \put(40,12){\line(0,-1){12}}
          \put(0,0){\line(1,0){40}}
          \put(0,0){\line(0,1){36}}
          \put(0,36){\vector(1,0){24}}
        \end{picture}
      }
    \end{center}
  \item Exemple~: somme des~${n=10}$ premiers entiers
\begin{verbatim}
int n = 10; int i = 1; int somme = 0;
if (i <= n) do { 
    somme = somme + i; 
    i = i + 1;
  } while (i <= n);
\end{verbatim}
  \end{itemize}
  \index{Instructions!d'it\'eration}
\index{\verb?do?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Instruction for
  \par
  \begin{tabular}{cc}
    \begin{minipage}[b]{4.7cm}
      \par\medskip
      Syntaxe~: \\
      $\Rightarrow$ \ {\tt for} {\tt (} 
      {\it expression\/$_{1\,option}$} {\tt ;} \\ 
      \par\qquad{\it expression\/$_{2\,option}$}{\tt ;} \\  
      \par\qquad{\it expression\/$_{3\,option}$}{\tt )}\\
      \par\qquad \ {\it instruction}
      \hspace*{6mm}    \\
      S\'emantique~: \\ it\'eration born\'ee 
    \end{minipage} &
    {\small
      \setlength{\unitlength}{.63mm}
      \begin{picture}(40,60)
        \put(25,12){\framebox(30,8){expression3}}
        \put(25,32){\framebox(30,8){instruction}}
        % on ne peut pas mettre du texte dans l'ovale
        \put(40,56){\oval(48,8)}   %   le put est au centre
        \put(20,55){expression2 != 0 ?} 
        \put(64,56){\line(1,0){8}}
        \put(72,56){\vector(0, -1){5}}
        \put(50,46){fin du {\tt for}}
        \put(67,57){non}
        \put(22,47){oui}
        \put(25,72){\framebox(30,8){expression1}}
        \put(40,12){\line(0,-12){12}}
        \put(40,32){\vector(0,-12){12}}
        \put(40,52){\vector(0,-12){12}}
        \put(40,72){\vector(0,-12){12}}
        \put(40,92){\vector(0,-12){12}}
        \put(10,0){\line(40,0){30}}
        \put(10,0){\line(0,66){66}}
        \put(10,66){\vector(1,0){29}}
      \end{picture}
    } 
  \end{tabular}
  \index{Instructions!d'it\'eration}
  \index{It\'eration born\'ee}
  \index{\verb?for?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Instruction for (suite)
  \begin{itemize}
  \item Remarques
    \begin{itemize}
    \item {\it expression\/$_{1}$} et {\it expression\/$_{3}$}~:
      valeurs inutilis\'ees \\
      \qquad\qquad\qquad $\Rightarrow$ effet lat\'eral~: expressions d'affectation
    \item {\it expression\/$_{1}$}~: instruction d'initialisation~;
    \item {\it expression\/$_{3}$}~: instruction d'it\'eration~;
    \item {\it expression\/$_{2}$}~: expression de test (arr\^et quand nulle)~;
    \item {\it instruction}~: corps de la boucle.
    \end{itemize}
  \item Exemple~: somme des~${n=10}$ premiers entiers
\begin{verbatim}
int i ; int n = 10; int somme = 0;
for (i = 0; i <= n; i = i + 1)
    somme = somme + i; 
\end{verbatim}
  \item M\^eme exemple avec un corps de boucle vide
\begin{verbatim}
int i ; int n ; int somme ;
for (i=0,n=10,somme=0; i<n; somme=somme+(i=i+1)) ;
\end{verbatim}
\end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
Attention \`a la confusion avec d'autres langages~:
\begin{verbatim}
#include <stdio.h>

int main(void){

  int foo ;
  for( foo=0 ; foo<10 ; foo++)
          printf("%d\n",foo) ;

  for( int bar=0 ; bar<10 ; bar++)
          printf("%d\n",bar) ;

  return 0 ;
}
\end{verbatim}
La compilation donne~:
\begin{verbatim}
% gcc for.c
for.c: In function `main':
for.c:9: `for' loop initial declaration used outside C99 mode
\end{verbatim}
\index{Instructions!d'it\'eration}
\index{It\'eration born\'ee}
\index{\verb?for?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Instruction {\tt goto} (possible mais \`a proscrire)~:
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt goto} 
    \hspace{3mm}{\it identificateur} \hspace{3mm}{\tt ;}
  \item S\'emantique~:
    \begin{itemize}
    \item toute instruction est \'etiquetable~;
    \item si on la fait pr\'ec\'eder d'un identificateur suivi du signe {\tt :}
    \item et d'un identificateur~: {\it \'etiquette}~;
    \item {\tt goto}~: transf\`ere
      le contr\^{o}le d'ex\'ecution \`{a} l'instruction \'etiquet\'ee par
      {\it identificateur}.
    \end{itemize}
  \item Remarques~:
    \begin{itemize}
    \item \'etiquettes visibles que dans la fonction o\`u elles sont
      d\'efinies~;
    \item s'utilise pour sortir de plusieurs niveaux d'imbrication~;
    \item permet d'\'eviter des tests r\'ep\'etitifs~;
\begin{verbatim}
   for (...) {     for (...) {
       ...
       if (catastrophe) goto erreur;
   }
   erreur: printf("c'est la cata..."); 
\end{verbatim}
    \end{itemize}
  \end{itemize}
  \index{Instructions!de rupture de contr\^ole}
  \index{\'Etiquettes}
  \index{\verb?goto?}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Rupture de contr\^ole}
  Instruction {\tt break}~:
  \begin{itemize}
  \item Syntaxe~:
    {\it instruction} :
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt break} \hspace{3mm}{\tt ;}
  \item S\'{e}mantique~:
    \begin{itemize}
    \item provoque l'arr\^{e}t de la premi\`{e}re instruction {\tt for}, {\tt while},
      {\tt do} ou {\tt switch} englobante~;
    \item reprend l'ex\'ecution à\`a l'instruction suivant l'instruction
    	termin\'ee.
    \end{itemize}
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  Instruction {\tt continue}~:
  \begin{itemize}
  \item Syntaxe~:
    \hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\tt continue} \hspace{3mm}{\tt ;}
    \item S\'{e}mantique~:
      \begin{itemize}
      \item uniquement dans une instruction {\tt for}, {\tt while} ou {\tt do}~; 
      \item provoque l'arr\^et de l'it\'eration courante~; 
      \item passage au d\'ebut de l'it\'eration suivante~;
      \item \'equivalent à {\tt goto suite} avec~:
        {\normalsize
\begin{verbatim}
  while(...) {       do {              for(...) {
    ...                ...               ...
  suite: ;            suite: ;           suite: ;
  }                  } while(...);     }
\end{verbatim}
}
\end{itemize}
\end{itemize}
\index{Instructions!de rupture de contr\^ole}
\index{\verb?break?}
\index{\verb?continue?}
\end{frame}
%------------------------------------------------------------------------------
% That's all folks
%------------------------------------------------------------------------------
