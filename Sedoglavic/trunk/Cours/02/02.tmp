

\begin{frame}
    \frameheading{Fonctions et proc\'edures}

 D\'efinition d'une fonction

\begin{itemize}
\item Syntaxe ANSI:

{\it d\'{e}finition-de-fonction-ANSI} :\\
\hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it type-retour} \hspace{3mm}
{\it nom-de-fonction} \\
\hspace*{43mm}{\tt (} \hspace{3mm}
{\it liste-de-param\`etres-typ\'es\/$_{option}$} \hspace{3mm}{\tt )}\\
\hspace*{18mm}\verb+{+\\
\hspace*{18mm}{\it liste-de-d\'{e}clarations\/$_{\hspace{1mm}option}$}\\
\hspace*{18mm}{\it liste-d'instructions}\\
\hspace*{18mm}\verb+}+
\newpage
\item S\'{e}mantique:
  \begin{itemize}
    \item {\it type-retour}: type de la valeur retourn\'ee (quelconque);
    \item {\it liste-de-param\`etres-typ\'es\/$_{option}$}:\\
\hspace*{10mm} liste des param\`etres formels avec leur type;
    \item passage de param\`etres {\em uniquement} par valeur;
    \item {\it liste-de-d\'{e}clarations\/$_{\hspace{1mm}option}$}:\\
\hspace*{10mm} d\'eclaration de variables {\em locales} \`a la fonction;
    \item {\it liste-d'instructions}: corps de la fonction;
  \end{itemize}

\item Retourner une valeur:
  \begin{itemize}
    \item corps doit contenir au moins une instruction: \\
\hspace*{30mm}
     {\tt return} \hspace{3mm}{\it expression} \hspace{3mm}{\tt ;}
    \item r\'esultat ind\'etermin\'e sinon;
    \item \'evalue {\it expression} qui sera la valeur de retour;
    \item rend le contr\^ole d'ex\'ecution \`a l'appelant;
    \item {\it expression}: type {\it type-retour};
  \end{itemize}

\index{D\'efinition!de fonctions}
\index{D\'eclaration!de fonctions}
\index{Fonctions!d\'efinition}
\index{Passage de param\`etres}
%\index{\verb?(,)?}
\end{itemize}

\end{frame}

\begin{frame}

 D\'efinition d'une fonction

\begin{itemize}
\item Syntaxe K\&R:

{\it d\'{e}finition-de-fonction-K\&R} : \\
{\it d\'{e}finition-de-fonction} :\\
\hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it type-retour} \hspace{3mm}
{\it nom-de-fonction} \\
\hspace*{43mm}{\tt (} \hspace{3mm}{\it liste-d'identificateurs\/$_{option}$} \hspace{3mm}{\tt )}\\
\hspace*{18mm}{\it liste-de-d\'{e}clarations\/$_{1 \hspace{1mm}option}$}\\
\hspace*{18mm}\verb+{+\\
\hspace*{18mm}{\it liste-de-d\'{e}clarations\/$_{2 \hspace{1mm}option}$}\\
\hspace*{18mm}{\it liste-d'instructions}\\
\hspace*{18mm}\verb+}+
\newpage
\item S\'{e}mantique: similaire \`a la norme ANSI
  \begin{itemize}
    \item {\it liste-d'identificateurs\/$_{option}$}:\\
\hspace*{10mm} liste des param\`etres formels sans sp\'ecification de type
    \item {\it liste-de-d\'{e}clarations\/$_{1\hspace{1mm}option}$}:\\
\hspace*{10mm} d\'eclaration des types des param\`etres formels
    \item noms identiques dans \\
\hspace*{10mm} {\it liste-d'identificateurs} et
  {\it liste-de-d\'{e}clarations\/$_1$};
    \item si un param\`etre omis dans {\it
        liste-de-d\'{e}clarations\/$_1$}: \\
\hspace*{10mm} type par d\'efaut: {\tt int}
  \end{itemize}

\end{itemize}

\index{D\'efinition!de fonctions}
\index{Fonctions!d\'efinition}
%\index{\verb?(,)?}

\end{frame}

\begin{frame}

 Exemple de d\'efinition de fonction: norme ANSI
\begin{verbatim}
   int sum_square(int i, int j) {
     int resultat;
     resultat = (i * i) + (j * j);
     return resultat;
   }
\end{verbatim}

 Exemple de d\'efinition de fonction: norme K\&R
\begin{verbatim}
   int sum_square(i,j)
     int i,j;           
   {
     int resultat;  

     resultat = (i * i) + (j * j);
     return(resultat);
   }
\end{verbatim}
\newpage
 Remarques
  \begin{itemize}
    \item pas de d\'efinition de fonctions dans des fonctions;
    \item {\tt return} est une instruction comme une autre:\\
\hspace*{10mm} plusieurs utilisations dans le corps d'une fonction
\begin{verbatim}
   int max(int a, int b) {
     if (a > b) return (a); else return(b);
   }
\end{verbatim}
    \item si la derni\`ere instruction ex\'ecut\'ee n'est pas un {\tt
        return}: \\
 \hspace*{10mm} $\Rightarrow$ r\'esultat ind\'etermin\'e
  \end{itemize}

\index{D\'efinition!de fonctions}
\index{Fonctions!d\'efinition}

\end{frame}

\begin{frame}

 Appel \`a une fonction
\begin{itemize}
\item Syntaxe:

{\it expression-appel} :\\
\hspace*{10mm} $\Rightarrow$ \hspace{3mm}{\it nom-de-fonction} 
\hspace{3mm}{\tt (} \hspace{3mm}{\it liste-d'expressions} \hspace{3mm}{\tt )}

\item S\'{e}mantique:
  \begin{itemize}
    \item \'evaluation des expressions de {\it liste-d'expressions};
    \item ordre d'\'evaluation ind\'etermin\'e;
    \item r\'esultats pass\'es en param\`etres effectifs \`a la fonction;
    \item passage par {\em valeur};
    \item contr\^ole d'ex\'ecution pass\'e au d\'ebut de {\it
        nom-de-fonction};
    \item{\it expression-appel}: valeur retourn\'ee par la fonction;  
  \end{itemize}
\newpage
\item Exemples:
\begin{verbatim}
   d = sum_square(a,b) / 2; c = max(a,b); 
\end{verbatim}

\end{itemize}

 Proc\'edures: fonctions avec effet de bord

\begin{itemize}
  \item C ne comporte pas de concept de proc\'edures;
  \item Les fonctions peuvent r\'ealiser tous les effets de bord voulus;
  \item Proc\'edure: fonction qui ne retourne "rien";
  \item Aucune valeur: type de base {\tt void}; 
  \item Pas de {\tt return} dans le corps d'une proc\'edure;
  \item Exemple:
\begin{verbatim}
      void print_add(int i, int j) {...}
\end{verbatim}
\end{itemize}

\index{Appel d'une fonction/proc\'edure}
\index{Fonctions!appel}
\index{Proc\'edures}
\end{frame}


\begin{frame}
  \framesubheading{Instructions de contr\^ole~:   branchement}%
  Les instructions de branchement d\'eterminent quelles instructions
  seront ex\'ecut\'ees et dans quel ordre.
    \begin{center}
  \begin{tabular}{ll}
      \begin{tabular}{l}
        \textbf{if(} \texttt{condition 1} \textbf{)}\\
        \qquad \texttt{instruction 1} \\
        \textbf{else if(} \texttt{condition 2} \textbf{)}\\
        \qquad \texttt{instruction 2} \\
        \textbf{\ldots} \\
        \textbf{else} \texttt{instruction n} \\
      \end{tabular}  &
      \begin{tabular}{l}
        \textbf{switch(} \texttt{expression} \textbf{)}\\
         \textbf{\{} \\
        \qquad  \textbf{case} \texttt{cste} \textbf{:} 
        \texttt{instruction(s) 1} \textbf{break~;}\\
        \textbf{\ldots} \\
        \qquad \textbf{default} \textbf{:} \texttt{instruction(s)} 
        \textbf{break} \\
        \textbf{\}}
      \end{tabular}
    \end{tabular}
  \end{center}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \framesubheading{Instructions de  contr\^ole~:     it\'erations}%
  Les boucles permettent de r\'ep\'eter une s\'erie d'instructions
  tant qu'une condition n'est pas v\'erifi\'ee.
  \begin{itemize}
  \item it\'eration \'enum\'erative \\
    \begin{tabular}{l}
      \textbf{for(} \texttt{expr 1} \textbf{;} \texttt{expr 2} \textbf{;} 
      \texttt{expr 3} \textbf{)} \\
      \qquad \texttt{instructions} 
    \end{tabular}
  \item It\'eration conditionnelle test\'ee en d\'ebut de boucle \\
    \begin{tabular}{l}
      \textbf{while} (\texttt{condition}) \\
      \qquad \texttt{instructions} \\
    \end{tabular}
  \item It\'eration conditionnelle test\'ee en fin de boucle \\
    \begin{tabular}{l}
      \textbf{do} \\
      \qquad \texttt{instructions} \\
      \textbf{while (} \texttt{condition} \textbf{) ;} 
    \end{tabular}
  \end{itemize}
\end{frame}
