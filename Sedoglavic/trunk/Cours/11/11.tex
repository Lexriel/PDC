%---------------------------------------------------------------------------
\svnidlong 
{$HeadURL: https://svn.fil.univ-lille1.fr/svn/sedoglav_PDC/trunk/Cours/11/11.tex $} 
{$LastChangedDate: 2012-12-06 15:08:06 +0100 (Thu, 06 Dec 2012) $} 
{$LastChangedRevision: 84 $} 
{$LastChangedBy: sedoglav $} 
\svnid{$Id: 11.tex 84 2012-12-06 14:08:06Z sedoglav $} 
%------------------------------------------------------------------------------
\newcommand{\reponse}[4]{%
  Ce bout de code 
  \begin{itemize}
  \item provoque une erreur \`a
    \begin{itemize}
    \item la compilation~: #1
    \item l'ex\'ecution~: #2
    \end{itemize}
  \item fait ce qu'il devrait~: #3
  \end{itemize}
  #4
}
\newcommand{\suspens}[1]{
  \begin{overprint}
    \onslide<1>
    \reponse{}{}{}{}%
    \onslide<2>
    #1
  \end{overprint}
}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{R\`egles du jeu}
   Les bouts de codes se pr\^etent aux commentaires.
   \par
   On cherche \`a savoir si ces codes
  \begin{itemize}
  \item provoquent une erreur \`a
    \begin{itemize}
    \item la compilation,
    \item l'ex\'ecution~; 
    \end{itemize}
  \item font ce qu'il devrait.
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\section{Pr\'eprocessing}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#define MAX = 10 ;
int t[MAX], x = MAX ;
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    { Une macro n'est ni une d\'eclaration ni une initialisation mais
      provoque une substitution textuelle.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#define add (a,b) (a + b)

int main(void){
   return add(1,2) ;
}
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    { L'espace est le s\'eparateur entre l'identificateur de macro et
      la cha\^\i{}ne \`a substituer.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#define CARRE(a) ((a) * (a))
int main(void){
   int x = 2 ;
   return CARRE(x++) ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {M\^eme bien constitu\'ee une macro n'immunise pas contre l'effet
      lat\'eral.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\section{Lisibilit\'e du code}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
/* On veut retourner 1 */
int main(void){
   int a=0, b=0, res ;

   if (a) 
      if (b)  res = !b ;
   else  res = !a ;

   return res ;
}
\end{verbatim}
  \suspens{ \reponse{non}{oui}{}%
    {Il est difficile de savoir \`a quel if se vouer, alors autant
      utiliser des blocs.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void){
  char c ;
  while (c = getchar() != EOF) putchar(c) ;
  return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {Il faut rendre lisible le code plut\^ot que de compter sur la
      priorit\'e entre les op\'erateurs.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\section{Efficacit\'e du code}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
/* On veut parcourir une cha\^ine de caract\`eres */
int
main
(void)
{ int i ;
  char * bibi="La vie est belle" ;
  for(i=0;i<strlen(bibi);i++);
  return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {C'est un parcours en~$n^{2}$~!!!!!! \`A \'eviter
      imp\'erativement.
      \par\medskip
      Utilisez les fonctions de la libraire standard \`a loisir
      apr\`es les avoir comprises (i.e.\ apr\`es votre cours de
      pratique des syst\`emes).}%
  }
\end{frame}
%------------------------------------------------------------------------------
\section{Syntaxe}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void){
  int a=1,b=1 ; 
  if(a=0) 
     printf("Attention z\\'ero") ;
  else b /= a ;
  return b ;
}
\end{verbatim}
  \suspens{
    \reponse{non}{non}{non}%
    {L'affectation est un op\'erateur et non une instruction.}%
}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
/* on veut retourner 0 */
int main(void){
   char a=1,b=0 ;
   switch(a){
      case 1 : a = b;
      defau1t : return 1 ; 
   }
   return a  ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {L'existence du \texttt{goto} et l'usage du \texttt{break}
      induisent cette erreur difficilement d\'etectable (sans l'aide
      des avertissements du compilateur).}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int tab[12] = {
   1, 2, 3, 4,
   5, 6, 7, 8,
   9,10,11,12
 } ;

int main(void){ /* on veut retourner 3 */
  int i=2,j=2 ;
  return tab[i++,j++] ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {La virgule est l'op\'erateur qui d\'elivre comme r\'esultat
      l'op\'erande droit apr\`es avoir \'evalu\'e l'op\'erande
      gauche.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
/* On veut retourner 2 au shell */
int main(void){
    return fct(2) ; 
}

int fct(int i){ 
    return i ; 
}
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    {La fonction \texttt{fct} devrait \^etre d\'eclar\'ee par un
      prototype avant la fonction principale.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int pair(int i){
   if (i)
      return impair(i-1) ;
   return 1 ;
}

int impair (int i){ 
   if (i)
      return pair(i-1) ;
   return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    {Encore une fois, un prototype permet de fournir au compilateur la
      d\'eclaration qui lui manque.}%
 }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
typedef int fct_t (int) ;

fct_t fct ;

int main(void){
     return fct(2) ;
}

int fct(int i){
    return i ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {Un prototype de fonction est une d\'eclaration.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int fct(int i){ 
    return i ; 
}

int main(void){
     fct(2) ; 
   return 0 ;
}

\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {M\^eme si la fonction \texttt{fct} retourne une valeur, rien ne
      nous force \`a la r\'ecup\'erer.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int MaVar = 1 ;

int main(void){
   return ++Mavar ;
}
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    {Les identificateurs sont sensibles \`a la casse.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int var(void){ return 2;}
int main(void){ 
    int a = 10, var = 1, cinq = a/var ;
    return cinq ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {La port\'e des identificateurs n'est pas un vain mot.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int deux(void){ return 2 ; }

int main(void){ 
    int (*deux) = deux ; 
    return deux ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Ce code retourne une adresse.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
On souhaite retourner la somme de deux entiers
   saisis au clavier.
\begin{verbatim}
int 
main(void){ 
    int a=0, b=0 ;
    scanf("%d%d",a,b) ;
    return a+b ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Le passage de param\`etre par r\'ef\'erence permet d'exporter de
      l'information d'une fonction.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int SommeDes10Premiers(int tab[10]) {
int i, res =0 ;
for(i=1;i<11;i++)
   res += tab[i] ;
   return res ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Les indices de tableaux commencent \`a~$0$ et rien ne vous
      emp\^eche de passer outre.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void){
     int zero = 0 ;
     int tab[5] = {1,2,3,4,10} ;
     zero = 0[tab] + *(tab+1) + *(2+tab) + tab[3] - 4[tab];
     return zero ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    { La notation \texttt{tab[1]} est \'equivalente \`a \verb?*(tab+1)?
      ce qui permet ce code surprenant.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#include<stdio.h>
int main(void){
     int i = 7, a[5]; char c = 0 ;
/* qu'est qui est affich\'e */
     printf( "%d", i++ * i++ );
/* comment est modifi\'e ce tableau */
     i = 1; a[i] = i++;
/* ce code peut il s'arr\^eter */
     do { c = getchar(); } while(c != EOF) ;
  return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{???}%
    { Si on ne lit pas la documentation du compilateur ou
      l'assembleur, il existe des questions sans r\'eponses i.e.\ la
      norme ne sp\'ecifie pas tout.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
/* ce code retourne 100 */
int main(void){
   i=0 ; j=1 ;
   while(i<100) ;
      i=i+j ;
   return i ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Attention aux trivialit\'es.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
char foo[10] = '\0' ;
char bar[10] = "\0" ;

int * ptr1, * ptr2  ; 
int * pptr1,  pptr2 ;
pptr1 = ptr1 ;
pptr2 = ptr2 ;
\end{verbatim}
  \suspens{ \reponse{}{}{}%
    {De petites  diff\'erences produisent de grands effets.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int *a[10] ;
int (*b)[10] ;
b[9]=a[0] ;
\end{verbatim}
  \suspens{ \reponse{oui}{}{}%
    {La compilation signale error: incompatible types in assignment.
En effet, le pointeur d'entier a[0] pourrait ''avoir'' plus de~$10$ cellules.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void){
/* Emboitemement de /* commentaire */ */
int a,b,c = 3;
int *pointer = &c ;
   /*divise c par lui m\^eme */
   a=c/*pointer ;
   b=c /*met b \`a 3*/ ;
   return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Attention aux commentaires.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#include<stdio.h>
char *foo(void){
    char str[31]="Pourquoi vais-je disparaitre~?" ;
    return str ;
}

int main(void){
   printf("%d %d %s\n",1,2,foo()) ;
   return 0;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Le compilateur indique que \texttt{warning: function returns
        address of local variable}.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int 
main
(void)
{
   char *str = "stringX" ;
   str[6]='Y' ;
   return 0;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {La cha\^\i{}ne "stringX" est stock\'ee dans un segment
	en lecture seule (.rodata) et la tentative d'acc\`es
	se solde par un \texttt{segmentation fault}.}%
}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#include<stdio.h>
struct tab_s{  int tab[2] ; } ;

struct tab_s foo(void){
    struct tab_s res ;
    res.tab[0] = 1 ; res.tab[1] = 2 ;
    return res ;
}

int main(void){
   struct tab_s tmp = foo() ;
   int zero = 2*tmp.tab[0] - tmp.tab[1] ;
   return  zero ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{oui}%
    {On ne peut affecter un tableau \`a un autre, c'est possible 
     pour les structures.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
Ce code retourne la taille de la cha\^\i{}ne de caract\`eres
\begin{verbatim}
int main(void){
   char *ch1 = "Hello world";
   return sizeof(ch1) ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {N'utilisez \texttt{sizeof} que sur des types.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
Une implantation de \verb+memset+
\begin{verbatim}
void *memset(void *b, int c, int len)
{
  int i ;
  for(i=0;i<len;i++)
     b[i]=c ;
  return b ;
}
\end{verbatim}
\suspens{
  \reponse{non}{}{}%
  {Ni arithm\'etique ni d\'er\'ef\'erencement de pointeur void}.%
}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void){  
   int *p ;
   p = malloc(10*sizeof (int));
   p[10] = 666 ; 
   return 0 ;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Affectation hors limite.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
#include<stdio.h>
#include <stdlib.h>
 
/* strtod, strtof, strtold - convert 
ASCII string to floating point number
float strtof(const char *, char **); */

int main(int argc, char **argv){
  printf("%f\n", strtof(argv[1], NULL)) ;  
  return 0 ;
}
\end{verbatim}
  Si on compile avec l'option ansi, le prototype de la fonction strtof
  --- n'\'etant pas dans cette norme et \'etant \`a l'int\'erieur
  d'une directive conditionnelle --- n'est pas pris en compte.  Sans
  prototype, la valeur de retour de la fonction est suppos\'ee \^etre
  un entier machine et le r\'esultat n'est pas cod\'e comme un
  flottant et donc faux.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int main(void) {
	int i ;
	int tampon[5] ;

	for(i=0;i<666;i++)
		tampon[i]=2 ;
	return 0;
}
\end{verbatim}
  \suspens{ \reponse{non}{non}{non}%
    {Cela provoque une boucle infinie~!!!}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
Le code
\begin{verbatim}
int main(void){
    int tab[10] ;
    int i = 0 ;
    for(;i<300;i++) 
        tab[i] = i ;
    return 0 ;
}
\end{verbatim}
donne l'ex\'ecution suivante~:
\begin{verbatim}
espoir % gcc code.c 
espoir % a.out
Segmentation fault
\end{verbatim}  
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int tab[10]; /* dans le fichier foo */
.....
extern int * tab ; /* dans le fichier bar */
\end{verbatim}
Il n'y a pas d'allocation de m\'emoire lors de la d\'eclaration d'un
pointeur (hormis la m\'emoire utilis\'ee pour contenir l'adresse).
\begin{verbatim}
extern foo; /* ceci est valide (c'est un entier) */
\end{verbatim}
Il existe beaucoup de r\`egles implicites en~C.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int bar(int n) { return n+2 ;}
int 
main
(void)
{
   int (*foo) (int) = bar ;
   foo++ ;
   return foo(1)
}
\end{verbatim}
Quid de l'arithm\'etique des pointeurs de fonctions~?
  \suspens{ \reponse{oui}{}{}%
    {Comme on ne connait pas la taille d'une fonction mais seulement son adresse et que
     cette taille est variable pour de fonctions de m\^eme signature, impossible de faire 
   de l'arithm\'etique des pointeurs de fonctions.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
int
bar
(int n)
{
   int tab[n] ;

   /* comparer avec malloc */
   return ;
}
\end{verbatim}
  \suspens{Il n'y a pas que l'\textsc{ansi} dans la vie.\reponse{oui}{}{}%
    {Ce code est valide en \textsc{c}99.}%
  }
\end{frame}
%------------------------------------------------------------------------------
\end{document}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
\begin{verbatim}
\end{verbatim}
  \suspens{ \reponse{}{}{}%
    {}%
  }
\end{frame}
%------------------------------------------------------------------------------
