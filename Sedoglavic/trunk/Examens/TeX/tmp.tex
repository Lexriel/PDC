

d\'eterminer des~$m$-uplets de
caract\`eres le composant.  Par exemple, si l'on saisi au clavier
(azerty) la phrase~:
\par
\centerline{Longtemps, je me suis couch\'e de bonne heure.}
\par
Les~$3$-uplets sont~: "Lon", "ong", "ngt", "gte", "tem", etc. Les
signes de ponctuations sont pris en compte~: "ps," "s, " et "je " sont
des~$3$-uplets. La taille~$m$ des uplets est d\'efinie par une macro
\verb+#define TailleUplet+.
\par
Pour faire l'analyse de fr\'equence des~$m$ uplets de lettres de ce
texte, nous allons utiliser les \'el\'ements suivants\footnote{ce
  n'est \'evidement pas optimal comme approche.}~:
\begin{itemize}
\item utiliser des cellules contiennent~$3$ informations~:
  \begin{itemize}
  \item un  carat\`ere~;
  \item son \emph{occurence locale}~;
  \item 
  \end{itemize}
,  et a \emph{fr\'equence
    locale} associ\'ee et un pointeur sur la cellule.
\item un arbre de codage d\'efini par
\begin{verbatim}
struct cellule_s *arbre
\end{verbatim}
 de profondeur~\verb+TailleUplet+.


 dans le texte. Cette liste doit \^etre tri\'ee
  suivant l'ordre lexicographique\footnote{comme l'ordre d'un
    dictionnaire.} des~$m$-uplets~;
\item parcourir le texte lettre par lettre et pour chacune~;
  \begin{itemize}
  \item v\'erifier si le~$m$ uplets commencant par cette lettre se
    trouve d\'ej\`a dans la liste~;
  \item si oui, incr\'ementer son occurence,
    \par
    si non, cr\'eer et ins\'erer la nouvelle cellule correspondante
    (l'occurence est alors~$1$)~;
  \end{itemize}
\item pour finir, on parcours la liste afin de calculer les
  fr\'equences (occurence divis\'e par le nombre total de~$m$-uplets).
\end{itemize}
\par\medskip
\paragraph{Question.}
\begin{enumerate}
\item Donnez la d\'eclaration \verb+struct cellule_s+ permettant de
  repr\'esenter une cellule d\'ecrite ci-dessus.
\item Donnez la d\'efinition de la fonction de prototype~:
\begin{verbatim}
    struct cellule_s *analyseDeFrequence(char *,int);
\end{verbatim}
  qui prend en param\`etres le texte \`a analyser et la taille~$m$
  du~$m$-uplet et qui retourne la liste cha\^\i{}n\'ee d\'ecrite
  ci-dessus. Vous pouvez \'ecrire autant de fonctions auxilliaires que
  vous le d\'esirez afin de rendre votre code simple et lisible.
\end{enumerate}
\end{document}
%-------------------------------------------------------------------------------
\section{Un agenda \`a la UNIX}
Un informaticien d\'ecide de se programmer un agenda sur le mod\`ele
d'un syst\`eme de fichiers \`a la UNIX. Pour se faire, il dispose d'un
espace m\'emoire~:
\begin{verbatim}
bloc_t agenda[NBBLOC]
\end{verbatim}
d\'efini avec une macro~\verb+NBBLOC+ que l'on suppose d\'efinie et un
type~\verb+bloc_t+ que nous allons expliciter.
\par
Un bloc peut \^etre~: un superbloc, un bloc libre, un n\oe{}ud
d'information, un bloc occup\'e ou un r\'epertoire.
\begin{itemize}
\item un bloc libre constituent une liste cha\^\i{}n\'ee, 
\item le superbloc est toujours le premier bloc de l'agenda i.e.\ la
  premi\`ere cellule de ce tableau.

  i.e.\ une structure compos\'e d'un tableau de~\verb+TAILLEBLOC+
  octets (on suppose disposer de cette macro)~;
\end{itemize}

\paragraph{Questions.}




