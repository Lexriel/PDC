\section{Taquinons les files}
\label{sec:TaquinFile}
Dans cette section, nous souhaitons construire un programme permettant
par une recherche exhaustive de r\'esoudre le probl\`eme du taquin.
Pour ce faire, nous allons utiliser la notion de \textit{file}.
\subsection{Implantation d'une file gard\'ee}
\label{sec:file}
Une cellule est compos\'ee d'une structure \texttt{state} de type
\texttt{position\_t} (qui sera d\'ecrit dans la
section~\ref{sec:taquin}) et d'un pointeur nomm\'e \texttt{next} sur
une autre cellule.
\par
Une file gard\'ee est constitu\'ee de~$2$ pointeurs~; le premier de
ces pointeurs a pour identificateur \texttt{tail} et pointe sur une
cellule qualifi\'ee de \textit{queue} de file. Le second a pour
identificateur \texttt{head} et pointe sur une cellule qualifi\'ee de
\textit{t\^ete} de file. Une file est vide lorsque les pointeurs
\texttt{tail} et \texttt{head} pointent sur \texttt{NULL}.
\paragraph{Fonctions de manipulation de la file.}
La file peut \^etre manipul\'ee gr\^ace aux fonctions suivantes dont
on donne le prototype~:
\begin{itemize}
\item \verb?void initfile(struct file_t *)? initialise une file
  d\'ej\`a d\'efinie comme \'etant vide~;
\item \verb?struct cellule_t * creercellule(struct position_t *)?
  construit une cellule en allouant la m\'emoire n\'ecessaire, en
  affectant \texttt{next} \`a \texttt{NULL} et en copiant les
  informations fournies par le param\`etre dans le champs
  \texttt{state}~;
\item \verb?int estvide(struct file_t *)? retourne~$1$ si la file est
  vide,~$0$ sinon~;
\item \verb?void ajouter(struct file_t *, struct cellule_t *)?
  ins\`ere une cellule~A dans la file.  Si la file est vide les
  pointeurs \texttt{tail} et \texttt{head} pointent sur la cellule~A.
  Sinon, le pointeur \texttt{next} de la cellule~A pointe vers la
  cellule point\'ee par \texttt{tail} et ce dernier pointeur est
  modifi\'e afin de pointer sur la cellule~A~;
  \item \verb?struct position_t * examiner(struct file_t *)? retourne un
  pointeur sur la position stock\'ee en t\^ete de la file~;
\item \verb?void supprimer(struct file_t *)? supprime la cellule de
  t\^ete de la file.  Si la file n'a qu'une cellule, on la supprime et
  on fait pointer la t\^ete et la queue sur \texttt{NULL}. Sinon, on
  parcours la file pour placer la t\^ete sur l'avant derni\`ere
  cellule et on supprime la derni\`ere cellule.
\end{itemize}

\paragraph{Questions.}
\begin{enumerate}
\item Donnez la d\'eclaration des types \texttt{cellule\_t} et
  \texttt{file\_t} d\'ecrits ci-dessus.
\item Donnez les d\'efinitions des~$3$ fonctions~:
  \begin{itemize}
  \item \verb?struct cellule_t * creercellule(struct position_t *)?
  \item \verb?void ajouter(struct file_t *, struct cellule_t *)? 
  \item \verb?void supprimer(struct file_t *)?
  \end{itemize}
  d\'ecrites ci-dessus.
\end{enumerate}

\subsection{Jeu de taquin}
\label{sec:taquin}
Un jeu de taquin est constitu\'e d'une grille de~$9$ cases contenant
des \textit{jetons} i.e.\ les entiers de~$0$ \`a~$8$~:
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    3 & 7 & 4 \\ \hline 
    0 & 1 & 8 \\ \hline 
    2 & 5 & 6 \\ \hline 
  \end{tabular}
\end{center}
L'entier~$0$ correspond \`a une case vide qui peut \^etre
\textit{d\'eplac\'ee} en l'\'echangeant avec une case voisine. Ainsi,
en d\'epla\c{c}ant la case vide vers la droite dans la position
ci-dessus, on obtient la position~:
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    3 & 7 & 4 \\ \hline 
    1 & 0 & 8 \\ \hline 
    2 & 5 & 6 \\ \hline 
  \end{tabular}
\end{center}
Le d\'eplacement en diagonale n'est pas autoris\'e.  L'objectif du jeu
est de parvenir \`a la position suivante (que l'on qualifie de
\textit{gagnante})~:
\begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    1 & 2 & 3 \\ \hline 
    4 & 5 & 6 \\ \hline 
    7 & 8 & 0 \\ \hline 
  \end{tabular}
\end{center}
\paragraph{Codage du jeu.}
Pour continuer, il nous faut pr\'eciser ce que l'on entend par
\textit{position}. Une position est une structure de type
\texttt{position\_t} qui contient les champs suivants~:
\begin{itemize}
\item un tableau bidimensionnel \texttt{grille} repr\'esentant la
  grille dont chaque case peut contenir un entier et donc un jeton.
  Par convention on pose que la case correspondant \`a
  \texttt{grille[i][j]} est \`a l'intersection de la~${(i+1)}$i\`eme
  ligne et de la~${(j+1)}$i\`eme colonne~;
\item un pointeur \texttt{solution} pointant sur une cha\^\i{}ne de
  caract\`eres. Notons qu'en cours d'ex\'ecution, cette cha\^\i{}ne
  est uniquement constitu\'ee des caract\`eres 'h', 'b', 'g' et~'d'.
  Ces caract\`eres repr\'esentent chacun un d\'eplacement ('h' pour
  haut, etc.)~;
\item un tableau \texttt{casevide} de deux cellules contenant les
  coordonn\'ees de la case vide. Ainsi si \texttt{casevide} est~${\{0,1\}}$ la
  case vide se trouve \`a l'intersection de la premi\`ere ligne et de
  la seconde colonne.
\end{itemize}
\paragraph{Fonctions de manipulation.}
Pour manipuler une position, on a besoin des fonctions suivantes~:
\begin{itemize}
\item \verb?int gagne(struct position_t *)? retourne~$1$ si la
  position est gagnante et~$0$ sinon~;
%\item \verb?int sontegales(struct position_t *, struct position_t *)? %
%  retourne~$1$ si la premi\`ere position pass\'ee en param\`etre est
%  \'egale \`a la seconde et~$0$ sinon (deux positions sont \'egales
%  si, et seulement si, les grilles sont les m\^emes)~;
\item \verb?char * concat(char *, char)? prend en entr\'ee un d\'ebut
  de solution (disons \verb?"db"?), un d\'eplacement (\verb?'h'?) et
  retourne un pointeur sur la nouvelle solution ainsi form\'ee
  (\verb?"dbh"?) pour laquelle de la m\'emoire aura \'et\'e
  r\'eserv\'ee (l'ancienne solution n'est pas modifi\'ee)~;
\item \verb?char * deplacementpossible(int *)? qui \'etant donn\'ee
  la case vide (dans la premi\`ere position d\'ecrite dans cette
  section par exemple) retourne une cha\^\i{}ne de caract\`eres
  regroupant l'ensemble des d\'eplacements possibles (\verb?"hdb"?).
  Pour faire simple, cette fonction peut recenser par des
  conditionnelles l'ensemble des cas possibles~;
\item \verb?struct position_t nouvelleposition(struct position_t, char)? % 
  retourne une nouvelle position d\'etermin\'ee par l'ancienne
  position et le d\'eplacement pass\'e en param\`etre (tous les
  champs de la nouvelle position doivent \^etre r\'eactualis\'es et
  l'ancienne position n'est pas affect\'ee).
\end{itemize}
\par\medskip
Pour r\'esoudre le probl\`eme du taquin on propose d'utiliser
l'algorithme suivant~:
\begin{enumerate}
  
\item Construisez une cellule \`a partir de la position initiale et
  ajouter la dans une file vide.
\item Examiner la position de t\^ete de la file. Si elle est gagnante,
  aller \`a l'\'etape~4. Sinon, aller \`a l'\'etape~3.
\item D\'eterminer l'ensemble des d\'eplacements possibles. Pour
  chacun d'entre eux, cr\'eer une nouvelle position associ\'ee \`a ce
  d\'eplacement et une nouvelle cellule contenant cette derni\`ere~;
  ajouter cette cellule \`a la fille.
\item C'est fini. Il ne reste qu'\`a afficher la solution trouv\'ee.
\end{enumerate}
\paragraph{Questions.}
\begin{enumerate}
\item Donnez la d\'eclaration du type \texttt{position\_t}.
\item Donnez les d\'efinitions des~$3$ fonctions de manipulation~:
  \begin{itemize}
  \item \verb?int gagne(struct position_t *)?
  \item \verb?char * concat(char *, char)?
  \item \verb?struct position_t nouvelleposition(struct position_t, char)?
  \end{itemize}
   d\'ecrites ci-dessus.
\item Donnez la d\'efinition de la fonction %
  \verb?char * solve(struct position_t);? qui r\'esoud le
  probl\`eme du taquin.
\end{enumerate}
