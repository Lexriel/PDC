\section{Arbre binaire~: cr\'eation et destruction}
\label{sec:ArbreBinaire}
On se propose de donner du code permettant d'implanter une certaine
sorte arbre binaire.  L'exercice porte sur la construction et
l'utilisation de type ainsi que l'usage des fonctions \verb+void * malloc(int)+ et
\verb+void free(void *)+. Seule la toute derni\`ere question n\'ecessite un peu
d'algorithmique simple.
\par
Nos arbres sont des structures de donn\'ee constitu\'ees de cellules
chacune constitu\'ee par~:
\begin{itemize}
\item deux pointeurs d'identificateur \verb+fillegauche+ et
  \verb+filledroite+ pointant sur une cellule ou sur \verb+NULL+ si la
  cellule n'a ni fille gauche ni fille droit~;
\item une structure (au sens~C du terme) de type \verb+data_t+ et
  d'identificateur \verb+data+~;
%\item un pointeur sur des caract\`eres (i.e.\ une cha\^ine de caract\`eres) d'identificateur \verb+string+.
\end{itemize}
\paragraph{Questions.}
\begin{enumerate}
\item Donner la d\'eclaration du type \verb+cellule_t+ qui
  repr\'esente une cellule.
\ifcorrection
\begin{correction}
\begin{verbatim}
typedef struct cellule_m cellule_t ;
struct cellule_m
{
cellule_t *fillegauche ;
cellule_t *filledroit ;
data_t data ;
} ;
\end{verbatim}
\end{correction}
\fi
\item Donner la d\'efinition d'une fonction d'identificateur
\verb+CreerCellule+ qui~:
\begin{itemize}
\item prend en param\`etre un objet de type \verb+data_t+~;
%et un pointeur pointant sur une cha\^\i{}ne de caract\`eres~;
\item alloue sur le tas l'espace m\'emoire n\'ecessaire \`a un objet
  de type \verb+cellule_t+ pour contenir les donn\'ees pass\'ees en
  param\`etre~;
\item affecte \`a \verb+NULL+ les pointeurs de cellule~;
\item affecte le champs \verb+data+ de cet objet gr\^ace
  aux param\`etres de la fonction~;
\item retourne un pointeur sur l'objet ainsi cr\'e\'e sur le tas.
\end{itemize}
\ifcorrection
\begin{correction}
\begin{verbatim}
cellule_t *
CreerCellule
(data_t d)
{
  cellule_t *res ;
  res = (cellule_t *) malloc(sizeof(cellule_t)) ;
  if (!res) return NULL ;
  res->fillegauche = res->filledroite = NULL ;
  res->data = d ;
  return res ;
}
\end{verbatim}
\end{correction}
\fi
\item Donner la d\'efinition d'une fonction de prototype~:
\begin{verbatim}
  void DetruireCellule(cellule_t **) ;
\end{verbatim}
qui permet de d\'esallouer l'espace m\'emoire associ\'e tout affectant \`a~\verb+NULL+ au pointeur point\'e par le param\`etre de cette fonction.
\ifcorrection
\begin{correction}
\begin{verbatim}
void
DetruireCellule
(cellule_t **cell)
{
  if(!*cell)
    free(*cell) ;
  *cell = NULL ;
  return ;
}
\end{verbatim}
\end{correction}
\fi
\item Donner la d\'efinition d'une fonction d'identificateur
  \verb+DetruireArbre+ qui prend en param\`etre un pointeur sur un pointeur sur une
  cellule (la racine d'un arbre), retourne le nombre de cellules
  constituant l'arbre associ\'e et d\'etruit ce dernier. Les pointeurs r\'ef\'erencant l'arbre doivent \^etre mis \`a~\verb+NULL+. 
\ifcorrection
\begin{correction}
\begin{verbatim}
int
DetruireArbre
(cellule_t **root)
{
  int nb = 1 ;
  if(!*root)
    return 0 ;
  nb = DetruireArbre((*root)->fillegauche) + DetruireArbre((*root)->filledroite) ;
  DetruireCellule(root) ;
  return nb ;
}
\end{verbatim}
\end{correction}
\fi
\end{enumerate}

