La taille d'une matrice carr\'ee creuse n'est pas connue \`a la
compilation mais seulement lors de sa cr\'eation.  Les coefficients de
cette matrice sont des entiers machines sign\'es.

On repr\'esente une matrice carr\'ee creuse sous la forme d'un tableau
dont chaque \'el\'ement correspond \`a une ligne de la matrice.

Pour chaque ligne d'une matrice, on stocke la liste
cha\^\i{}n\'ees des \'el\'ements non nuls de cette ligne. Un
\'el\'ement d'une ligne est form\'e d'un couple (indice de colonne,
valeur).  Chaque liste est tri\'ee suivant la valeur de l'indice.

% La figure \ref{matcreuse} pr\'esente un exemple d'une telle repr\'esentation.

% \begin{figure}[h]
% \begin{center}
% \includegraphics[width=0.6\textwidth]{matcreuse.idraw}
% \end{center}
% \caption{Repr\'esentation d'une matrice carr\'ee creuse.\label{matcreuse}}
% \end{figure}
\paragraph{Questions.}
\begin{enumerate}
\item \'Ecrire le type \verb?MatriceCreuse_t? repr\'esentant une
  matrice carr\'ee creuse comme d\'ecrit ci-dessus, ainsi que les
  types \verb+ligne_t+ et \verb?element_t? correspondant \`a une ligne
  et \`a un \'el\'ement de la liste cha\^\i{}n\'ee constituant la
  ligne.

\item \'Ecrire une fonction de prototype
  \verb+void freemat(MatCreuse_t)+ qui lib\`ere l'espace m\'emoire
  associ\'e \`a la matrice creuse pass\'ee en param\`etre.

\item \'Ecrire une fonction
  \verb?void multscal(int a, MatriceCreuse_t M)? qui r\'ealise la
  multiplication de \verb?M? par le scalaire \verb?a?. Les
  \'el\'ements de \verb?M? sont directement modifi\'es par cette
  proc\'edure.  La multiplication d'une matrice par un scalaire
  revient \`a multiplier chaque \'el\'ement de la matrice par ce
  scalaire.

% \item 
%   \'Ecrire une fonction \verb?int *multvect(MatriceCreuse_t M, int *v)? qui
%   r\'ealise la multiplication matrice-vecteur de \verb?M? par \verb?v?.
%   Cette fonction alloue le vecteur r\'esultat et renvoie un pointeur sur 
%   son premier \'el\'ement. Comme la matrice est carr\'ee, la taille de
%   \verb?v? et celle du vecteur r\'esultat sont \'egales \`a la taille des
%   dimensions de la matrice. Soit $n$ cette taille, le vecteur r\'esultat
%   $R$ est tel que $R[i] = \sum_{j=0}^{n} M[i][j] \times v[j]$ pour $0
%   <= i < n$.

\item 
  
  \'Ecrire une fonction
  \verb?MatriceCreuse_t convert(int M[][], int n)? qui convertit une
  matrice carr\'ee pleine~\verb?M? de taille~\verb+n+ en une matrice
  creuse et renvoie le r\'esultat. Cette fonction r\'ealisera toutes
  les allocations dynamiques n\'ecessaires. Nous supposons ici que
  nous sommes en C-Ansi, ainsi \verb?convert? peut renvoyer une
  structure \verb?MatriceCreuse_t?.

% \item 
   
% \'Ecrire une fonction \verb?MatriceCreuse_t transpose(MatriceCreuse_t M)? qui
%   calcule la transpos\'ee de \verb?M? et renvoie le r\'esultat. La
%   transpos\'ee d'une matrice carr\'ee est une matrice carr\'ee de m\^eme
%   taille o\`u lignes et colonnes ont \'et\'e interverties.
\end{enumerate}
\ifcorrection
\paragraph{Corrections.}
\begin{enumerate}
\item 
\begin{verbatim}
struct listecouple_m{
   unsigned int           indice ;
   int                    coeff  ;
   struct listecouple_m * next   ;
} ;

typedef struct couple_m couple_t

typedef couple_t * ligne_t ;

struct MatriceCreuse_m{
   unsigned int taille ; /* pour savoir combien il y a de ligne */
   ligne_t ligne ;
} ;
typedef struct MatriceCreuse_m MatriceCreuse_t
\end{verbatim}
\item 
\begin{verbatim}
void freecoefflist(couple_t * cell)
{
    if(cell) return ;
    freecoefflist(cell->next) ;
    free(cell) ;
    return ;
}
void freemat(MatCreuse_t M)
{
   unsigned int lignecourante ;
   for(lignecourante=0;lignecourante<M.taille;lignecourante++) 
         freecoefflist(M.ligne[lignecourante]) ;
   free(M.ligne) ;
   return ;
}
\end{verbatim}
\item 
\begin{verbatim}
void multscal(int a, MatriceCreuse_t M)
{
   unsigned int lignecourante ;
   couple_t coeffcourant ;
   for(lignecourante=0;lignecourante<M.taille;lignecourante++) 
   {
     coeffcourant = M.ligne[lignecourante] ;
     while(coeffcourant) ;
     {
       coeffcourant->coeff *= a             ;
       coeffcourant         = M.ligne->next ;
     }
   }
   return ; 
}
\end{verbatim}
%\item
\item 
\begin{verbatim}
couple_t *creercellule(unsigned int indice,int coeff)
{
  couple_t *res ;
  res = (couple_t *) malloc(sizeof(couple_t)) ;
  res.indice = indice ;
  res.coeff  =  coeff ;
  res.next   =   NULL ;
  return res ;
}

MatriceCreuse_t convert(int M[][], int n)
{
   MatriceCreuse_t mat ;
   unsigned int i,j ;
   couple_t *head, *tail ;

   mat.taille = n ;
   mat.ligne  = (ligne_t *) malloc(sizeof(couple_t)*n) ;

   for(i=0;i<mat.taille;i++) 
   { 
     head = NULL ;
     for(j=0;j<mat.taille;j++)
        if(M[i][j])
        {
          if(head==NULL)
             head = tail = creercellule(i,M[i][j]) ;
          else 
          {
             tail->next = creercellule(i,M[i][j]) ;
             tail = ptr->next ;
          }
        }
     mat.ligne=ptr.head ;
   }
}
\end{verbatim}
\end{enumerate}
\fi
