\section{D\'ecompression d'un texte compress\'e par ajout de pr\'efixe}
On  consid\`ere dans la  suite des cha\^\i{}nes  de caract\`eres ASCII
exclusivement  compos\'ees  de lettres    (elles ne  comportent  aucun
chiffre).
\par
Une m\'ethode  primaire  de  compression  consiste \`a  rep\'erer  les
motifs r\'ep\'et\'es  dans  la  cha\^\i{}ne  \`a  compresser  puis \`a
construire  une  nouvelle   cha\^\i{}ne   constitu\'ee  du  nombre  de
r\'ep\'etitions suivi du motif. Par exemple, la cha\^\i{}ne~:
\begin{verbatim}
AAAAAAAAAABABABCCD
\end{verbatim}
est compress\'ee en
\begin{verbatim}
10A2BA1B2C1D
\end{verbatim}
\paragraph{Question.}
Construire une fonction qui prend    en argument un pointeur sur   une
cha\^\i{}ne de  caract\`eres  compress\'ee et qui renvoit  un pointeur
sur une nouvelle cha\^\i{}ne de caract\`eres non compress\'ee.
\par\smallskip
Vous pouvez utiliser la fonction \verb+malloc+ d'allocation m\'emoire de la librairie standard.
\ifcorrection
\begin{correction}
\newpage
\begin{verbatim}
#include<stdio.h>
#include<stdlib.h>

int 
char2int(char **str)
{
  int res;
  res = 0;
  for (; (**str >= '0') && (**str <= '9'); (*str)++)
  res = 10 * res + **str - '0';
  return res;
}

char *
cmp2noncmp(char *cmp)
{
  char *tmp, *res ;
  int lc, foo, bar ;
  tmp = cmp ;
  lc = 0 ;
  bar= 0;
  while (*tmp != 0)
    {
      foo= char2int(&tmp);
      while((*tmp != 0) && (*tmp - '0' < 0 ||  * tmp - '9' > 0)) 
	{
	  tmp++;
	  bar++;
	}
      lc += bar * foo;
    }
  res = (char *) malloc((lc + 1) * sizeof(char));
  bar = 0;
  while (*cmp!=0) 
    {
    foo = char2int(&cmp);
      while (foo -- > 0) 
	{
	  tmp= cmp;
	  while ((*tmp != 0) && (*tmp - '0' < 0 || * tmp - '9' > 0))
	    * (res + bar++) = *(tmp++);
	}
      cmp= tmp;
    }
  *(res + bar)= 0;
  return res;
}
\end{verbatim}
\end{correction}
\fi