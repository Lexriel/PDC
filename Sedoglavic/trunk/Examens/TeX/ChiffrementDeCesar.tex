\section{Chiffrement de C\'esar}
\subsection{\'Echauffement}
\input{TeX/Quizz_7}
\subsection*{Le principe du chiffrement de C\'esar.}
\'Etant donn\'e un entier positif~$n$, ce codage consiste \`a
remplacer chaque lettre d'un texte par la lettre qui se situe~$n$
places plus loin dans l'alphabet. Par exemple avec un d\'ecalage
de~$7$, on obtient~:
\par
\begin{center}
\begin{tabular}{cccccccc}
Clair & T & A & Q & U & E \\
%D\'ecalage & 7 & 7 & 7 & 7 & 7 \\
Chiffr\'e &  [ & H & X & $\setminus$ & L
\end{tabular}
\end{center}
Ainsi, le texte clair~T (code \textsc{ascii}~$84$) est chiffr\'e par
le texte~[ (code \textsc{ascii}~$91$).
\subsection{Chiffrement.}
Donnez la d\'efinition de la fonction de prototype~:
\begin{verbatim}
char *chiffrer_cesar(const char *clair, int decalage) ;
\end{verbatim}
qui prend en param\`etre une cha\^\i{}ne de caract\`eres non cod\'ee
et retourne son chiffr\'e (sans d\'etruire le clair).  
\ifcorrection
\begin{correction}
\begin{verbatim}
char *
chiffrer_cesar
(char *clair, int decalage) 
{
  int i ;
  char *chiffre ;

  for(i=0;clair[i];i++) ;

  chiffre = (char *) malloc(i+1) ;

  for(i=0;clair[i];i++) 
    chiffre[i] = clair[i] + decalage ;

  return chiffre;
}
\end{verbatim}
\end{correction}
\fi
\subsection{D\'echiffrement.}
Utiliser la fonction de chiffrement pour implanter l'op\'eration
inverse dans la fonction de prototype~:
\begin{verbatim}
char *dechiffrer_cesar(char *chiffre, int decalage) ;
\end{verbatim}
\ifcorrection
\begin{correction}
  Au lieu d'ajouter le d\'ecalage, il suffit de le retrancher.
\end{correction}
\fi
\subsection{Premier pas vers le cassage du code.}
Donnez la d\'efinition de la fonction de prototype~:
\begin{verbatim}
char calcul_frequence(char *texte, float frequences_calculees[]) ;
\end{verbatim}
qui calcule les fr\'equences de chaque lettre de la table des
caract\`eres ASCII (de~$0$ \`a~$255$) dans le texte et les stocke dans
la table \verb+frequences_calculees+. (On pourra d\'ej\`a calculer
l'occurrence de chaques lettre pour en d\'eduire les fr\'equences
d'apparitions).  De plus, cette fonction doit retourner la lettre la
plus fr\'equente.
\ifcorrection
\begin{correction}
\begin{verbatim}
  char 
  calcul_frequence
  (char *texte, float frequences_calculees[]) 
  {
    int taille,i,plusfreq ;

    /* initialisation du tableau */
    for(i=0;i<256;i++)
       frequence_calculees[i]=0 ;

    taille = 0 ;
    while(*texte)
    {
      taille++ ;
      frequences_calculees[(int) (*texte)]++ ;
    }

    plusfreq = 0 ;
    for(i=0;i<256;i++)
    {
      frequence_calculees[i]/=taille ;
      if(frequence_calculees[plusfreq]<frequence_calculees[i])
      plusfreq=i ;
    }
      
    return (char) plusfreq ;
  }
\end{verbatim}
\end{correction}
\fi
\subsection{Calcul du d\'ecalage moyen}
On suppose disposer d'une table cod\'ee par le tableau \texttt{float
  french[255]} qui contient la probabilit\'e d'occurrences des lettres
de la table ASCII en fran\c{c}ais. Par exemple, \texttt{french['e']}
contient~$0,1486$, \texttt{french[' ']} contient~$0,1835$ et
\texttt{french['u']} contient~$0,0506$.  Ainsi, pour un texte
de~$1000$ caract\`eres, on s'attend \`a ce qu'il y ait~$148$
occurrences de la lettre~$e$.
\par\bigskip
\'Ecrire une fonction de prototype
\begin{verbatim}
int decalage(char *texte, float *langue) ;
\end{verbatim}
qui analyse le contenu du fichier crypt\'e et retourne une proposition
de d\'ecalage employ\'e par le chiffre de C\'esar. (On cherche la
lettre la plus courante dans le texte, on suppose que c'est la lettre
ayant le plus de probabilit\'es d'appara\^\i{}tre~; on obtient ainsi
un d\'ecalage probable).
%  Ce processus peut se faire sur l'ensemble des
% lettres et on peut faire la moyenne des d\'ecalages obtenus).

\ifcorrection
\begin{correction}
\begin{verbatim}
int
decalage
(char * texte, float *langue)
{
  float freq[256] ;
  int plusfreqtexte ;
  int plusfreqlang  ;
  int i ;

  plusfreqtexte = (int) calcul_frequence(texte,freq) ;
  
  plusfreqlang=0;
  for(i=0;i<256;i++)
    if(langue[plusfreqlang]<langue[i])
      plusfreqlang=i ;

  i = plusfreqlang-plusfreqtexte ;
  return    i<0 ? plusfreqtexte-plusfreqlang : i ;
}
\end{verbatim}
\end{correction}
\fi
