\section{Approximation $k$-chotomique d'une racine}
On suppose disposer d'une fonction prenant un nombre flottant machine
en param\`etre et retournant la valeur approch\'ee en ce point d'une
fonction math\'ematique continue.  Par exemple~:
\begin{verbatim}
double f (double x) { return (x-2)*(x-3)*(x-1/100.) ; }
\end{verbatim}
De plus, on suppose disposer d'une macro
\begin{verbatim}
#define k 5
\end{verbatim}
\paragraph{Objectif.}
\'Etant donn\'es trois flottants machines~${e, a}$ et~$b$ tels que~:
\[
  a<b,\quad f(a)<0, \quad f(b) >0,\quad 0<e<b-a,
\]
on se propose de d\'eterminer (au moins) un sous-intervalle
de~${[a,b]}$ de longueur inf\'erieur \`a~$e$ et contenant une racine
de~$f$ (un \'el\'ement~$r$ tel que~${f(r)=0}$).
\par
Pour ce faire, on se propose de d\'efinir une fonction de prototype~:
\begin{verbatim}
typedef double (*pfct_t)(double) ;
char *racine(double, double, double, pfct_t)  ;
\end{verbatim}
prenant en param\`etre les trois flottants~$a,b$ (${a<b}$) et~$e$ et
un pointeur sur la fonction~$f$. Cette fonction \verb+racine+ retourne une
cha\^\i{}ne de caract\`eres donnant l'intervalle trouv\'e.
\par
Par exemple, pour l'exemple~$f$ ci-dessus
avec~\verb?racine(0,6,1/1000.,f)?,  on obtient la sortie suivante~:
\begin{verbatim}
bash$./a.out
 [9.9840000000e-03,1.0368000000e-0] [1.9998720000e+00,2.0002560000e+0]  
 [2.9998080000e+00,3.0001920000e+0] 
bash$
\end{verbatim}
Vous pouvez  utiliser
 une approche $k$-chotomique r\'ecursive bas\'ee sur la strat\'egie suivante~:
\begin{itemize}
\item si~${f(a)f(b)>0}$ alors retournez la cha\^\i{}ne de caract\`eres vide~:
\item si~${b-a<e}$ alors retournez la cha\^\i{}ne de caract\`eres~$[a,b]$~;
\item sinon, retournez la concat\'enation des sorties
  de~:
\begin{verbatim}
racine(((k-i)*a+i*b)/k,((k-(i+1))*a+(i+1)*b)/k,e),
\end{verbatim}
  pour~$i$ allant de~$0$ \`a~$(k-1)$.
\end{itemize}
\paragraph{Questions~:}
\begin{enumerate}
\item Donnez la d\'efinition d'une fonction de prototype~:
\begin{verbatim}
char * Double2Intervalle(double a, double b);
\end{verbatim}
  qui retourne la cha\^\i{}ne de caract\`eres~$[a,b]$.
\par
Vous pouvez utiliser les fonctions \verb+malloc+, et \verb+sprintf+ (comme \verb+printf+,  la fonction \verb+sprintf+ convertit une ou plusieurs
variables mais \verb+sprintf+ place les
r\'esultats \`a l'adresse m\'emoire pass\'ee en premier
param\`etre). Par exemple, on a~:
\begin{verbatim}
bash$ cat << EOF > exemple.c ; gcc exemple.c ; ./a.out 
>#include <stdio.h>
>#include <stdlib.h>
>int
>main
>(void) 
>{
>  char * str ;
>  str = (char *) malloc(sizeof(char)*13) ;
>  sprintf(str,"%.10e",2./3.) ; /* .10 permet de ne garder que 10 d\'ecimales */
>  printf("%s\n", str) ;
>  return 0;
>}
>EOF 
6.6666666667e-01
bash$
\end{verbatim}
\item Donnez la d\'efinition de la fonction de prototype~:
\begin{verbatim}
char * racine (double, double, double, pfct_t) ;
\end{verbatim}
Prenez soin \`a ne pas trop faire d'allocation dynamique et \`a coder
les copies et concat\'enations de tableaux (fa\^\i{}te une premi\`ere
version na\"\i{}ve puis raffiner la si vous avez le temps).
\par
Vous pouvez utilisez la fonction~\verb+free+ de la librairie standard.
\par
Vous devez refaire les fonctions de concat\'enation (sans utiliser \verb+sprintf+ ;-)et de calcul de longueur de cha\^\i{}nes
de caract\`eres.
\end{enumerate}
\par
\ifcorrection%
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define n 10

double
fct
(double x) 
{
  return (x+0.99)*(x+1.01)*(x-0.99)*(x+1.01)*(x+1.4) ;
  return (x + 3.45) *(x-0.2)*(x+5.59)*(x - 1.22)*(x+6.54); /* (x - 11.4) * (x - 45.3)   */
}

char  *
Double2Intervalle
(double a, double b)
{
  char * dest ;
  dest = (char *) malloc(38*sizeof(char));
  sprintf(dest, " [%.10e,%.10e] \0", a);
  return dest;
}

char *
racine
(double a, double b, double e, double (*f)(double)) 
{
  char *res[n], *dest;
  int i,j,k ;

  if(a>b) exit(2) ;
  
  if (f(a) * f(b) > 0)
    return "";

  if ((b - a) < e) 
    return Double2Intervalle(a,b) ;  

  for(j=i=0;i<n; i++) 
    {
      res[i] = racine(((n-i)*a+i*b)/n, ((n-(i+1))*a+(i+1)*b)/n, e, f);
      for(k=0; res[i][k] ; k++) ;
      j+=k ;
    }

  dest = (char *) malloc((j+1)*sizeof(char)) ;

  i=0;
  for(k=0; k<n ; k++) 
    for(j=0; dest[i] = res[k][j] ;j++,i++) ;

  for(i=0;i<n;i++) 
    if(res[i][0]) 
      free(res[i]) ;

  return dest ;
}

int
main
(void) 
{
  printf("%s\n", racine(-3, 2, 1. / 1000., fct));
  return 0;
}

\end{verbatim}
\fi%
\paragraph{Remarque~:} ce n'est pas un bon algorithme global d'isolation de
racine (l'appel~\verb+racine(-2,2,1/10)+ ne trouve pas de racine
pour~${f(x)=(x-1)(x+1)}$ car~${f(-2)f(2)=9>0}$). On ne vous demande pas d'en coder un bon.
