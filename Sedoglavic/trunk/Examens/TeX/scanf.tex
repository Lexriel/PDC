\section{Une implantation sommaire de la fonction scanf}
\label{sec:printf}
Dans cette section, on se propose d'implanter la fonction \verb+scanf+
dans une architecture dans laquelle le passage des param\`etres se
fait par une pile (cf.\ fin de la section pour une description de
l'architecture).

Par ailleurs, on suppose ne disposer que d'une seule fonction externe
dont le prototype est \verb?int getchar(void);? et qui lit depuis
l'entr\'ee standard un caract\`ere dont le code \textsc{ascii} est retourn\'e
apr\`es conversion en un entier~; en cas d'erreur ou si l'entr\'ee est
un fichier dont on a atteint la fin, cette fonction retourne l'entier
d\'efini par la macro \verb+EOF+.

Par exemple, pour extraire de l'entr\'ee standard un entier et le stocker dans une
variable de type entier,  on peut utiliser le code suivant~:
\begin{verbatim}
#include<stdio.h>

int main(){
  unsigned char c ;
  c = (unsigned char) getchar() ;
  return 0 ;
}
\end{verbatim}
L'entr\'ee standard est consid\'er\'ee comme une suite fini ou vide
de~$n$ octets~$o_{1},\ldots,o_{n}$~; si elle est vide la fonction~\verb+getchar+ attend qu'un octet lui soit transmis, sinon apr\`es  un appel \`a \verb+getchar+, l'entr\'ee standard est constitu\'ee de la  suite fini de~${n-1}$ octets~$o_{2},\ldots,o_{n}$.
\par
\paragraph{Objectif.} L'objectif est d'implanter la fonction de
prototype~: \verb?int mscanf(const char *format, ...)?  permettant de
saisir depuis l'entr\'ee standard~:
\begin{itemize}
\item des caract\`eres \textsc{ascii} classique de type \verb+char+.
% \item des cha\^\i{}nes de caract\`eres du type \verb+string_t+ suivant~:
% \begin{verbatim}
% struct string_p{
%     char *string ;            /* un pointeur sur un espace m\'emoire */
%     unsigned int stringsize ; /* de taille stringsize octets */
% } ;
% typedef struct string_p string_t ;
%\end{verbatim}
\item des entiers machines positifs dans les bases d\'ecimale et binaire.
% \item des entiers machines positifs de Gauss de type \verb+GaussInt_t+
%   (que vous devrez d\'efinir par la suite) i.e.\ des nombres complexes
%   dont les parties r\'eelles et imaginaires sont des entiers machines
%   positifs.
\end{itemize}
Cette fonction retourne~$0$ en cas de probl\`eme (mauvaise directive
ou probl\`eme lors de la saisie i.e.\ le codage de la suite de
caract\`eres de l'entr\'ee standard ne correspond pas aux conventions,
cf.\ la suite) et~$1$ sinon.
\paragraph{Caract\'eristique de la fonction mscanf.}
Cette fonction a un param\`etre obligatoire et un nombre variable de
param\`etres compl\'ementaires. 
\par
Le param\`etre obligatoire est constitu\'e par une cha\^\i{}ne de
caract\`eres  compos\'ee d'une ou plusieurs directives.  Une directive
commence par le caract\`ere~\% et peut \^etre de plusieurs formes~:
\begin{itemize}
\item  la directive~\%c indique que l'on souhaite saisir un caract\`ere~;
\item la directive~\%s indique que l'on souhaite saisir une
  cha\^\i{}ne de caract\`eres~;
\item la directive~\%d indique que l'on souhaite saisir un entier positif en
  base d\'ecimale~;
\item la directive~\%b indique que l'on souhaite saisir un entier positif en
  base binaire.
% \item la directive~\%Gd indique que l'on souhaite saisir un entier de
%   Gauss positif en base d\'ecimale (par exemple~\verb?2+3I?)~;
% \item la directive~\%Gb indique que l'on souhaite saisir un entier
%   de Gauss positif en base binaire (par exemple~\verb?10+11I?).
\end{itemize}
\paragraph{Convention pour la saisie par mscanf.}
On convient qu'~:
\begin{itemize}
% \item un entier de Gauss ne peut prendre que la
%   formes~\verb?x1..xn+y1..ymI? ou~\verb+x1..xn+ et~\verb?y1..ym? sont
%   des entiers (avec~\verb?'+'? et~\verb+'I'+ les caract\`eres usuels)~;
\item un entier se termine par tout caract\`ere non num\'erique~;
\item une cha\^\i{}ne de caract\`eres (de type \verb+char *+) se
  termine par un caract\`ere de code~$0$ ou \verb+EOF+.
\end{itemize}
\paragraph{Questions}
\begin{enumerate}
% \item Donnez la d\'eclaration d'un type \verb+GaussInt_t+ permettant
% de repr\'esenter les entiers de Gauss.
\item De quels types peuvent \^etre les param\`etres compl\'ementaires de la fonction
\verb+mscanf+~?
\item 
  Donnez la d\'efinition d'une fonction %
  \verb?int ScanString(char *s,unsigned int stringsize)? qui saisit
  depuis l'entr\'ee standard une cha\^\i{}ne de caract\`eres d'au plus
  \verb+stringsize+ caract\`eres et les places dans l'espace m\'emoire
  point\'e par~\verb+s+ et retourne~$1$ en cas de probl\`eme et~$0$
  sinon.  On convient que~:
\begin{itemize}
\item les op\'erations d'allocation et de d\'esallocation de~\verb+s+
  incombent \`a l'utilisateur et non pas \`a la fonction
  \verb+ScanString+.
\item la saisie d'une cha\^\i{}ne de caract\`eres s'interrompt par la
  saisie du caract\`ere de code \textsc{ascii}~$0$ ou \verb+EOF+ (ce dernier
  est remplac\'e par~$0$ dans la cha\^\i{}ne de caract\`eres).
\item un probl\`eme survient lorsque la fonction saisie
  \verb+stringsize+ caract\`eres sans rencontrer de caract\`ere de
  code \textsc{ascii}~$0$ ou \verb+EOF+ et dans ce cas le dernier caract\`ere
  de l'espace m\'emoire associ\'e \`a~\verb+s+ doit \^etre de code
  \textsc{ascii}~$0$.
\end{itemize}
\item Donnez la d\'efinition d'une fonction %
  \verb?int ScanInt(int b, unsigned int *res)? qui saisit depuis
  l'entr\'ee sortie standard une cha\^\i{}ne de caract\`eres repr\'esentant un entier positif exprim\'e dans la
  base~${b\in\{2,10\}}$ et le transmet par l'interm\'ediaire de son
  second param\`etre~\verb+res+. Cette fonction arr\^ete la saisie au
  premier caract\`ere de l'entr\'ee standard n'\'etant pas un chiffre
  de la base~\verb+b+~; ce caract\`ere est converti en entier et
  retourn\'e.
%\item Donnez la d\'efinition de la fonction de prototype %
%\verb?int *parpt(int,int);? qui prend en entr\'ee la position du param\`etre
%dans la liste des param\`etres\footnote{dans la fonction %
%  \verb?void PrintInt(int i,int b)? i est le premier param\`etre,~b est le second.}
%et qui retourne un pointeur sur ce param\`etre.
% \item Donnez la d\'efinition de la fonction \verb?mscanf? en ne tenant
%   pas compte des entiers de Gauss (i.e.\ seules les directives~\%c
%   et~\%s sont \`a prendre en compte dans cette question).
% \item Donnez la d\'efinition de la fonction \verb?mscanf? en tenant
%   compte des entiers de Gauss.
\item Donnez la d\'efinition de la fonction \verb?mscanf?.
\end{enumerate}

\paragraph{Mod\`ele de passage de param\`etres aux fonctions.}
Rappelons que les param\`etres d'une fonction sont pass\'es par la
pile. Cette pile est compos\'ee de cellules dont la taille en octet
correspond au type \verb?int?, elle croit vers les adresses
d\'ecroissantes et elle a la structure suivante~:
\begin{center}
  \begin{tabular}{l|c|}
    \hline 
    0000 & $\cdots$ \\ \hline
    & seconde variable locale \\ \hline
    & premi\`ere variable locale \\ \hline
    & ancien pointeur de contexte \\ \hline
    & adresse de retour \\ \hline
    & premier param\`etre \\ \hline
    & second param\`etre \\ \hline
    FFFF &$\cdots$ \\ \hline
  \end{tabular}
\end{center}
Ainsi si \verb?int foo? est la premi\`ere variable locale automatique
d\'efinie dans la fonction appel\'ee et que \verb?ptr?  est un
pointeur sur la cellule correspondante, \verb?ptr+1? pointe sur
l'ancien pointeur de contexte.
\par
De plus, lors de l'appel d'une fonction, ses param\`etres sont
empil\'es du dernier au premier et on note qu'un pointeur occupe une
cellule dans tous les cas.

\ifcorrection
  \begin{correction}
    \begin{enumerate}
    \item Ces param\`etres doivent \^etre des pointeurs de type
      \verb+int*+ ou \verb+char*+ selon le format.
    \item
\begin{verbatim}
int 
ScanString
(char *s,unsigned int stringsize)
{
  stringsize-- ; /* pour pouvoir placer un 0 en fin */   
   while(1) ;
    {
	if (!stringsize)
		return 1 ;

     *s = (char) getchar() ;
     switch(*s)
     { 
     case EOF  :  ;
     case '\n' : *s = 0 ;
     case 0    : break ;
     } ;
     s++ ;
     stringsize-- ;
    }
    return 0 ;
}
\end{verbatim}
    \item
\begin{verbatim}
int 
ScanInt
(int b, unsigned int *res)
{
int c ;
*res = 0;
while( ((c=getchar)!=EOF || c!='\n') && ( (c=c-'0')>-1 && c <=b))
{
  *res *=b;
  *res += c ;
}
   return c+'0' ;
}
\end{verbatim}
    \item 
\begin{verbatim}
int 
mscanf
(const char *str, ...)
{
   /* on positionne un pointeur sur le premi\`ere 
   param\`etre */
   int *tmp  = (int *) str ;
   int message = 1 ;
   while(*str)
   {
     str ++ ;
     /* on cherche le premier format */
     if(*(str-1)!='%')
        continue ;

     switch(*str)
     {
      case 'c' : message *= ScanString((char *) tmp , 1) ; break ;
      case 's' : message *= ScanString((char *) tmp , 1 << 32) ; break ;
      case 'b' : message *= ScanInt(2, tmp ) ; break ;
      case 'd' : message *= ScanInt(10, tmp ) ; break ;
      default : continue
     }
     if(!message)
        break ;
     tmp ++ ;
   }
   return message ;
}
\end{verbatim}
    \end{enumerate}
  \end{correction}
\fi
