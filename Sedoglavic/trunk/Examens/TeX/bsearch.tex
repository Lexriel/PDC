\section{Recherche binaire d'un objet dans un tableau}
Donner la d\'efinition de la fonction  \verb+bsearch+ de prototype~:
\begin{verbatim}
void *bsearch
(
    const void *key, const void *base, size_t nel,
    size_t size, int (*compar)(const void*, const void*)
);
\end{verbatim}
Cette fonction recherche de mani\`ere dichotomique la clef \verb+key+ dans le tableau base.
\par\smallskip
Elle suppose que les objets du tableau base sont rang\'es dans l'ordre croissant.
\par\smallskip
Les arguments de cette fonction sont~:
\begin{itemize}
        \item\verb+key+~: \'el\'ement {\`a} rechercher (clef de recherche)~;
          \item\verb+base+~: adresse de l'\'el\'ement~$0$ du tableau {\`a} scruter~;
          \item\verb+nel+~: nombre d'\'el\'ements dans le tableau~;
          \item\verb+size+~: taille de chaque \'el\'ement dans le tableau~;
          \item\verb+compar+~: pointeur sur une fonction de comparaison d\'efinie par l'utilisateur.
\end{itemize}
\par\medskip
La fonction \verb+bsearch+ fait appel \`a la fonction point\'ee par \verb+compar+ avec comme premier argument la clef de recherche et comme second argument l'\'el\'ement du tableau \`a comparer avec la clef; cette fonction retourne un entier donnant le r\'esultat de la comparaison :
\begin{itemize}
\item valeur n\'egative~: la clef est plus petite que l'\'el\'ement en cours~;
\item valeur nulle~: la clef et l'\'el\'ement en cours sont \'egaux~;
\item valeur positive~: la clef est plus grande que l'\'el\'ement en cours.
\end{itemize}
\par\medskip
En cas de succ\`es, \verb+bsearch+ retourne l'adresse de la premi\`ere entr\'ee identique \`a la clef, sinon \verb+bsearch+ retourne NULL.
\par\medskip
Par exemple, le code suivant~:
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <string.h> 

typedef int (*fptr)(const void *, const void *);

int 
compare1
(const int *n1, const int *n2) 
{
    return(*n1 - *n2);
}

int 
compare2
(const char *str1, const char *str2) 
{
   return strlen(str1) - strlen(str2);
}

int
main
(void) 
{
    int tab1[9] = {123, 234, 345, 456, 567, 678, 789, 890, 901};
    int key1 = 890;
    char *tab2[5] = {"ABCDEF", "PHM", "EB", "DA", "DF"};
    char *key2 = "DA";

    if ( bsearch(&key1, tab1, 9, sizeof(int), (fptr) compare1) != NULL )
       printf("%d est dans tab1\n", key1);
    else
       printf("%d n'est pas dans tab1\n", key1);

    if ( bsearch(&key2, tab2, 5, sizeof(char *), (fptr) compare2) != NULL )
       printf("%s est dans tab2\n", key2);
    else
      printf("%s n'est pas dans tab2\n", key2);
    return 0;
}
\end{verbatim}
produit l'ex\'ecution~:
\begin{verbatim}
% ./a.out
890 est dans tab1
DA est dans tab2
\end{verbatim}
\ifcorrection%
\begin{correction}
\verbatiminput{C/bsearch.c}
\end{correction}
\fi
