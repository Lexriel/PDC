\section{Appariement de brin d'ADN}
\ifcorrection%
\subsection*{\'Enonc\'e}%
\fi%
L'acide d\'esoxyribonucl\'eique --- l'ADN --- est le support de
l'information g\'en\'etique de tout organisme vivant connu. Cette
mol\'ecule a une structure constitu\'ee de deux brins
h\'elico\"\i{}daux compos\'es chacun d'une cha\^\i{}ne de
nucl\'eotides qui contiennent les bases azot\'ees~:
\begin{center}
\begin{tabular}{cc}
	\begin{tabular}{ll}
	    A & ad\'enine \\
	    G & guanine 
	\end{tabular}
	&
	\begin{tabular}{ll}
	    T & thymine \\
	 C & cytosine 
	\end{tabular}		
\end{tabular}
\end{center}
Ces bases sont toujours appari\'ees par~$2$ selon la r\`egle de Watson
et Crick~:
\begin{center}
  \begin{tabular}{l}
    A et T s'apparient ensemble~; \\
    C et G s'apparient ensemble.
\end{tabular}
\end{center}
La synth\`ese de l'ADN s'effectue par r\'eplication au cours de la
division cellulaire.
\paragraph{Questions.}
\begin{enumerate}
\item Donnez la d\'efinition d'une fonction de prototype %
  \verb+char ComplementBase(char);+ qui prend en argument la lettre
  majuscule repr\'esentant la base (A pour ad\'enine par exemple) et
  retourne la lettre compl\'ementaire (T dans notre exemple). Cette
  fonction retourne~$0$ si le param\`etre ne correspond pas \`a une
  base.
\item Donnez la d\'efinition d'une fonction de prototype %
  \verb+char * ComplementBrin(char *);+ qui prend en argument une
  cha\^\i{}ne de caract\`eres repr\'esentant un brin d'ADN (ATGTGACGTA
  par exemple) et qui retourne la cha\^\i{}ne de caract\`eres
  compl\'ementaire (TACACTGCAT dans notre exemple). Notez que vous
  devez vous occuper de l'allocation m\'emoire de la cha\^\i{}ne
  produite et v\'erifier la validit\'e de la cha\^\i{}ne d'entr\'ee
  (la fonction retourne~$0$ en cas d'erreur sur l'entr\'ee).
\end{enumerate}
\ifcorrection
\begin{correction}
\subsection*{Proposition de correction}%
\input{Verbatim/AppariementADN.c.verb}
\subsection*{D\'etails de cette correction}%
Nous allons constuire les~$2$ fonctions suivantes~:
@ 
<<*>>=
<<Ent\^ete>>
<<Compl\'ementBase>>
<<Compl\'ementBrin>>
@ %def
 
\begin{enumerate}
\item
@ 
Pour construire la fonction [[ComplementBase]], nous allons compl\'eter le squelette suivant~:
<<Compl\'ementBase>>=
<<Ent\^eteCompl\'ementBase>>
{
<<VariableAutomatique>>
<<R\`egleDeWatsonEtCrick>>
<<ValeurRenvoy\'ee>>
}
@ %def ComplementBase
L'ent\^ete de cette fonction est donn\'ee dans l'\'enonc\'e~:
<<Ent\^eteCompl\'ementBase>>=
char 
ComplementBase
(char base)
@ %def 
@ 
Nous n'allons utiliser que la variable automatique suivante~:
<<VariableAutomatique>>=
char res ;
@ %def 

@ 
Cette variable contiendra d'ailleurs la valeur de retour de
notre fonction~:
<<ValeurRenvoy\'ee>>=
return res ;
@ %def 

@ 
Il ne reste plus qu'\`a implanter les r\`egles de Watson
et Crick~:
<<R\`egleDeWatsonEtCrick>>=
switch(base)
{
case 'A' : res = 'T' ; break ;
case 'T' : res = 'A' ; break ;
case 'C' : res = 'G' ; break ;
case 'G' : res = 'C' ; break ;
@ %def 

@ 
et pour finir tenir compte du traitement d'erreur sp\'ecifi\'e 
dans l'\'enonc\'e~:
<<R\`egleDeWatsonEtCrick>>=
default : res = 0 ;
}
@ %def 

\item 
@
 Pour construire la fonction [[ComplementBrin]], nous allons
compl\'eter le squelette suivant~:
<<Compl\'ementBrin>>=
<<Ent\^eteCompl\'ementBrin>>
{
<<VariablesAutomatiques>>
<<AllocationM\'emoire>>
<<ConstructionCompl\'ementBrin>>
<<ValeurDeRetour>>
}
@ %def ComplementBrin
L'ent\^ete de cette fonction est, elle aussi, donn\'ee dans l'\'enonc\'e~:
<<Ent\^eteCompl\'ementBrin>>=
char *
ComplementBrin
(char *brin)
@ %def 

@ 
Nous allons utiliser une variable
<<VariablesAutomatiques>>=
int i;
@ %def i

afin de d\'eterminer l'espace m\'emoire \`a r\'eserver.
@ 
Pour ce faire, on peut utiliser une simple boucle~:
<<AllocationM\'emoire>>=
for(i=0;brin[i];i++);
@ %def 

@ 
En fin de boucle, cette variable automatique [[i]] doit
\^etre incr\'ement\'ee afin de tenir compte du caract\`ere de 
terminaison de cha\^\i{}ne (de code \textsc{ascii}~$0$).
<<AllocationM\'emoire>>=
i++ ;
@ %def 

@ 
Pour effectuer l'allocation dynamique proprement dite, nous
devons utiliser la variable automatique~:
<<VariablesAutomatiques>>=
char *res ;
@ %def 

@ 
et l'instruction~:
<<AllocationM\'emoire>>=
if(!(res = (char *) malloc(sizeof(char)*i)))
	return 0 ;
@ %def 
Remarquons que la conditionnelle g\`ere tout probl\`eme d'allocation.

@ 
L'usage de la fonction [[malloc]] n\'ecessite l'inclusion suivante~:
<<Ent\^ete>>=
#include <stdlib.h>
@ %def 
afin de disposer du prototype de cette fonction.

@ 
C'est l'adresse de cet espace m\'emoire qui est 
retourn\'ee par la fonction [[ComplementBrin]]~:
<<ValeurDeRetour>>=
return res ;
@ %def 


@ 
Il nous reste maintenant \`a remplir cet espace 
par le compl\'ement du brin d'entr\'e~:
<<ConstructionCompl\'ementBrin>>=
for(i=0;brin[i];i++)
  if(!(res[i] = ComplementBase(brin[i])))
  {
    free(res);
    return 0 ;	
  }
@ %def 
La conditionnelle ci-dessus tient compte de la gestion
d'erreur sp\'ecifi\'ee par l'\'enonc\'e (en cas d'erreur, 
on lib\`ere l'espace m\'emoire allou\'e).

@ 
Pour finir, on s'assure de la pr\'esence d'un caract\`ere de terminaison de 
cha\^\i{}ne~:
<<ConstructionCompl\'ementBrin>>=
res[i]=0;
@ %def 


\end{enumerate}

\end{correction}
\fi
