\section{Utilisation du clavier d'un t\'el\'ephone en mode SMS}
\ifcorrection%
\subsection*{\'Enonc\'e}%
\fi%
Vous  avez  d\'ej\`a  remarqu\'e  que  le   clavier d'un t\'el\'ephone
outre la touche~\#, ressemblait \`a~:
\par
\begin{center}
\begin{tabular}{ccc}
 1 &  2  & 3 \\
   & ABC & DEF \\[\smallskipamount]
 4 & 5 & 6 \\
GHI & JKL & MNO  \\[\smallskipamount]
 7 & 8 & 9 \\
PQRS &TUV  &WXYZ
\end{tabular}
\end{center}
\par
Cette disposition permet   \`a l'utilisateur de taper   du texte.  Par
exemple, presser  la touche~$7$ une fois  correspond \`a la lettre~$P$
alors que presser cette touche~$4$ fois correspond  \`a la lettre~$S$. 
La touche~\#  du t\'el\'ephone sert \`a s\'eparer  les lettres et peut
\^etre  omise lorsqu'il est clair qu'une  lettre se termine et l'autre
commence.
\par
Par exemple, la s\'equence
\begin{verbatim}
777666222559996#6668866#8244466
\end{verbatim}
correspond donc au mot
\begin{verbatim}
ROCKYMOUNTAIN
\end{verbatim}
\paragraph{Question.}
Donnez une fonction qui prend en param\`etre une cha\^\i{}ne de
caract\`eres --- stock\'ees dans un tableau --- correspondant au texte
tap\'e en mode SMS (comme la s\'equence ci-dessus) et qui affiche le texte 
 correspondant sur la sortie standard
\paragraph{Indications.}
Le prototype de la fonction \verb+int putchar(int)+ est d\'efini dans
le fichier d'ent\^ete \verb+#include <stdio.h>+. Cette fonction prend
en argument un entier, le converti en caract\`ere et l'affiche sur la
sortie standard et retourne ce caract\`ere en cas de succ\`es ou EOF
en cas d'\'echec.
\ifcorrection
\begin{correction}
\subsection*{Proposition de correction}%
\input{Verbatim/ClavierEnModeSMS.c.verb}
\subsection*{D\'etails de cette correction}%
Pour d\'efinir le code, nous allons suivre les \'etapes~:
@ 
<<*>>=
<<Ent\^ete>>
<<Structure de donn\'ee>>
<<FonctionDeTraduction>>
@ %def

@ 
Il ne reste plus qu'\`a \'ecrire la fonction de traduction en se basant
sur le squelette suivant~:
<<FonctionDeTraduction>>=
<<Ent\^eteDeFonction>>
{
<<Variables automatiques>>
<<conversion>>
putchar('\n');
}
@ %def 

@ 
Cette fonction d'identificateur [[Traduction]] prend une cha\^\i{}ne
de caract\`eres en param\`etre et ne retourne rien~:
<<Ent\^eteDeFonction>>=
void
Traduction
(char *texte)
@ %def Traduction

\subsubsection*{Gestion de l'entr\'ee}
On commence par s'assurer que l'entr\'ee correspond bien \`a nos attentes.
@ 
Si la cha\^\i{}ne donn\'ee en param\`etre est vide, on quitte la fonction~:
<<Initialisation>>=
if(!*texte)
   return ;
@ %def 

@ 
L'expression bool\'eenne suivante~:
<<caract\`ere invalide>>=
(*texte<'1' || *texte>'9') && *texte!='#'
@ %def 
est vrai si le caract\`ere consid\'er\'e est invalide.

@ 
On va chercher le premier caract\`ere valide de la cha\^\i{}ne en utilisant 
une r\'ecursion~:
<<Initialisation>>=
if(<<caract\`ere invalide>>)
   Traduction(texte+1) ;
@ %def 

@ 
\subsubsection{Structure de donn\'ee}
Nous allons utiliser la structure suivante~:
<<Structure de donn\'ee>>=
struct data_m
{
char chiffre ;
int iteration ;
char modulo ;
};
@ %def 

@ 
et pour faire simple, on d\'efini le type suivant~:
<<Structure de donn\'ee>>=
typedef struct data_m data_t ;
@ %def 

@ 
Notre implantation se base principalement sur la manipulation de la variable
automatique suivante~:
<<Variables automatiques>>=
data_t data ;
@ %def data
qui est modifi\'ee \`a chaque nouveau caract\`ere rencontr\'e suivant
les r\`egles que nous allons implanter ci-dessous.

Pour bien comprendre cette structure de donn\'ee, nous allons tout de suite
voir comment l'utiliser lors de l'affichage de la conversion.

@ 
\subsubsection*{Affichage}
Pour l'affichage, on va se servir du tableau suivant allou\'e automatiquement~:
<<Variables automatiques>>=
char tab[10] = "  ADGJMPTW" ;
@ %def 
@ 
L'affichage proprement dit correspond au code suivant~:
<<afficher>>=
putchar(tab[data.chiffre-'0']+(data.iteration % data.modulo)) ;
@ %def 
qui explicite l'usage de notre structure [[data]].

@ 
Le prototype de la fonction [[putchar]] utilis\'ee est d\'eclar\'e 
dans le fichier d'ent\^ete suivant~:
<<Ent\^ete>>=
#include <stdio.h>
@ %def 

\subsubsection*{Affectation de [[data]]}

@
On initialise l'ensemble des champs de la variable [[data]] en
traitant le premier caract\`ere de la cha\^\i{}ne donn\'ee en
param\`etre~:
<<Affectation de data>>=
data.chiffre = *texte;
data.iteration = 0 ;
if(*texte=='1')
  data.modulo = 1 ;
else 
  data.modulo=(*texte=='9' || *texte=='7')?4:3 ;
@ %def 

@ 
La conversion commence par l'initialisation de [[data]]
et la prise en compte du caract\`ere suivant~:
<<conversion>>=
<<Initialisation>>
<<Affectation de data>>
texte++ ;
@ %def 

@ 
Le reste correspond l'application des r\`egles de conversion~:
<<conversion>>=
while(1)
{
<<r\`egles de conversion>>
}
@ %def 
d\'efinies dans la section suivante.
@ 
\subsubsection*{R\`egles de conversion}
Notre conversion ob\'eit aux r\`egles suivantes~:
\begin{enumerate}
\item si le caract\`ere consid\'er\'ee est le caract\`ere de terminaison
de cha\^\i{}ne (de code \textsc{ascii}~$0$), on affiche la traduction en cours (si le caract\`ere pr\'ec\'edent n'est pas un di\`ese) et
on sort de la boucle~:
<<r\`egles de conversion>>=
if(!*texte)
{ 
<<afficher>>
break ;
}
@ %def 

@ 
\item on passe les caract\`eres non valides~:
<<r\`egles de conversion>>=
if(<<caract\`ere invalide>>)
{
  texte++ ;
  continue ;
}
@ %def 
@ 
\item si on consid\`ere de nouveau le m\^eme chiffre, on enregistre une it\'eration
suppl\'ementaire, on passe ce caract\`ere et on recommence la boucle~:
<<r\`egles de conversion>>=
if(*texte==data.chiffre)
{
  data.iteration++ ;
  texte++;
  continue ;
}
@ %def
@ 
\item si le caract\`ere consid\'er\'e est le di\`ese, on le passe~:
<<r\`egles de conversion>>=
while(*texte=='#')
  texte++ ;
@ %def 
@ 
Remarquons que l'on peut tomber sur une cha\^\i{}ne avec un di\`ese terminal.
La r\`egle suivante g\`ere ce cas~:
<<r\`egles de conversion>>=
if(!*texte)
  continue ;
@ %def 

@
\item la derni\`ere r\`egle est implicite --- pas besoin de conditionnelle puisque qu'on 
se trouve forcement dans ce cas --- et correspond \`a la prise en compte 
d'un nouveau chiffre. Dans ce cas, il faut afficher et r\'eactualiser data~:
<<r\`egles de conversion>>=
<<afficher>>
<<r\'eactualiser data>>
@ %def 
\end{enumerate}

@ 
\subsubsection*{R\'eactualisation de data}
En ce qui concerne la r\'eactualisation, on ne modifie [[data]] que
face \`a un chiffre compris entre~$2$ et~$9$ inclus.
<<r\'eactualiser data>>=
if(*texte>'0' && *texte<'9'+1)
{
<<Affectation de data>>
}
texte++ ;
@ %def 

\end{correction}
\fi
