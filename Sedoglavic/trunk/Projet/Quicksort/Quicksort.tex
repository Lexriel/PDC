\documentclass{article}
\usepackage[french]{babel}
\begin{document}
\section{Description du tri Quicksort}
Le tri Quicksort a \'et\'e introduit par C.A.R.~Hoare en~$1960$.
C'est le prototype des m\'ethodes \emph{diviser pour r\'esoudre}.

On suppose disposer~:
\begin{itemize}
\item d'un tableau compos\'e d'\'el\'ements \`a trier~;
\item d'une fonction de comparaison~$f$ prenant en param\`etre deux
  \'el\'ements du tableau et retournant un entier~:
  \begin{itemize}
  \item~$0$ s'ils sont \'equivalent pour la fonction de comparaison,
  \item positif si le premier est consid\'er\'e plus grand que le second,
  \item n\'egatif sinon~;
  \end{itemize}
\end{itemize}
\paragraph{Principe du tri.}
On d\'esigne par~$x$ le premier \'el\'ement de la portion (au d\'epart
la totalit\'e) du tableau en cours de traitement.  Supposons
qu'apr\`es manipulation, on r\'eussi \`a r\'eagencer la portion
consid\'er\'ee du tableau en~$3$ zones contig\"ues~:
\begin{itemize}
\item la premi\`ere \'etant constitu\'ee des \'el\'ements~$y$ tels
  que~${f(y)< f(x)}$~;
\item la seconde  \'etant r\'eduit \`a l'\'el\'ement~$x$~;
\item la troisi\`eme \'etant constitu\'ee des \'el\'ements~$z$ tels que~${f(x)\leq f(z)}$.
\end{itemize}
Il suffira de recommencer r\'ecursivement la manipulation sur la
premi\`ere et la troisi\`eme partition du tableau pour trier notre
tableau. La r\'ecursion prend fin lorsque  la
portion consid\'er\'ee est r\'eduite \`a un \'el\'ement.

\subparagraph{Attention~:}

Aucune copie du tableau n'est fa\^\i{}te lors du tri i.e.\ ce dernier
est destructif puisqu'il alt\`ere la partition qui lui est donn\'ee en
param\`etre.

\subparagraph{Une m\'ethode de partitionnement non sym\'etrique.}  

Pour partitionner la portion consid\'er\'ee, on peut placer un
pointeur~\texttt{current} sur l'\'el\'ement~$x$ et un
pointeur~\texttt{next} sur l'\'el\'ement suivant. Ceci fait, il reste
\`a parcourir la portion en applicant la strat\'egie suivante~:
\begin{itemize}
\item[] tant que le pointeur pointe dans la portion de tableau consid\'er\'ee faire~:
\item si l'\'el\'ement~$y$ point\'e par~\texttt{next} est tel
  que~${f(y)< f(x)}$, alors 
  \begin{itemize}
  \item incr\'ementer~\texttt{current},
  \item permuter les \'el\'ements point\'es par \texttt{current} et
    \texttt{next}~;
  \end{itemize}
\item incr\'ementer~\texttt{next}.
\end{itemize}
Pour finir, il reste \`a permuter l'\'el\'ement~$x$ avec celui point\'e par~\texttt{current}.

\section{Quicksort sur un tableau d'entier}
Avant tout, nous allons remplir un tableau d'entiers de taille~:
\begin{verbatim}
#define TailleTabInt 1000
\end{verbatim}
Pour ce faire, nous allons utiliser le g\'en\'erateur pseudo-al\'eatoire suivant~:
\begin{verbatim}
void RemplirTableau(int *tab){
  register unsigned int i ;

  unsigned int m = (1 << 30) - 1 ; 

  tab[0] = 705 ; /* c'est la graine */

  for(i=1;i<TailleTabInt;i++)       
    tab[i] = 16807*TabInt[i-1] % m ; 
  /* les \'el\'ements de cette r\'ecurrence lin\'eaire */
  /* pr\'esentent les propri\'et\'es statistique du hasard */
}
\end{verbatim}
\paragraph{Question.}
Implanter suivant le principe d\'ecrit dans la section pr\'ec\'edente
la fonction de prototype~:
\begin{verbatim}
       void inttabqsort(int *tab, unsigned int taille);
\end{verbatim}
et tester la sur un tableau al\'eatoirement rempli.
\section{Quicksort g\'en\'erique}

\'Ecrivez le code source de la fonction de prototype suivant~:
\begin{verbatim}
       void mqsort(void *base, void *end, unsigned int size_el,
                  int(*compar)(void *, void *));
\end{verbatim}
avec
\begin{itemize}
\item \texttt{base} le premier \'el\'ement de la partition \`a trier~;
\item \texttt{end} le dernier \'el\'ement de la partition \`a trier~;
\item \texttt{size\_el} la taille de chaque cellule du tableau~;
\item \texttt{compar} un pointeur sur la fonction de comparaison.
\end{itemize}

Cette fonction applique le principe du tri Quicksort expos\'e plus
haut mais ne n\'ecessite aucune information suppl\'ementaire sur le
tableau \`a trier.

Votre fonction devra \^etre utilisable par quiconque sera en
possession du code source et du prototype. Par exemple, votre code
source doit permettre la production d'un code objet utilisable dans le
code suivant~:
\begin{verbatim}
struct toto{
  unsigned int bibi ;
  char foo ;
}  ;

struct toto tab[5] = { {1,'E'},{1,'D'},{1,'C'},{1,'B'}, {1,'A'} } ;

int mcompar(void *first, void *second){
  struct toto *one=(struct toto *) first, *two = (struct toto *) second ;
  return (one->foo+one->bibi) - (two->foo+one->bibi) ;
}

void mqsort(void *base, void *end, unsigned int size_el,
            int(*compar)(void *, void *));

int main(void){
  mqsort((void *) tab,(void *) (tab + 4),sizeof(struct toto),&mcompar) ;
  for(i=0;i<5;i++) 
    printf("%c\n",tab[i].foo) ;
}
\end{verbatim}

\end{document}
