\documentclass{article}
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\footnotesize\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again
\usepackage{fullpage}
\advance\hoffset by -3mm  % A4 is narrower.
\advance\voffset by  8mm  % A4 is taller.
\usepackage[french]{babel}
\usepackage{ifpdf}
\ifpdf
\usepackage{ae} % Almost European fonts
\usepackage{aeguill}
% En passant, on met en place de liens symbolique dans le pdf
\usepackage[pdftex]{hyperref}
\pdfadjustspacing=1
\fi
\title{Petite API de la biblioth\`eque bfd n\'ecessaire au projet}
\begin{document}
\maketitle
\begin{abstract}
  En guise de correction, je vais donner la description des
  principales fonctions de la biblioth\`eque bfd utilis\'e. 
%  Vous trouverez dans l'archive un code solution du projet (que j'ai
%  piqu\'e \`a Fran\c{c}ois Boulier.
  Je tente de pr\'esenter cette biblioth\`eque de mani\`ere
  progressive afin de servir de guide \`a la r\'ealisation du projet.
  \par
  Dieu reconna\^\i{}tra les siens\ldots\ mais ils seront dans un sale \'etat en arrivant.
  \flushright{Alexandre \verb?20:29?}
\end{abstract}

L'objet de base de la biblioth\`eque bfd est un type structure du
m\^eme nom qu'il est hors de question de d\'ecrire dans son ensemble
%(c'est proprement d\'elirant d'imaginer que nos \'etudiants vont y
%comprendre quoi que ce soit et donc pas question --- \`a mon sens ---
%de les inciter \`a lire la d\'eclaration de cette structure).
\par
Que doit-on en retenir alors~?
\par
\`A chaque fichier objet sera attach\'e une variable de type bfd qui
donne acc\`es \`a l'ensemble des informations n\'ecessaires. Ces
derni\`eres sont extractibles par le biais de fonctions d\'ej\`a
\'ecritent et constituant une API. Le projet consiste donc \`a bien
d\'eterminer ce que l'on cherche et comment le trouver.
\section{Placer l'information associ\'e \`a un fichier dans une structure bfd}
\paragraph{Cuisine interne.}
Pour commencer, il faut initialiser des donn\'ees internes et pour ce
faire, on dispose de~:
\begin{verbatim}
 void bfd_init(void);
   *Description*
This routine must be called before any other BFD function to initialize
magical internal data structures.
\end{verbatim}
De plus, on a tout int\'er\^et \`a utiliser le fichier d'ent\^ete \verb+#include <stdbool.h>+.
\par
La compilation du code n\'ecessite la libraire bfd et on peut invoquer
le compilateur comme suit~:
\begin{verbatim}
gcc foo.c -lbfd
\end{verbatim}
%Rien qu'\`a lire \c{c}a, on se sent \`a l'aise pour la suite et
%convaincu de la pertinence p\'edagogique du projet.
\paragraph{Entr\'ee-sortie.}
Un fichier \'etant donn\'e, il est possible d'assigner une variable de
type bfd tr\'es simplement par~:
\begin{verbatim}
     bfd *bfd_openr(const char *filename, const char *target);

Open the file FILENAME (using `fopen') with the target TARGET.  Return
a pointer to the created BFD.
\end{verbatim}
Cette instruction a son pendant~:
\begin{verbatim}
     bfd_boolean bfd_close (bfd *abfd);

Close a BFD. If the BFD was open for writing, then pending operations
are completed and the file written out and closed.  If the created file
is executable, then `chmod' is called to mark it as such.

   All memory attached to the BFD is released.

   The file descriptor associated with the BFD is closed (even if it
was passed in to BFD by `bfd_fdopenr').

   *Returns*  `TRUE' is returned if all is ok, otherwise `FALSE'.
\end{verbatim}
qui ne nous sera pas utile puisque l'on ne fait que lire la table des
symboles et que l'on ne cherche pas \`a \'ecrire (mais autant \^etre
propre).
\paragraph{Quel est le type du fichier.}
En nous restreignant \`a ce qui nous concerne, le fichier que nous
venons de consid\'erer peut \^etre~:
\begin{itemize}
\item un fichier objet~;
\item ou une archive.
\end{itemize}
La diff\'erence entre ses~$2$ types est donn\'ee par~:
\begin{verbatim}
   * `bfd_object'
   The BFD may contain data, symbols, relocations and debug info.

   * `bfd_archive'
   The BFD contains other BFDs and an optional index.
\end{verbatim}
Comment les distinguer me direz vous~? Et bien, on utilise~:
\begin{verbatim}
     bfd_boolean bfd_check_format(bfd *abfd, bfd_format format);

Verify if the file attached to the BFD ABFD is compatible with the
format FORMAT (i.e., one of `bfd_object', `bfd_archive' or `bfd_core').

   The function returns `TRUE' on success, otherwise `FALSE' with one
of the following error codes:
\end{verbatim}
\paragraph{Dans le cas d'une archive.}
Une archive est constitu\'ee de plusieurs fichiers objets et l'on
dispose d'une fonction permettant de passer de fichier objet en
fichier objet~:
\begin{verbatim}
     bfd *bfd_openr_next_archived_file(bfd *archive, bfd *previous);

Provided a BFD, ARCHIVE, containing an archive and NULL, open an input
BFD on the first contained element and returns that.  Subsequent calls
should pass the archive and the previous return value to return a
created BFD to the next contained element. NULL is returned when there
are no more.
\end{verbatim}
Pour chaque fichier objet constituant notre archive, on peut donc
obtenir une structure bfd le d\'ecrivant.
\section{Manipuler la table des symboles d'un fichier objet}

\paragraph{Le type symbol\_info.}
Pour commencer pr\'ecisons que symbol\_info est un type pr\'ed\'efini dans bfd.h
constitu\'e par une structure~:
\begin{verbatim}
typedef struct _symbol_info{
  symvalue value;
  char type;
  const char *name;            /* Symbol name.  */
  unsigned char stab_type;     /* Stab type.  */
  char stab_other;             /* Stab other.  */
  short stab_desc;             /* Stab desc.  */
  const char *stab_name;       /* String for stab type.  */
} symbol_info ;
\end{verbatim}
\`A chaque symbole nous allons devoir associer une telle structure. En
effet, les informations que l'on cherche sont incluse dans celle-ci.
Par exemple, le type est un caract\`ere qui est~U si le symbol n'est
pas d\'efini et une majuscule si le symbol est global.

\paragraph{Comment obtenir un objet symbol\_info~?}
Pour effectuer cette op\'eration, nous allons devoir passer par deux
objets interm\'ediaires~:
\begin{itemize}
\item les ``mini symboles''~;
\item et ``les asymbol''.
\end{itemize}
\subparagraph{D'un objet bfd aux ``mini symboles''.}
La fonction dont voici un exemple d'utilisation~:
\begin{verbatim}
bfd *abfd ;
long symcount;
void *minisyms;
unsigned int size;
symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);
\end{verbatim}
permet d'obtenir en retour un pointeur minisyms sur de l'espace
m\'emoire contenant des informations d\'esir\'ees, le nombre symcount
de symboles d\'efinis et la taille size de chaque espace m\'emoire
repr\'esentant~$1$ symbol.
\par
Le codage ``mini symboles'' n'est pas une structure mais de l'espace
m\'emoire brut qu'il va falloir exploiter.
\paragraph{D'une ``mini symboles'' aux asymbols.}
\`A partir d'une structure bfd, on peut construire une structure du
type asymbol~:
\begin{verbatim}
  asymbol * bfd_make_empty_symbol (bfd *);

Create a new `asymbol' structure for the BFD ABFD and return a pointer
to it.  Used by core file routines, binary back-end and anywhere else
where no private info is needed.
\end{verbatim}
Cette structure va nous permettre d'extraire des informations de
l'espace m\'emoire associ\'e aux ``mini symboles''.
Pour ce faire, on utilise la fonction bfd\_minisymbol\_to\_symbol ~:
\begin{verbatim}
bfd *abfd
asymbol *store, *sym;
bfd_byte *from;

    /* initialisation de store */
    store = bfd_make_empty_symbol (abfd);

    /* pour indiquer le point de d\'epart */
    from = (bfd_byte *) minisyms;
    
    sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
\end{verbatim}
La structure asymbol est associ\'ee \`a un unique symbole alors que
les ``mini symboles'' contiennent l'information associ\'e \`a
l'ensemble des symboles.
\par
Le pointeur store nous permet de stocker l'information associ\'ee au
premier symbole dans la variable sym. Si on voulait acc\'eder au
second symbole, on utiliserait from += size; avec size la taille
d\'etermin\'ee dans le paragraph pr\'ec\'edent.
\paragraph{D'une structure asymbol \`a une structure symbol\_info.}
Pour compl\'eter notre parcours, il nous reste \`a d\'efinir la fonction~:
\begin{verbatim}
 bfd_get_symbol_info (bfd *, asymbol *, symbol_info *);
\end{verbatim}
Cette derni\`ere permet \`a partir d'une structure asymbol d'obtenir
la structure symbol\_info correspondante que nous avons vue \^etre
facile \`a utiliser.
\end{document}
