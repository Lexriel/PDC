\documentclass{article}
\makeatletter  % makes '@' an ordinary character
\renewcommand{\verbatim@font}{%
  \ttfamily\footnotesize\catcode`\<=\active\catcode`\>=\active%
}
\makeatother   % makes '@' a special symbol again
\usepackage{fullpage}
\advance\hoffset by -3mm  % A4 is narrower.
\advance\voffset by  8mm  % A4 is taller.
\usepackage[french]{babel}
\usepackage{ifpdf}
\ifpdf
\usepackage{ae} % Almost European fonts
\usepackage{aeguill}
% En passant, on met en place de liens symbolique dans le pdf
\usepackage[pdftex]{hyperref}
\pdfadjustspacing=1
\fi
\newtheorem{proposition}{Proposition}

\title{biblioth\`eque Binary File Descriptor}
\begin{document}
\maketitle

\section{Sans utiliser de biblioth{\`e}que}

La commande UNIX {\em nm} consulte ce qu'on appelle la \emph{table des
symboles} d'un fichier objet, d'une biblioth{\`e}que ou d'un ex{\'e}cutable.
Voici un exemple.

\begin{verbatim}
$ cat a.c
int f ()
{
    return 1;
} 

int g ()
{
    return 2;
}

$ cat b.c
float zero = (float)0;

char un ()
{
    return '1';
}

$ cat main.c
extern int f ();
extern int g ();
int main ()
{   int x;
    x = f ();
}

$ gcc -c a.c b.c main.c
$ nm -g a.o
0000000000000000 T f
0000000000000014 T g
$ nm -g b.o
0000000000000014 T un
0000000000000000 D zero
$ nm -g main.o
                 U f
0000000000000000 T main
$ gcc a.o b.o main.o
$ nm -g a.out
... bla bla bla ...
0000000100000764 T f
0000000100000778 T g
00000001000007b4 T main
00000001000007a0 T un
000000010000078c D zero
\end{verbatim}

Avec l'option \emph{-g} {\em nm} n'imprime que les symboles \emph{globaux} 
(ou {\em extern} en C).
On s'int{\'e}resse aux deux derni{\`e}res colonnes.
On voit que 
\begin{enumerate}
\item	{\em a.o} comporte deux symboles globaux $f$ et $g$. La lettre {\em T}
	indique que les symboles sont d{\'e}finis dans des sections \emph{text} du 
	fichier objet (les sections \emph{text} contiennent le code en langage
	machine~; on a donc affaire {\`a} des fonctions)~;
\item	{\em b.o} comporte deux symboles {\em zero} et {\em un}. La lettre
	{\em D} indique que les symbole {\em zero} est d{\'e}fini dans une
	section \emph{data} du fichier objet. Les sections \emph{data}
	contiennent les donn{\'e}es initialis{\'e}es. On a donc affaire {\`a}
	une variable initialis{\'e}e, {\`a} une cha{\^\i}ne de caract{\`e}res etc \dots
\item 	{\em main.o} comporte un symbole {\em main} et une r{\'e}f{\'e}rence
	ind{\'e}finie (la lettre {\em U} signifie \emph{{\em undefined}}) {\`a}~$f$.
\end{enumerate}
L'{\'e}dition des liens est possible ici.
L'ex{\'e}cutable est obtenu en \emph{juxtaposant} le contenu des trois fichiers 
objets. On remarque que le contenu du fichier {\em b.o} est pr{\'e}sent bien 
qu'il ne soit pas en fait utilis{\'e}.
L'ex{\'e}cutable ne comporte aucune r{\'e}f{\'e}rence ind{\'e}finie. 
R{\'e}sumons--nous.

\begin{proposition}
Dans le cas o{\`u} on n'utilise aucune biblioth{\`e}que,
l'{\'e}dition des liens entre plusieurs fichiers objets est possible si,
et seulement si, 
\begin{enumerate}
\item	aucun symbole global d{\'e}fini dans un fichier objet n'est 
	red{\'e}fini dans un autre~;
\item	le symbole {\em main} est d{\'e}fini~;
\item	chaque symbole global ind{\'e}fini dans un fichier objet est d{\'e}fini
	dans un autre.
\end{enumerate}
\end{proposition}

\section{Utilisation d'une biblioth{\`e}que}

Une biblioth{\`e}que (fichier \emph{.a} ou {\em archive file} en Anglais)
n'est rien d'autre qu'une juxtaposition de fichiers objets (plus un
index pour s'y retrouver plus facilement).
On les cr{\'e}e avec la commande {\em ar} (pour {\em archive}).
Suite de l'exemple pr{\'e}c{\'e}dent.

\begin{verbatim}
$ ar cr libapin.a a.o b.o
$ gcc -L. main.c -lapin
\end{verbatim}

L'appel {\`a} {\em ar} a cr{\'e}{\'e} la biblioth{\`e}que {\em libapin.a}.
Cette biblioth{\`e}que contient les deux fichiers objets {\em a.o} et {\em b.o}.
Sur la derni{\`e}re ligne, on a compil{\'e} {\em main.c} en {\'e}ditant les liens 
avec cette biblioth{\`e}que. Quelques remarques sur les options de {\em gcc}~:
\begin{enumerate}
\item	l'option \emph{-Ldirectory} indique {\`a} {\em gcc} qu'il faut chercher
	la biblioth{\`e}que dans le r{\'e}pertoire {\em directory} (sur l'exemple,
	il faut chercher dans le r{\'e}pertoire courant \emph{.})~;
\item	pour {\'e}diter les liens avec {\em libxxx.a} on passe {\`a} {\em gcc}
	l'option \emph{-lxxx} (d'o{\`u} l'{\'e}criture \emph{-lapin}).
\end{enumerate}
La commande {\em nm} permet aussi d'{\'e}tudier le contenu d'une biblioth{\`e}que.
Suite de l'exemple.

\begin{verbatim}
$ nm -gs libapin.a

Archive index:
f in a.o
g in a.o
zero in b.o
un in b.o

a.o:
0000000000000000 T f
0000000000000014 T g

b.o:
0000000000000014 T un
0000000000000000 D zero
$ nm -g a.out
... meme bla bla ...
0000000100000784 T f
0000000100000798 T g
0000000100000764 T main
\end{verbatim}

L'option \emph{-s} pass{\'e}e {\`a} {\em nm} n'est utile que dans le cas
d'une biblioth{\`e}que~: elle demande l'impression de la table d'index.
On remarque que le contenu du fichier {\em b.o} n'est pas inclus dans
l'ex{\'e}cutable. C'est d{\^u} au fait qu'aucun symbole d{\'e}fini dans {\em b.o}
n'est n{\'e}cessaire.

\begin{proposition}
Lorsqu'on {\'e}dite les liens avec une biblioth{\`e}que, tout se passe comme
si on {\'e}ditait les liens avec les fichiers objets qui la composent
et dont au moins un symbole est n{\'e}cessaire.
\end{proposition}

\section{La biblioth{\`e}que standard}

Sauf demande expresse du contraire, {\em gcc} provoque syst{\'e}matiquement
l'{\'e}dition des liens avec la biblioth{\`e}que standard {\em libc.a}
habituellement situ{\'e}e dans le r{\'e}pertoire /usr/lib.

\begin{verbatim}
$ nm -g /usr/lib/libc.a
... gros bla bla ...
printf.o:
         U ___errno
         U __iob
         U __threaded
         U _doprnt
         U _ferror_unlocked
         U _flockget
         U _mutex_unlock
         U _setorientation
00000000 T printf
... gros bla bla ...
\end{verbatim}

\section{Utilisation de plusieurs biblioth{\`e}ques}

On peut fort bien {\^e}tre amen{\'e} {\`a} utiliser plusieurs biblioth{\`e}ques et
il se peut que certains fichiers objets contenus dans une biblioth{\`e}que
aient des r{\'e}f{\'e}rences ind{\'e}finies vers des symboles d{\'e}finis dans une
autre biblioth{\`e}que.

Une variante de l'exemple pr{\'e}c{\'e}dent illustre cette situation.

\begin{verbatim}
$ cat x.c
extern int trois;
int quatre ()
{
    return trois + 1;
}
$ cat y.c
int trois = 3;
$ cat princ.c
#include <stdio.h>
extern int quatre ();
int main ()
{
    printf ("%d\n", quatre ());
}
$ gcc -c x.c y.c princ.c
$ ar cr liboup.a x.o
$ ar cr libubrique.a y.o
$ nm -gs liboup.a
Archive index:
quatre in x.o
 
x.o:
0000000000000000 T quatre
                 U trois
$ nm -gs libubrique.a
Archive index:
trois in y.o
 
y.o:
0000000000000000 D trois
$ nm -g princ.o
0000000000000000 T main
                 U printf
                 U quatre
$ gcc -L. princ.o -loup -lubrique
$ a.out
4
$ gcc -L. princ.o -lubrique -loup
./liboup.a(x.o): In function `quatre':
x.o(.text+0x4): undefined reference to `trois'
x.o(.text+0x8): undefined reference to `trois'
x.o(.text+0xc): undefined reference to `trois'
x.o(.text+0x18): undefined reference to `trois'
collect2: ld returned 1 exit status
\end{verbatim}

On remarque que l'ordre dans lequel les biblioth{\`e}ques sont pass{\'e}es {\`a} {\em gcc}
est important~: l'{\'e}diteur de liens parcourt les biblioth{\`e}ques dans l'ordre 
dans lequel elles sont donn{\'e}es. Il ne revient pas \emph{en arri{\`e}re}.

Dans le premier cas, l'{\'e}dition des liens se passe bien.
Lors du parcours de {\em liboup.a}, le fichier {\em x.o} est inclus dans 
l'ex{\'e}cutable parce qu'il contient la d{\'e}finition manquante de {\em quatre}.
Ensuite, lors du parcours de {\em libubrique.a}, le fichier {\em y.o} est
inclus parce qu'il contient la d{\'e}finition manquante de {\em trois}.

Dans le deuxi{\`e}me cas, l'{\'e}dition des liens {\'e}choue.
Lors du parcours de {\em libubrique.a} l'{\'e}diteur des liens n'inclut pas
le fichier {\em y.o} parce qu'il n'y a encore aucune r{\'e}f{\'e}rence ind{\'e}finie
vers {\em trois}. Ensuite, lors du parcours de {\em liboup.a}, le
fichier {\em x.o} est inclus. C'est seulement {\`a} ce moment--l{\`a} qu'une r{\'e}f{\'e}rence
ind{\'e}finie vers le symbole {\em trois} appara{\^\i}t. Comme la biblioth{\`e}que
{\em libubrique.a} n'est pas parcourue une deuxi{\`e}me fois, la r{\'e}f{\'e}rence
reste ind{\'e}finie et l'{\'e}dition des liens {\'e}choue.

\section{Le projet}

\section{Le programme demand{\'e}}

Votre programme {\em projet} doit respecter la syntaxe suivante.

\begin{verbatim}
projet [--objets|--symboles] fichier-1 ... fichier-n
\end{verbatim}

Il retourne le code~$0$ si l'{\'e}dition des liens est possible et 
un code diff{\'e}rent de~$0$ sinon. Votre programme doit (comme {\em gcc})
syst{\'e}matiquement faire l'{\'e}dition des liens avec la biblioth{\`e}que standard.
Si l'{\'e}dition des liens est impossible,
il doit indiquer par un message appropri{\'e} sur la sortie d'erreur
standard les raisons de l'{\'e}chec. En cas de succ{\`e}s, si le premier param{\`e}tre vaut
{\em --objets} il doit imprimer les noms des fichiers objets n{\'e}cessaires
{\`a} l'{\'e}dition des liens (y compris ceux qui sont inclus dans les biblioth{\`e}ques)~;
si le premier param{\`e}tre vaut {\em --symboles} il doit 
imprimer les symboles globaux qui figureront dans l'ex{\'e}cutable. 

On a pu r{\'e}aliser le projet en r{\'e}partissant le code sur deux fichiers 
{\em projet.c} et {\em symtab.c} qui totalisent un peu plus de 300 lignes.
Voici des exemples d'ex{\'e}cution.

\begin{verbatim}
$ projet main.o a.o b.o
$ projet --objets main.o a.o b.o
main.o
a.o
b.o
$ projet --symboles main.o b.o a.o
main
f
zero
un
g
$ projet a.o b.o
main is undefined
linking failed
$ projet a.o a.o
twice defined symbol: f
twice defined symbol: g
main is undefined
linking failed
$ projet --objets main.o libapin.a
main.o
a.o
$ projet princ.o liboup.a libubrique.a
$ projet princ.o libubrique.a liboup.a
undefined symbol: trois
linking failed
$ projet projet.o symtab.o /usr/lib/libbfd.a /usr/lib/libiberty.a
$ projet projet.o symtab.o /usr/lib/libiberty.a /usr/lib/libbfd.a
undefined symbol: xstrerror
undefined symbol: xexit
undefined symbol: objalloc_create
undefined symbol: objalloc_free
undefined symbol: _objalloc_alloc
undefined symbol: objalloc_free_block
undefined symbol: hex_init
undefined symbol: _hex_value
undefined symbol: concat
linking failed
\end{verbatim}

\section{La documentation demand{\'e}e}

Avec le programme C on vous demande une documentation qui ne doit pas
d{\'e}passer 10 pages. Inutile d'inclure un listing du programme.
Cette documentation doit d{\'e}crire 
\begin{enumerate}
\item	les algorithmes que vous mettez en {\oe}uvre pour r{\'e}soudre le
	probl{\`e}me pos{\'e} (gestion de la table des symboles, etc.)~;
\item	une documentation aussi pr{\'e}cise que possible des fonctions de la 
	bfd que vous utilisez (cf. ci--dessous). Il est donc d{\'e}conseill{\'e} 
	d'utiliser plus
	de fonctions de la bfd qu'il n'est strictement n{\'e}cessaire ({\'e}viter
	les gros \emph{copier--coller}).
\end{enumerate}

\section{Informations utiles}

Vous utiliserez la biblioth{\`e}que {\em libfd.a}.
Vous aurez probablement besoin d'inclure le fichier {\em bfd.h} et
d'{\'e}diter les liens avec (dans l'ordre, cf. ci--dessus) les biblioth{\`e}ques 
{\em libfd.a} et {\em libiberty.a}.

Pour trouver la bonne fa{\c c}on d'utiliser la biblioth{\`e}que, le plus simple consiste
{\`a} {\'e}tudier le contenu du fichier {\em bfd.h} et le code du programme {\em nm.c}. 
On conseille de tracer l'ex{\'e}cution de {\em nm} en utilisant le debugger.

Dans /home/enseign/boulier/binutils-2.9/binutils se trouvent
le fichier {\em nm.c} ainsi que l'ex{\'e}cu\-table {\em nm} compil{\'e} de fa{\c c}on
{\`a} pouvoir en tracer l'ex{\'e}cution au debugger. On y trouve aussi une
documentation {\em bfd.dvi}. On vous d{\'e}conseille de l'imprimer (gros
fichier). M{\'e}fiez--vous en~: elle ne correspond pas exactement {\`a} la version 
de la bfd que vous utilisez~; en plus elle contient apparemment des erreurs.

\subsection{Contourner certaines erreurs de la bfd}

Pour contourner certaines erreurs (semble--t--il) de la biblioth{\`e}que bfd
(qui surviennent lorsqu'on parcourt les biblioth{\`e}ques pr{\'e}d{\'e}finies), on 
conseille d'utiliser les tests suivants pour d{\'e}ter\-miner si un symbole 
est global ou ind{\'e}fini~:

\begin{verbatim}
    bfd* fichier_objet;   /* fichier objet courant */
    asymbol* sym;         /* symbole courant dans le fichier_objet */
    symbol_info syminfo;

    ...
    bfd_get_symbol_info (fichier_objet, sym, &syminfo);
    if (isupper ((unsigned char)syminfo.type)
    { 
        /* le symbole est global */
    }
    if (syminfo.type == 'U')
    {
        /* le symbole est {\`a} la fois global et ind{\'e}fini */
    }
\end{verbatim}

\section{Progression conseill{\'e}e}

On vous conseille de r{\'e}aliser votre projet un peu {\`a} la fois en incluant
de plus en plus de fonctionnalit{\'e}s. Voici une progression propos{\'e}e~:

\begin{enumerate}
\item	{\'E}crire un programme qui lit un nom de fichier
	objet sur sa ligne de commande et qui imprime la table de
	ses symboles (comme {\em nm}).
\item	M{\^e}me chose mais en traitant en plus le cas d'une biblioth{\`e}que.
\item	R{\'e}aliser le projet dans le cas o{\`u} aucune biblioth{\`e}que n'est utilis{\'e}e.
\item	R{\'e}aliser le projet dans le cas o{\`u} seule la biblioth{\`e}que standard
	est utilis{\'e}e.
\item	R{\'e}aliser le projet complet.
\end{enumerate}

Attention~: testez votre programme sur les machines du M5.

\section{{\'E}valuation}

Le programme compte pour 1/3 de la note.
Le rapport pour 1/3. 
Un contr{\^o}le TP sur machine pour 1/3.

Il est indispensable que votre programme soit compilable et respecte
la syntaxe donn{\'e}e dans l'{\'e}nonc{\'e}.

Un programme qui r{\'e}sout parfaitement les probl{\`e}mes simples et pas du
tout les probl{\`e}mes compliqu{\'e}s est pr{\'e}f{\'e}r{\'e} {\`a} un programme qui r{\'e}sout
tout {\`a} moiti{\'e}.

La note tiendra compte de la lisibilit{\'e} du code et de la lisibilit{\'e}
des identificateurs de variables et de fonctions.

\end{document}