\documentclass{article}
\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage{fullpage}
\advance\hoffset by -3mm  % A4 is narrower.
\advance\voffset by  8mm  % A4 is taller.
\newtheorem{definition}{D\'efinition}
\title{Pratique du~C (INFO~$301$)~:\\
  Projet~: implantation du filtre grep} \begin{document}
\maketitle
\section{Introduction}
On se propose d'implanter en C-ANSI un filtre \texttt{mongrep} inspir\'e du
filtre \texttt{grep} existant sur la plupart des syst\`emes Unix.
\par
Bien que certaines notions utilis\'ees dans ce projet vous sont
famili\`eres puisque vues en cours de compilation, le sujet est
autosuffisant et ne n\'ecessite pas la ma\^\i{}trise de ce cours.
\par
Le filtre \texttt{mongrep} imprime les lignes, appartenant \`a un
fichier, qui contiennent un certain \emph{motif}. Ce dernier
correspond \`a l'ensemble des mots d'un \emph{langage} reconnu par un
automate associ\'e \`a une \emph{expression rationnelle}.  
\par
Le motif recherch\'e est donn\'e par l'utilisateur
dans la ligne de commande sous la forme d'un param\`etre
repr\'esentant une expression rationnelle (cf.\ section~\ref{ser:details} page~\pageref{ser:details}).
\par
 Le filtre \texttt{mongrep}
doit donc reconna\^\i{}tre le langage associ\'e pour effectuer la
recherche du motif.
\par
Pour toute expression rationnelle, il existe un unique (au nom des
\'etats pr\`es) automate fini d\'eterministe minimal
\emph{reconnaissant} le langage associ\'e. La construction d'un tel
automate passe par
\begin{enumerate}
\item la construction d'un arbre de syntaxe abstraite associ\'e \`a
  l'expression rationnelle~; 
\item la construction d'un automate fini %d\'eterministe
 \`a partir de  cet arbre~;
%\item la minimisation de cet automate d\'eterministe.
\end{enumerate}
Nous allons coder ces phases qui nous seront suffisantes (sans aller jusqu'\`a construire un automate fini d\'eterministe). % bien que la derni\`ere ne soit pas
%imp\'erative \`a l'implantation du filtre~\texttt{mongrep}.
\section{Une grammaire d'expressions rationnelles}
\label{sec:GramExpRat}
La grammaire des expressions rationnelles utilis\'ees par la
commande~\texttt{mongrep} est donn\'ee par la Figure~\ref{grammaire}
page~\pageref{grammaire}. C'est une version tr\`es simplifi\'ee de
celle utilis\'ee par \texttt{grep}.
\begin{figure}
{\normalsize
\begin{verbatim}
expression ::= expression_concatenation '|' expression || expression_concatenation
expression_concatenation ::= expression_repetition expression_concatenation 
                             || expression_repetition
expression_repetition ::= expression_simple '*' || expression_simple
expression_simple ::= '(' expression ')' || car_non_speciaux || intervalle
car_non_speciaux ::= tout caractere sauf '|', '*', '[', ']', '.' || '\|' || '\*' 
                     || '\[' || '\]' || '\.'
intervalle ::= '.' || '[' liste ']' || '[^' liste ']' || '[' liste '-]' 
               || '[^' liste '-]'
liste ::= non_moins liste1 
liste1 ::= non_fermant liste1
non_moins ::= tout caractere sauf '-'
non_fermant ::= tout caractere sauf ']'
\end{verbatim}
}
\caption{Grammaire des expressions rationnelles de \texttt{mongrep}
  \label{grammaire}}
\end{figure}
Notre filtre \texttt{mongrep} va prendre une cha\^\i{}ne de
caract\`eres codant une expression rationnelle en param\`etre depuis
la ligne de commande d'un shell. Dans un premier temps, cette
cha\^\i{}ne va \^etre convertie en un arbre binaire d\'enomm\'e
\emph{arbre de syntaxe abstraite}.
%% -------------------------------------------------------------------------
\section{Construction d'un arbre de syntaxe abstraite correspondant
  \`a une expression rationnelle}
La Figure~\ref{arbre} page~\pageref{arbre} sch\'ematise la repr\'esentation d'un tel arbre
et les principales fonctions permettant sa construction \`a partir
d'une cha\^\i{}ne de caract\`eres --- prise sur l'entr\'ee standard
--- pour une grammaire simplifi\'ee.
\begin{figure}
  \begin{center}
    \leavevmode
    \includegraphics[width=\textwidth]{asa}
  \end{center}
  \caption{Construction de l'arbre \label{arbre}}
\end{figure}
Pour \^etre plus pr\'ecis, la fonction \texttt{simple} de la Figure~\ref{arbre}  page~\pageref{arbre}  
implante la r\`egle
\begin{verbatim}
simple ::= '(' expr ')' || car 
\end{verbatim}
de la grammaire simplifi\'ee.
\par
Notez bien qu'en ce qui concerne le filtre \texttt{mongrep} que l'on
vous demande d'implanter, la cha\^\i{}ne de caract\`eres
repr\'esentant l'expression rationnelle consid\'er\'ee n'est pas prise
sur l'entr\'ee standard --- comme dans l'exemple de la Figure~\ref{arbre} ---
mais comme param\`etre du filtre. 
Ainsi, on vous demande d'adapter le code de
la Figure~\ref{arbre} page~\pageref{arbre} afin d'\^etre utilisable
dans le filtre \texttt{mongrep} et de le compl\'eter afin de pouvoir
implanter la grammaire de la Figure~\ref{grammaire}
page~\pageref{grammaire}.
\par
Les algorithmes pr\'esent\'es dans la suite utilisent l'arbre de
syntaxe abstraite construit pr\'ec\'edemment, auquel on a ajout\'e un
n\oe{}ud racine (de type~\verb+CONCAT+) ayant pour fils droit un
n\oe{}ud de fin~$\textrm{end}$ (not\'e \# dans la Figure~\ref{arbre})
et pour fils gauche l'arbre de syntaxe abstrait originel.
%% -------------------------------------------------------------------------
\input{automate}
%% -------------------------------------------------------------------------
%  \subsection{Construction de l'automate d\'eterministe}
%  Pour obtenir l'automate d\'eterministe \`a partir de ces ensembles, il
%  reste \`a appliquer l'algorithme pr\'esent\'e Fig.~\ref{determ}
%  page~\pageref{determ}. Cet algorithme construit un ensemble
%  d'\'etats~$Detat$, chaque \'etat \'etant associ\'e \`a un sous-arbre
%  de l'arbre de syntaxe abstraite, et une table de transition~$Dtran$,
%  repr\'esentant les transitions de l'automate. Ainsi, si~${Dtran[T, a]
%    = U}$, alors il y a une transition dans l'automate de l'\'etat~$T$
%  \`a l'\'etat~$U$ \'etiquet\'ee par la lettre~$a$. \par Les \'etats
%  de~$Detat$ sont marqu\'es pour pouvoir indiquer s'ils ont \'et\'e
%  examin\'es ou pas. L'\'etat initial de l'automate
%  est~$\textrm{initial}(root)$, les \'etats finaux sont tous les \'etats
%  associ\'e au n\oe{}ud repr\'esentant le symbole de fin.
%  \begin{figure}[htbp]
%    {\bf Initialement},~$Detat$ contient un seul \'etat non marqu\'e
%    constitu\'e des \'el\'ements de~$\textrm{initial}(root)$.
%    \par
%    {\bf Tant qu'}il reste un \'etat~$T$ non marqu\'e dans~$Detat$ {\bf
%      faire}
%    \begin{itemize}
%    \item marquer~$T$;
% %        \item {\bf Pour} chaque lettre~$a$ de l'alphabet {\bf faire}
% %          \begin{itemize}
% %          \item Soit~$U$ l'ensemble des n\oe{}uds de l'arbre qui sont
% %            dans~$\textrm{follow}(p)$, avec~$p$ le n\oe{}ud
% %            associ\'e
% %            \`a~$T$, et tel que~$p$ repr\'esente la lettre~$a$~;
% %          \item {\bf Si}~$U$ n'est pas vide et n'appartient pas
% %            \`a~$Detat$, {\bf alors} ajouter~$U$ \`a~$Detat$ (sans
% %            le
% %            marquer)~;
% %          \item $Dtran[T, a] = U$~;
% %          \end{itemize}
% %        \end{itemize}
%  \item[] Soit~$U$ l'ensemble des n\oe{}uds de l'arbre qui sont
%    dans~$\textrm{follow}(p)$, avec~$p$ le n\oe{}ud associ\'e
%    \`a~$T$. \par
%    Pour tout \'el\'ement de~$u$ de~$U$ faire~: \begin{itemize} \item
%      {\bf Si} $u$ qui n'appartient pas d\'ej\`a \`a~$Detat$, {\bf
%        alors} ajouter~$u$ \`a~$Detat$ (sans le marquer)~; \item
%      ${Dtran[T, a] = u}$ pour chaque lettre~$a$ dans l'alphabet
%      associ\'e au n\oe{}ud~$p$. \end{itemize} \end{itemize}
%  \caption{Construction de l'automate d\'eterministe. \label{determ}}
%  \end{figure}
 %% -------------------------------------------------------------------------
% \subsection{Minimisation de l'automate}
% %% -------------------------------------------------------------------------
% Veuiller \`a terminer une implantation du filtre \texttt{mongrep}
% avant d'implanter cette minimisation.
% \par\medskip
% La minimisation d'un automate d\'eterministe~$M$ s'effectue en
% partitionnant l'ensemble de ses \'etats. Le calcul de cette
% partition~$\Pi_{finale}$ se fait en appliquant it\'erativement
% l'algorithme de la figure~\ref{minim} sur la partition
% courante~$\Pi$. Chaque application de cet algorithme \`a~$\Pi$
% calcule une nouvelle partition~$\Pi_{new}$, et, lorsque~${\Pi_{new}
%   = \Pi}$, on a trouv\'e la partition finale~${\Pi_{finale} =
%   \Pi_{new}}$. Si~${\Pi_{new} \neq \Pi}$, on r\'eitère l'algorithme
% de la figure~\ref{minim} en prenant~${\Pi = \Pi_{new}}$.
% Initialement, la partition~$\Pi$ comporte deux groupes, le groupe
% des \'etats acceptants (finaux), et les \'etats non-acceptants.

% \begin{figure}[htbp] {\bf Pour} chaque groupe~$G$ de~$\Pi$ {\bf
%     faire} \begin{itemize} \item Partitionner~$G$ en sous-groupes,
%     de sorte que \begin{quote} deux \'etats~$s$ et~$t$ de~$G$ sont
%       dans le m\^eme sous-groupe {\em si et seulement si}, pour
%       toute lettre~$a$ de l'alphabet, les \'etats~$s$ et~$t$ ont une
%       transition par~$a$ vers des \'etats qui appartiennent au
%       m\^eme groupe de~$\Pi$; \end{quote} \item Remplacer~$G$
%     dans~$\Pi_{new}$ par l'ensemble des sous-groupes calcul\'es
%     pr\'ec\'edemment; \end{itemize} \caption{Algorithme de
%     partitionnement d'une partition $\Pi$.} \label{minim}
% \end{figure}

% Chaque groupe d'\'etats de~$\Pi_{finale}$ repr\'esente en fait un
% \'etat de l'automate minimal~$M'$. Pour calculer les transitions de
% l'automate minimal, on choisit pour chaque groupe de~$\Pi_{finale}$
% un \'etat {\em repr\'esentant}. Les \'etats de l'automate minimal
% seront les \'etats repr\'esentants. Soit $s$ un \'etat
% repr\'esentant, et supposons qu'il y a une transition par la lettre
% $a$ dans l'automate non minimal de $s$ vers $t$. Soit $r$ le
% repr\'esentant du groupe de $t$, alors on a une transition dans
% l'automate minimal de $s$ vers $r$ par la lettre $a$. L'\'etat
% initial de $M'$ sera le repr\'esentant du groupe contenant l'\'etat
% initial de $M$, ses \'etats finaux seront les repr\'esentants des
% groupes qui contiennent un \'etat final de $M$. Il reste \`a
% supprimer les \'etats morts (bouclant sur eux-m\^emes pour toute
% lettre) non finaux, et les \'etats non-atteignables depuis l'\'etat
% initial.

%% -------------------------------------------------------------------------
\section{Implantation de la commande \texttt{mongrep}}
%% -------------------------------------------------------------------------
\label{ser:details}
La commande \texttt{mongrep} a la syntaxe suivante:
\begin{verbatim}
mongrep  expression-rationnelle < fichier
\end{verbatim}
en utilisant la grammaire des expressions rationnelles pr\'esent\'ee
dans la section~\ref{sec:GramExpRat}. Cette commande effectue la
recherche des motifs dans le fichier envoy\'e sur son entr\'ee
standard~; elle affiche les lignes qui contiennent un mot du langage
d\'efini par l'expression rationnelle.

Remarque~: les caract\`eres ASCII constituant les m\'etacaract\`eres
sont d'abord interpr\'et\'e par le shell. Ainsi le filtre
\texttt{mongrep} doit en tenir compte comme dans les exemples
suivants --- et \'equivalents --- d'appels~:
\begin{verbatim}
% ./mongrep '(a|b)*abb' < foo # l'accent aig\"u ' bloque l\'evaluation
% ./mongrep \(a\|b\)\*abb < foo
\end{verbatim}
Le caract\`ere ASCII~\verb+\+ permet de bloquer l'\'evaluation du
m\'etacaract\`ere par le shell et permet ainsi \`a la commande
\texttt{mongrep} de le traiter. Votre filtre \texttt{mongrep} doit
permettre de consid\'erer un m\'etacaract\`ere comme un caract\`ere
ASCII normal sur le m\^eme principe (utilisation de~\verb+\+).
 
\section{R\'ealisation}
\label{sec:realisation}

Vous devez rendre (par l'interface PROF) un r\'epertoire contenant~:
\begin{itemize}
\item les codes sources de votre projet~; \item un Makefile permettant
  la compilation de votre projet~; \item un fichier de test
  \texttt{testfile} et un script shell
  \texttt{test.sh} utilisant \texttt{mongrep} sur ce fichier test.
\end{itemize} Vous pouvez adjoindre une description de votre
implantation. \end{document}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
