\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{eepic}
\newcommand{\dashlinestretch} {}

\topmargin -2.5cm
\textheight 25cm
\textwidth 16cm
\oddsidemargin 0cm
\evensidemargin 0cm

%---------- Entete de feuille ----------
\def\entete{St\'eganographie \'el\'ementaire avec un fichier BMP
\centerline{\bf \large  IUC}
\smallskip
\hrule
\medskip}

%----------- D\'efinition exercice -------
\newcounter{exerc}
\newcommand{\exercice}{\stepcounter{exerc}
  \setcounter{quest}{0}
  \paragraph{\large \bf Exercice \theexerc~:}}
\newcounter{quest}
\newcommand{\quest}{\stepcounter{quest}
  \setcounter{subquest}{0}
  {\noindent \bf Q \thequest~. }}
\newcounter{subquest}
\newcommand{\subquest}{\noindent \stepcounter{subquest}
  \hspace{0.2cm}{Q \thequest.\thesubquest.~}}

% ---------- C'est parti ---------------

\title{St\'eganographie \'el\'ementaire avec un fichier BMP}
\author{V.~B\'enony\qquad A.~Sedoglavic \\
Universit\'e des Sciences et Technologies de Lille}
\date{2003--2004}
\begin{document}
\maketitle
\section{Pr\'esentation}

\bigskip

\emph{La st\'eganographie (du grec \emph{steganos}, couvert et
  \emph{graphein}, \'ecriture) c'est l'art de cacher un message au sein
  d'un autre message de caract\`ere anodin, de sorte que l'existence
  même du secret en soit
  dissimul\'ee\footnote{http://lwh.free.fr/pages/algo/crypto/steganographie.htm}.}

\bigskip

Le but de ce projet sera de dissimuler de l'information (sous la forme
d'une cha\^\i{}ne de caract\`eres quelconque) dans une image stock\'ee en BMP\@.
Pour ce faire, nous allons tout d'abord pr\'esenter le format de fichier
BMP\footnote{http://www.wotsit.org/filestore/bmpfrmat.zip}.

\section{Le format BMP 24 bits non compress\'e}

Nous nous occuperons uniquement dans cette section des fichiers BMP
\emph{non compress\'es} et en \emph{24 bits} puisqu'il s'agit du format
le plus simple \`a manipuler.

Afin d'obtenir ce type de format \`a partir d'une image sous un autre
format, vous pouvez utilisez un utilitaire comme gimp (fonction Save as).

Le fichier est constitu\'e de deux parties distinctes : le \emph{header}
et les \emph{donn\'ees non compress\'ees}.

\subsection{Header BMP}

Le header est une repr\'esentation binaire des informations concernant
une image. Cet en-t\^ete contient des informations sur la taille de
l'image en largeur et en hauteur (en \emph{pixels}), le nombre de
couleurs ou encore le type d'encodage des donn\'ees.

C'est gr\^ace \`a cet en-t\^ete que nous allons pouvoir d\'eterminer si les
informations d'un fichier BMP sont conformes \`a ce que l'on attend en
entr\'ee de notre projet.

L'ent\^ete est constitu\'e d'une s\'erie d'entiers, cod\'es sur 16 ou 32 bits
(respectivement 2 ou 4 octets). Ces entiers sont dispos\'es dans un
ordre pr\'ecis :
$$
\begin{tabular}{|l|c|l|}
\hline
&&\\
Nom du champs & Longueur en octets & Signification\\
&&\\
\hline
Identifier      & 2     & Contient toujours  l'octet `B' suivit de l'octet `M'\\
FileSize        & 4     & Taille totale du fichier en octets\\
Reserved        & 4     & Champs r\'eserv\'e, doit \^etre \'egal \`a 0\\
DataOffset      & 4     & Nombre d'octets s\'eparant le d\'ebut du fichier des donn\'ees de l'image\\
HeaderSize      & 4     & Taille en octets de l'header\\
Width           & 4     & Largeur de l'image en pixels\\
Height          & 4     & Hauteur de l'image en pixels\\
Planes          & 2     & Nombre de plans\\
BitsPerPixels   & 2     & Nombre de bits n\'ecessaires pour repr\'esenter un pixel\\
Compression     & 4     & Type de compression\\
BitmapDataSize  & 4     & Taille en octets des donn\'ees de l'image\\
HResolution     & 4     & R\'esolution horizontale de l'image en pixels par m\`etre\\
VResolution     & 4     & R\'esolution verticale de l'image en pixels par m\`etre\\
Colors          & 4     & Nombre de couleurs dans l'image\\
ImportantColors & 4     & Nombre de couleurs importantes\\
\hline
\end{tabular}
$$

Tous les champs ne nous concernent pas ; seuls les champs
$\mathtt{Identifier}$, $\mathtt{DataOffset}$, $\mathtt{Width}$,
$\mathtt{Height}$, $\mathtt{BitsPerPixels}$, $\mathtt{Compression}$ et
$\mathtt{BitmapDataSize}$ seront r\'eellement n\'ecessaires.

\bigskip \bigskip \bigskip \bigskip


\exercice\ \\
D\'efinissez un type $\mathtt{BMP\_HEADER}$ contenant toutes les
informations d'une en-t\^ete BMP. \'Ecrivez ensuite une fonction
permettant de lire l'ent\^ete d'un fichier BMP, et dont le prototype
sera :

\begin{verbatim}
          int loadBitmapHeader(FILE *fichier, BMP_HEADER *entete);
\end{verbatim}

On consid\`ere donc que le fichier \`a donc \'et\'e ouvert \`a l'ext\'erieur de la
fonction, et que le pointeur retourn\'ee par une fonction \verb|fopen|
est donn\'ee en param\`etre (pointeur \verb|fichier|). La fonction aura
pour but de remplir la structure point\'ee par \verb|entete|. La
fonction retournera $1$ si l'op\'eration s'est effectu\'ee normalement, et
$0$ sinon.



\exercice\ \\
\'Ecrivez une fonction permettant de v\'erifier la validit\'e d'un en-t\^ete
de fichier BMP\@. La fonction devra v\'erifier :

\begin{enumerate}
\item qu'il s'agit bien d'un fichier BMP (en v\'erifiant que les deux
  premiers octets soient bien `B' et `M')
\item qu'il s'agit d'un fichier non compress\'e (le champs
  $\mathtt{Compression}$ doit \^etre \'egal \`a~$0$)
\item que le fichier est bien un fichier en~$24$ bits (le champs
  $\mathtt{BitPerPixels}$ doit \^etre \'egal \`a~$24$).
\item que la taille des donn\'ees ($\mathtt{BitmapDataSize}$) est bien
  \'egal \`a $\mathtt{Width} \times \mathtt{Height} \times 3$.
\end{enumerate}

Le prototype de la fonction sera le suivant :
\begin{verbatim}
          int isBitmapHeaderCorrect(BMP_HEADER *header);
\end{verbatim}

La fonction retournera $1$ si tout est correct, et $0$ sinon.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Organisation des donn\'ees}

Les donn\'ees des fichiers BMP non compress\'es en 24 bits sont tr\`es
simples \`a interpr\'eter. En effet, chaque \'el\'ement de l'image (ou
\emph{pixel} pour \emph{picture element}) est cod\'e sur 3 octets (d'où
$3\times8 = 24$ bits). Chacun de ces octets repr\'esente la proportion
de chacune des trois couleurs fondamentales composant toute couleur.

$$
\mathrm{Pixel} = (\mathrm{Rouge}, \mathrm{Vert}, \mathrm{Bleu}).
$$

Le taux de rouge, de vert et de bleu est cod\'e pour chaque composante
sur 8 bits (donc entre 0 et 255 compris).

Nous allons utiliser le fait que l'oeil humain \`a beaucoup de mal \`a
distinguer des nuances de couleurs tr\`es proches l'une de l'autre pour
cacher de l'information. Si l'on consid\`ere deux pixels voisins dans
une image, et dont les repr\'esentations sont les suivantes :
$$
\mathrm{Pixel_1} = (10010110_{(2)}, 11010101_{(2)},
00101100_{(2)}),
$$
$$
\mathrm{Pixel_2} = (10010110_{(2)}, 11010100_{(2)},
00101100_{(2)}).
$$

Alors, il est quasiment impossible de d\'etecter une diff\'erence de
couleur \`a l'oeil nu entre ces deux couleurs. Or, elle diff\`erent bien
l'une de l'autre, puisque leurs taux de vert (deuxi\`eme composante)
sont diff\'erents. Nous pouvons donc conclure que modifier le bits de
poids le plus faible dans une composante chromatique n'a quasiment
aucun impact sur notre perception visuelle de l'image.

\medskip Le principe du codage est alors le suivant; si l'on
consid\`ere un message $m$ \`a cacher dans une image, on note $m_i$ le
$i$i\`eme octet de ce message, et $[m_i]_j$ le $j$i\`eme bit de ce
$i$i\`eme octet (les octets sont num\'erot\'es \`a partir de 0, et les
bits sont num\'erot\'e 7 pour le bits de poids le plus fort, et 0 pour
le bit de poids le plus faible).  Il est alors facile de d\'efinir une
suite $u_n$ qui contient la suite des bits composant le message $m$ :
$$
u_n = \left\lbrace
\begin{array}{ll}
        [m_{\frac{n}{8}}]_{(7 - (n\%8))} 
        & \mathrm{si}\ n\in[0 \ldots 8\times \mathtt{strlen}(m)], \\
        0 & \mathrm{sinon}
\end{array} 
\right.
$$

avec $x/y$ la division enti\`ere de $x$ par $y$, et $x\%y$ le reste de
la division enti\`ere de $x$ par $y$.


\exercice\ \\
\'Ecrivez une fonction permettant de calculer $u_n$ pour tout $n$
connaissant le message $m$. Le prototype de la fonction sera :
\begin{verbatim}
          int getBit(char *m, int n);
\end{verbatim}

\bigskip \bigskip

Les pixels composant l'image se trouvent, dans le fichier, juste apr\`es
l'en-t\^ete. Le nombre d'octets composant ces donn\'ees est sp\'ecifi\'e dans
l'en-t\^ete sous le champs $\mathtt{BitmapDataSize}$.


\exercice\ \\
\'Ecrivez une fonction permettant de lire les donn\'ees d'un fichier BMP\@.
Le header du fichier (qui aura au pr\'ealablement \'et\'e lu gr\^ace \`a un
appel \`a la fonction \verb|loadBitmapHeader|) sera donn\'ee en param\`etre
\`a cette fonction. Elle retournera un pointeur de type %
\verb|unsigned char *| qui pointera une zone en m\'emoire allou\'ee
par cette fonction, et qui contiendra la suite des pixels lus \`a
partir du fichier.

Le prototype de cette fonction sera :
\begin{verbatim}
          unsigned char * loadBitmapDatas(FILE *fichier, BMP_HEADER *header);
\end{verbatim}

La fonction retournera \verb|NULL| si elle n'arrive pas \`a lire les
donn\'ees du fichier BMP\@. On consid\`ere que la validit\'e du fichier (via
la fonction \verb|isBitmapHeaderCorrect|) aura \'et\'e v\'erifi\'e.


\exercice\ \\
\'Ecrivez une fonction permettant de sauvegarder un fichier BMP gr\^ace
aux informations d'un header qui sera donn\'e en param\`etre, et d'un
pointeur sur une zone en m\'emoire contenant les pixels de l'image. Le
prototype sera :

\begin{verbatim}
          int saveBitmapDatas(FILE *fichier, BMP_HEADER *header, unsigned char *pixels);
\end{verbatim}

La fonction retournera $1$ si tout s'est pass\'e correctement et $0$
sinon.

\section{Fonction de permutation}

Afin de ne pas placer le message dans les octets les uns \`a la suite
des autres dans le fichier BMP r\'esultant, nous allons \'ecrire une
fonction capable de construire des fonctions de permutation d\'efinie
par un param\`etre que l'on appellera la \emph{cl\'e du syst\`eme}. Cette
fonction de permutation nous permettra de savoir quels sont les octets
de l'image \`a modifier, et dans quel ordre. Pour repr\'esenter $f$, nous
allons utiliser un tableau de $N$ entiers, où la $i$i\`eme case
du tableau contiendra la valeur de $f(i)$.

Une fonction de permutation est une fonction agissant d'un ensemble
$\mathbb{K} = [0 \ldots N-1]$ d'entiers vers ce m\^eme ensemble
$\mathbb{K}$, et dont le but est de d\'efinir une \emph{bijection}.
$$
f : \mathbb{K} \longrightarrow \mathbb{K}
$$
$$
\forall (x, y) \in \mathbb{K}^2, f(x) = f(y) \Longleftrightarrow x
= y
$$

Pour arriver \`a notre but, nous allons d\'efinir $f$ comme la plus simple
permutation qui soit, c'est \`a dire :
$$
f(x) = x.
$$

C'est \`a dire que dans le tableau repr\'esentant cette fonction, nous
allons placer dans la $i^{i}$\`eme case la valeur $i$. Ensuite, nous
allons \'echanger certaines cases de ce tableau de mani\`ere al\'eatoire. Le
processus est le suivant :

\begin{center}
\begin{tabular}{|l|}
\hline
\\
Faire $N$ fois\\
\hspace{1cm}tirer au hasard deux entiers $i$ et $j$\\
\hspace{1cm}les contraindre \`a l'ensemble $[0..N-1]$ en calculant\\
\hspace{2cm}$i$ = $i$ modulo $N$\\
\hspace{2cm}$j$ = $j$ modulo $N$\\
\hspace{1cm}\'echanger les cases i et j du tableau repr\'esentant la fonction\\
\\
\hline
\end{tabular}
\end{center}

Le probl\`eme est qu'il faut \^etre capable de construire \`a nouveau cette
m\^eme fonction \`a tout moment. Or la notion de hasard ne nous permet pas
de conna\^\i{}tre \`a l'avance la fonction qui va \^etre construite. Pour
\emph{contraindre le hasard}, nous allons utiliser la fonction C
\verb|srand(unsigned int seed)| afin de modifier l'\'etat initial du
g\'en\'erateur pseudo-al\'eatoire. Il suffira donc, avant tout appel \`a la
fonction de g\'en\'eration d'al\'ea \verb|rand| d'appeler la fonction
\verb|srand|, param\'etr\'ee par la cl\'e du syst\`eme.


\exercice\ \\
\'Ecrivez une fonction capable de construire une fonction de permutation
selon le principe \'evoqu\'e plus haut. La fonction retournera un pointeur
sur la fonction construite (c'est donc \`a cette fonction d'allouer la
place en m\'emoire n\'ecessaire \`a la repr\'esentation de la fonction de
permutation)\footnote{pour les \'etudiants de mon groupe : la fonction
  que je vous ai demand\'e en s\'eance de TP est \`a modifier (tr\`es
  l\'eg\`erement) afin d'allouer la m\'emoire n\'ecessaire AVANT de construire
  la fonction}. Le prototype sera le suivant :

\begin{verbatim}
          int * createPermutationFunction(int N, unsigned int key);
\end{verbatim}

La fonction retourne donc un tableau d'entiers repr\'esentant la
fonction de permutation construite.

\section{Camouflage du message dans l'image}

Nous allons maintenant modifier une image BMP afin d'y cacher un
texte. Le processus est alors le suivant :

\begin{center}
\begin{tabular}{|l|}
\hline
\\
pour $i$ allant de $0$ \`a~$(1 + \mathrm{strlen}(m)) \times 8$\\
\hspace{1cm}calculer ${b =\mathtt{getBit}(m, i)}$\\
\hspace{1cm}calculer $o = $ permutation[i] le num\'ero de l'octet des pixels qui sera modifi\'e\\
\hspace{1cm}effacer le bit de poids faible du $o^{i}$\`eme octet du tableau de pixels\\
\hspace{1cm}remplacer ce bit par $b$\\
\\
\hline
\end{tabular}
\end{center}

Le fait de placer~${(1 + \mathtt{strlen}(m)) \times 8}$ bits dans
l'image permet de sauvegarder tous les bits du message $m$
(soit~${\mathrm{strlen}(m)\times 8}$ bits) plus le z\'ero qui termine
toute cha\^\i{}ne de caract\`eres en~C~($8$ bits suppl\'ementaires).


\exercice\ \\
\'Ecrivez une fonction capable d'ouvrir un fichier BMP, lire les
informations concernant l'en-t\^ete et le tableau de pixels, cacher un
message, et sauvegarder un fichier r\'esultant. Le nom des fichiers \`a
lire et cr\'eer, ainsi que le message et la cl\'e permettant de construire
la fonction de permutation seront donn\'ee en param\`etre \`a la fonction.
Le prototype sera :

\begin{verbatim}
          int hideMessage(char *source, char *dest, char *message, unsigned int key);
\end{verbatim}

\verb|source| et \verb|dest| repr\'esentent donc les noms des fichiers \`a
respectivement lire, et cr\'eer. La fonction retournera $1$ si tout
s'est pass\'e correctement, et $0$ sinon.



\exercice\ \\
D\'eterminez l'algorithme capable d'effectuer l'op\'eration inverse,
puis \'ecrivez la fonction correspondante en C\footnote{Il suffit de
  construire la fonction de permutation de la m\^eme mani\`ere, puis de
  concat\'ener les bits de poids faible afin de reconstruire le message
  jusqu'\`a ce que l'on ai 8 z\'eros de suite (fin de cha\^\i{}ne).}.
Le prototype sera le suivant :
\begin{verbatim}
          char * retrieveMessage(char *source, unsigned int key);
\end{verbatim}

\verb|source| sera le nom du fichier BMP \`a lire.

\end{document}

