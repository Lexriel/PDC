\documentclass[a4paper]{article}

\usepackage[french]{babel}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{eepic}
\newcommand{\dashlinestretch} {}

\topmargin -2.5cm
\textheight 25cm
\textwidth 16cm
\oddsidemargin 0cm
\evensidemargin 0cm

%---------- Entete de feuille ----------
\def\entete{Implantation sommaire d'un allocateur de m\'emoire
\centerline{\bf \large  PDC}
\smallskip
\hrule
\medskip}

%----------- D\'efinition exercice -------
\newcounter{exerc}
\newcommand{\exercice}{\stepcounter{exerc}
  \setcounter{quest}{0}
  \paragraph{\large \bf Exercice \theexerc~:}}
\newcounter{quest}
\newcommand{\quest}{\stepcounter{quest}
  \setcounter{subquest}{0}
  {\noindent \bf Q \thequest~. }}
\newcounter{subquest}
\newcommand{\subquest}{\noindent \stepcounter{subquest}
  \hspace{0.2cm}{Q \thequest.\thesubquest.~}}

% ---------- C'est parti ---------------

\title{Implantation sommaire d'un allocateur de m\'emoire}
\author{Pratique du C  \\
Universit\'e des Sciences et Technologies de Lille}
\date{2004--2005}
\begin{document}
\maketitle
\section{Pr\'esentation}
Pour disposer d'une zone m\'emoire contig\"ue, on peut utiliser la fonction de prototype
\begin{verbatim}
#include <unistd.h>
void *sbrk(ptrdiff_t increment);
\end{verbatim}
Cette fonction alloue \texttt{increment} octets et retourne l'adresse
de cette zone. Par exemple, le code
\begin{verbatim}
#include <stdlib.h>
#define BUFFERSIZE 65536
#define DETAIL_TECHNIQUE 2*sizeof(void *)
int main(void){
 void *buffer ;
 int i,res ;
 buffer = sbrk(BUFFERSIZE);
 int *ptr = (int *) buffer ;
 if(buffer!=-1)
   /* utilisation de la nouvelle zone m\'emoire */
   for(i=0;i<BUFFERSIZE+10;i++)
        ptr[i]= 666 ;
 return res ;
}
\end{verbatim}
permet d'obtenir une zone m\'emoire point\'ee par \texttt{buffer} de
taille \texttt{BUFFERSIZE} et la remplit de~$666$.  Pour plus de
d\'etails, reportez vous au manuel en ligne du programmeur Linux.
\paragraph{Objectif.}
On souhaite utiliser des portions de mani\`ere dynamique i.e.\ pouvoir
disposer --- quand c'est possible --- d'un pointeur de type quelconque
sur une portion de l'espace m\'emoire obtenu par la manipulation
ci-dessus (sans possibilit\'e de recouvrement avec d'autres portions
point\'ees par d'autres pointeurs).

Pour ce faire, on se propose d'\'ecrire les fonctions de prototype~:
\begin{itemize}
\item \verb+void *alloc(unsigned int);+ cette fonction retourne un
  pointeur de type \verb+void+ sur un espace m\'emoire de taille
  pass\'ee en param\`etre \`a la fonction. Elle retourne \verb+NULL+
  s'il est impossible de disposer de la quantit\'e de m\'emoire
  demand\'ee~;
\item \verb+void free(void *);+ cette fonction lib\`ere l'espace
  m\'emoire associ\'e au pointeur pass\'e en param\`etre.
\end{itemize}
Aucune autre fonction ou partie du code n'a \`a acc\'eder au tableau
\verb+buffer+~: ce dernier n'est manipul\'e que par l'interm\'ediaire
des fonctions \verb+alloc+ et \verb+free+. Pour assurer ce point, les
objets globaux --- \verb+buffer+ par exemple --- sont de classe
d'allocation \verb+static+.

\section{Implantation \`a base de liste doublement cha\^\i{}n\'ee}
Nous allons utiliser une structure de donn\'ee auxiliaire permettant
de stocker l'ensemble des blocs d\'efinis dans l'espace m\'emoire
\verb+buffer+.
\par
Chaque bloc commence par une ent\^ete d\'efinie par une structure de
type \verb+freelist_t+ constitu\'ee par les champs~:
\begin{itemize}
\item \verb+isfree+ pour savoir si le bloc est libre ou pas~;
\item \verb+size+ pour la taille en octets de cette zone~;
\item \verb+next+ pour un pointeur sur l'ent\^ete du bloc suivante de
  la liste~;
\item \verb+previous+ pour un pointeur sur l'ent\^ete du bloc
  pr\'ec\'edent de la liste.
\end{itemize}
Ainsi, dans un bloc libre de taille totale~$n$ octets, ne sont
r\'eellement disponibles que~${n-\tau}$ octets avec~:
\begin{verbatim}
tau = 2*sizeof(unsigned int) + 2*sizeof(freelist_t *) ;
\end{verbatim}
\par
On suppose exister une variable globale \verb+freelist_t *Head+ qui
permet de pointer sur la premi\`ere ent\^ete. De plus, une ent\^ete
dont le champs \verb+next+ (resp.\ \verb+previous+) pointe sur
\verb+NULL+ est la derni\`ere (resp.\ premi\`ere) de la liste.  La
liste des blocs est vide si \verb+Head+ pointe sur \verb+NULL+.


\section{Mise en place du m\'ecanisme d'allocation}
Pour continuer, il nous faut donner la d\'eclaration de la structure
de l'ent\^ete en d\'efinissant le type \verb+freelist_t+
correspondant.

\paragraph{Initialisation.}
Ceci fait, 
 donnez la d\'efinition d'une fonction de prototype~:
\begin{verbatim}
static void AllocatorInit(void) ;
\end{verbatim}
  qui initialise l'espace m\'emoire que l'on va allouer.  En fait,
  cette fonction place une ent\^ete du bloc de m\'emoire disponible au
  d\'ebut une structure de type \texttt{freelist\_t} et l'initialise
  de mani\`ere a ce que ce bloc soit consid\'er\'e comme libre.
%\item Que fait la fonction d\'efinie ci-dessous~:
%\begin{verbatim}
%static void AllocatorInit(void){
%  freelist_t *ptr = (freelist_t *) buffer ;
%  ptr->isfree = TRUE ;
%  ptr->size = BUFFERSIZE ;
%  ptr->next = NULL ;
%  ptr->previous = NULL ;
%  Head = ptr ;
%  return ;
%}
%\end{verbatim}
%\item Donnez la d\'efinition de la fonction de prototype~: %
%\verb+void Retirer(BlocHeader_t *);+ qui prend en argument
%une ent\^ete de bloc libre et retire ce dernier  de
%la liste des blocs libres.
%\item Donnez la d\'efinition de la fonction de prototype~: %
%  \verb+void Inserer(BlocHeader_t *);+ qui prend en argument une
%  ent\^ete de bloc libre et ins\`ere ce dernier de la liste des blocs
%  libres en respectant le fait que la liste des blocs libres est
%  tri\'ee par adresses d'ent\^etes croissantes.


\section{Allocation}
 Donnez la d\'efinition de la fonction de prototype %
  \verb+void *alloc(unsigned int taille)+ qui prend en entr\'ee la
  taille de l'espace m\'emoire d\'esir\'e par l'utilisateur et qui
  retourne un pointeur sur le d\'ebut de l'espace m\'emoire disponible
  (juste apr\`es l'ent\^ete) du bloc correspondant.
  \par
  L'algorithme utilis\'e pour ce faire est le suivant~:
  \begin{enumerate}
  \item Pointer le premier bloc libre de taille suffisante ---
    sup\'erieure \`a~${\tau+\mathrm{taille}}$ --- dans la liste des
    blocs. Ce bloc est le bloc courant. Retourner NULL si ce n'est pas
    possible~;
  \item Si l'espace libre du bloc courant est inf\'erieur
    \`a~${2\tau+\mathrm{taille}}$, aller \`a l'\'etape~(d)~;
  \item Sinon, le bloc courant doit \^etre scind\'e en deux blocs~: le
    premier est le nouveau bloc courant et sert \`a satisfaire la
    requ\^ete~; le second est ajout\'e \`a la liste des blocs juste
    derri\`ere le bloc courant.  Poursuivre par l'\'etape suivante~;
  \item Retourner un pointeur sur l'espace libre positionn\'e juste
    apr\`es l'ent\^ete du bloc courant.
  \end{enumerate}

\section{D\'esallocation}
 Donnez la d\'efinition de la fonction de prototype %
  \verb+void free(void *ptr)+ qui prend en entr\'ee un pointeur et
  lib\`ere le bloc correspondant. Si ce bloc peut \^etre fusionn\'e
  avec ses voisins, cette op\'eration est effectu\'ee.

\section{Critique de la m\'ethode employ\'ee}
La m\'ethode d'allocation dynamique utilis\'ee ci-dessus est
rudimentaire. Pour s'en convaincre consid\'erez les points suivants~:
\begin{itemize}
\item Comment s'assurer que le pointeur \verb+ptr+ pointe bien apr\`es
  une ent\^ete~?
\item Que risque-t-il de se passer si un bloc de~$n$ octets de
  m\'emoire est allou\'e et que l'on manipule ce bloc sans
  pr\'ecaution comme dans l'allocation de~D suivante~:
\begin{verbatim}
   unsigned int i, n = 48 ; 
   char *D = (char *) SiamoisAlloc(n) ;
   for(i=0;i<65000;i++)
   *(D+i) = 1 ;
\end{verbatim}
  \end{itemize}


\end{document}

