\section{Manipulation de cha{\^\i}nes de caract\`eres}
\label{sec:ManipulationChaineDeCaracteres}
\begin{exercice}[Conversion d'une cha\^\i{}ne de caract\`eres en entier]
  \'Ecrire  la fonction     \texttt{int   convertion(char *txt)}   qui
  convertie la cha\^\i{}ne \texttt{txt}  en un entier (dans un premier
  temps, on peut supposer  que cette cha\^\i{}ne repr\'esente bien  un
  entier)~: la cha\^\i{}ne \verb+"100"+ doit \^etre convertie en l'entier \verb+100+. 
  \ifcorrection
  \begin{correction}
    \input{Verbatim/string2int.c.verb}
  \end{correction}
  \fi
\end{exercice}

\begin{exercice}[Conversion d'un entier en cha\^\i{}ne de caract\`eres]
  \'Ecrire la  fonction \texttt{char *convertion(int i)} qui convertie
  l'entier~\texttt{i} en une cha\^\i{}ne entier)~: l'entier \verb+100+
  doit \^etre convertie en la cha\^\i{}ne \verb+"100"+.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/int2string.c.verb}
  \end{correction}
  \fi%
  Attention.   Cet  exercice   n\'ecessite  la  compr\'ehension de  la
  primitive \texttt{malloc}.
\end{exercice}

\begin{exercice}[Inclusion de cha\^\i{}ne de caract\`eres]
  \'Ecrire  la   fonction \texttt{int    incluse(char ch1[MAX],   char
    ch2[MAX])}    qui  v\'erifie   si   la   cha\^\i{}ne  \texttt{ch1}
  appara\^\i{}t dans  la cha\^\i{}ne de  caract\`eres \texttt{ch2} (on
  renvoie~$1$ si oui et~$0$ sinon).
  \par
  Exemple  :  la  cha\^\i{}ne  \texttt{"lu"}   est   incluse dans   la
  cha\^\i{}ne \texttt{"Salut"}, \texttt{``au''} n'est pas incluse dans
  cette  cha{\^\i}ne    et \texttt{"bon"} n'est  pas    contenue  dans
  \texttt{"Bonjour"}.
\end{exercice}

\begin{exercice}[Reconnaissance d'un pangramme]
  Un pangramme  est une  phrase  qui contient  toutes les  lettres  de
  l'alphabet. Le pangramme suivant comporte~$42$ lettres~: 
\begin{verbatim}
Portez ce vieux whisky au petit juge blond qui fume
\end{verbatim}
  \par
  \'Ecrivez une fonction \texttt{pangramme} qui prend en entr\'ee une
  cha{\^\i}ne  de caract\`eres  et   v\'erifie si une  phrase  est  un
  pangramme~: elle retourne~$1$ si  c'est le cas  et~$0$ sinon.  Notez
  que  seules l'espace et  les lettres de l'alphabet (minuscules ou/et
  majuscules) peuvent composer un pangramme.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/pangramme.c.verb}
  \end{correction}
  \fi
\end{exercice}
%------------------------------------------------------------------------------
\section{Pointeurs et passage de param\`etres par adresse}
\label{sec:PointeursEtPassageDArguments}
Le passage d'arguments en~C se fait par valeur.  Afin de modifier la
valeur de \textit{sortie} d'un argument, on peut utiliser un pointeur.
\begin{exercice}[\'Echange de variable par une proc\'edure]
  On consid\`ere le code suivant~:
\begin{verbatim}
void permuter ( ... ){
   ....
}

int main(void){
  int a = 3;
  int b = 4;

  permuter( ... ) ;
  return 1 ;
}
\end{verbatim}
  Compl\'etez la fonction \texttt{echanger} qui permet de permuter le
  contenu des variables~\texttt{a} et~\texttt{b}.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/permutation.c.verb}
  \end{correction}
  \fi
\end{exercice}

\begin{exercice}[Passage de tableau en param\`etre]
  Expliquez le comportement du code suivant~:
  \input{Verbatim/passageParametreTableau.c.verb}
\end{exercice}
%------------------------------------------------------------------------------
\subsection{Allocation dynamique}
\label{sec:AllocationDynamique}
\begin{exercice}[Copie d'une cha\^\i{}ne de caract\`ere]
  Programmez la fonction de prototype~:
\begin{verbatim}
   char * strcopie(char *) ;
\end{verbatim}
  qui prend en param\`etre une cha\^\i{}ne de caract\`ere et retourne
  un pointeur sur une copie de cette cha\^\i{}ne.
\end{exercice}
%------------------------------------------------------------------------------
\subsection{Les param\`etres de la fonction main}
\label{sec:ParametresFonctionsMain}

\begin{exercice}
  Construisez un ex\'ecutable qui prend en argument sur la ligne de
  commande un entier~$n$ et qui affiche~$n$ fois le contenu de la
  variable d'environnements~USER si cette derni\`ere est d\'efinie.
\end{exercice}

%------------------------------------------------------------------------------
\subsection{Implantation d'une pile par un tableau}
\label{sec:TableauEtPile}\index{Pile}
La notion de   \textit{pile} intervient couramment  en  programmation. 
Par exemple, on l'utilise pour implanter les passages d'arguments lors
d'appels de proc\'edures.
\par
Sch\'ematiquement, une pile est  une structure de donn\'ees lin\'eaire
pour laquelle les insertions et les suppressions d'\'el\'ements se font
toutes \textit{du  m\^eme    cot\'e}.     On  parle    de    structure
LIFO~: Last In First Out.
\par
Plus formellement, on peut consid\'erer un ensemble d'\'el\'ements~$E$
et  noter~$\mathrm{Pil}(E)$ l'ensemble de  toutes  les piles sur~$E$.  
Par  exemple, les entiers peuvent  constituer l'ensemble~$E$~; la pile
vide~$P_{0}$    est dans~$\mathrm{Pil}(E)$.  Les op\'erations usuelles
sur une pile sont~:
\begin{itemize}
\item $\mathrm{estVide}$   est   une application  de~$\mathrm{Pil}(E)$
  dans~${(\mathrm{vrai},\mathrm{faux})}$,~${\mathrm{estVide}(P)}$  est
  vrai si, et seulement si,~$P$ est la pile~$P_{0}$.
\item       $\mathrm{ajouter}$         est         une     application
  de~${E\times\mathrm{Pil}(E))}$ dans~${\mathrm{Pil}(E)}$.
\item          $\mathrm{extraire}$          est  une       application
  de~${\mathrm{Pil}(E)\setminus P_{0}}$ dans~$\mathrm{Pil(E)}$.
\item       $\mathrm{supprimer}$        est    une         application
  de~${\mathrm{Pil}(E)\setminus P_{0}}$ dans~$\mathrm{Pil(E)}$.
\end{itemize}
Si~$x$ est un  \'el\'ement de~$E$, les  relations satisfaites par une
pile~$P$ et ces op\'erations sont~:
\begin{enumerate}
\item ${\mathrm{estVide}(P_{0})=\mathrm{vrai}}$
\item ${\mathrm{supprimer}(\mathrm{ajouter}(x,P))=P}$
\item ${\mathrm{estVide}(\mathrm{ajouter}(x,P))=\mathrm{faux}}$
\item ${\mathrm{extraire}(\mathrm{ajouter}(x,P))=x}$
\end{enumerate}
Cette derni\`ere r\`egle caract\'erise les piles.
\par
G\'en\'eralement,  on implante une pile  par un couple constitu\'e par
un tableau  contenant  les \'el\'ements  de la  pile et un  entier qui
repr\'esente la hauteur i.e.\ le nombre d'\'el\'ements de la pile. 
\begin{verbatim}
#define Max 30 
typedef struct Pile{

   int hauteur ;
   char tab[Max] ;

} Pile ;
\end{verbatim}
Notons que la hauteur est ainsi le premier indice disponible.
\subsection{Conversion d'une expression infixe en postfixe}
\label{sec:InfixeToPostfixe}
Afin  d'illustrer l'utilisation d'une pile,  on  se propose l'exercice
suivant.
\begin{exercice}[Convertion d'une expression infixe en postfixe]
  On suppose fournie une cha\^\i{}ne de caract\`eres prise en entr\'ee
  dans le  shell. Cette cha\^\i{}ne  est une formule infixe compos\'ee
  des op\'erateurs {+,*} o\`u les op\'erandes sont des chiffres de~$0$
  \`a~$9$.  On s'impose  l'utilisation du  parenth\'esage pour pouvoir
  traiter  + et  *  de la  m\^eme  fa\c{c}on.   Les parenth\`eses sont
  repr\'esent\'ees par des crochets []. On se  propose de convertir de
  la cha\^\i{}ne infixe en une forme postfixe (passer de {\tt 4*[3+5]}
  \`a {\tt 4,3,5,+,*}).
  \par
  Pour ce faire, on va utiliser trois piles~:
  \begin{itemize}
  \item une pile SRC qui contiendra la cha\^\i{}ne prise en entr\'ee~;
  \item une pile TMP temporaire n\'ecessaire aux op\'erations~;
  \item une pile RES qui contiendra le r\'esultat.
  \end{itemize}
  Pour implanter  notre    premi\`ere \'etape,   on  va  s'aider  d'un
  automate.  Il   s'agit  d'une  repr\'esentation   d'un    algorithme
  compos\'ee     d'\'etats     et    de    transitions.     Dans    la
  figure~\ref{fig:AlgoInfixe2Postfixe}, les transitions  correspondent
  aux fl\`eches du diagramme et les \'etats aux encadr\'es.
  \begin{figure}[htbp]      % Automate infixe vers postfixe
    \begin{center}
                                %BEGIN IMAGE
      \count0=75                   % \count0 le quart de la fen\^etre
      \count1=\count0
      \multiply\count1 by 4        % \count1 la hauteur de la fen\^etre
      \count2=\count0
      \multiply\count2 by 2        % \count2 la moitie de la fenetre
      \count3=\count0
      \multiply\count3 by 3        % \count3 les trois quarts de la fen\^etre
      \count4=20                   % hauteur estimee d'une ligne
      \count5=\count4
      \multiply\count5 by 2 % largeur de reference des cases
      \advance\count1 by \count4
      \count14=\count3
      \advance\count14 by -\count5
      \count15=\count2
      \advance\count15 by -\count5
      \count16=\count0
      \advance\count16 by -\count5
      \begin{picture}(\count1,\count3)
                                % le corps de l'automate
        \count6=\count5
        \multiply\count6 by 4
        \put(\count2,\count14){\oval(\count6,\count4){\makebox(0,0)
            {R\'ecup\'eration d'un caract\`ere}}}
        \count9=\count4
        \multiply\count9 by 3
        \put(0,\count15){\oval(\count9,\count4){\makebox(0,0){Empiler TMP}}}
        \put(\count0,\count15){\oval(\count9,\count4)
          {\makebox(0,0){D\'epiler TMP}}}
        \count8=\count5
        \multiply\count8 by 3
        \put(\count3,\count15){\oval(\count8,\count4)
          {\makebox(0,0){\shortstack{D\'epiler TMP vers RES}}}}
        \put(\count2,\count16){\oval(\count6,\count4)
          {\makebox(0,0){Analyse et d\'ecision}}}
        \count7=\count5
        \multiply\count7 by 2
        
        \put(0,\count16){\oval(\count7,\count4){\makebox(0,0){5~: Erreur}}}
        \put(\count1,\count16){\oval(\count5,\count4){\makebox(0,0){4~: Fin}}}
        
                                % les fleches
                                % du debut vers r\'ecup\'eration
        \advance\count5 by \count4
        \put(0,\count14){\vector(1,0){\count5}}
        
                                % de recuperation vers la decision
        \count10=\count14
        \advance\count10 by -\count4
        \count11=\count0
        \multiply\count11 by 2
        \advance\count11 by -\count4
        \advance\count11 by -\count4    
        \put(\count2,\count10){\vector(0,-1){\count11}} 
                                % de la decision vers Empiler vers res
        \count10=\count16
        \advance\count10 by \count4
        \count12=\count2
        \advance\count12 by \count4
        \count11=\count4
        \multiply\count11 by 3
        \put(\count12,\count10){\vector(3,2){\count11}}
        
                                % de depiler vers recuperation
        \count12=\count15
        \advance\count12 by \count4 
        \put(\count0,\count12){\vector(3,2){\count11}}
    
                                % de la decision vers Depiler
        \count12=\count2
        \advance\count12 by -\count4 
        \put(\count12,\count10){\vector(-3,2){\count11}}
    
                                % de depiler vers res vers recuperation
        \put(\count3,\count12){\vector(-3,2){\count11}}
                                % de empiler vers recuperation
        \advance\count11 by \count4
        \put(0,\count12){\vector(2,1){\count11}}

                                % de la decision vers Empiler
        \count12=\count15
        \advance\count12 by -\count4 
        \put(\count12,\count10){\vector(-2,1){\count11}}
        
                                % de la decision vers la fin
        \count12=\count4
        \advance\count12 by \count3
        \count11=\count4
        \multiply\count11 by 2
        \put(\count12,\count16){\vector(1,0){\count11}}
        
                                % de la decision vers l'erreur
        \count12=\count2
        \advance\count12 by -\count7
        \advance\count12 by -5
        \put(\count12,\count16){\vector(-1,0){\count4}}
        
      \end{picture}
                                %END IMAGE
                                %HEVEA \imageflush
      \caption{Automate repr\'esentant un algorithme de convertion %
        de l'infixe vers le postfixe}%
      \label{fig:AlgoInfixe2Postfixe}
    \end{center}
  \end{figure}
  Dans notre cas, on s'impose les \'etats suivants~:
  \begin{enumerate}
  \item D\'epiler de SRC dans TMP~;
  \item D\'epiler de TMP dans RES~;
  \item D\'epiler SRC et d\'epiler TMP~;
  \item Erreur~;
  \item Fin~;
  \item D\'epiler de SRC dans RES.
  \end{enumerate}
  Quand un caract\`ere   est d\'epil\'e de SRC,  il  est empil\'e soit
  dans TMP soit dans RES.  Un chiffre  est toujours empil\'e dans RES. 
  Par contre, si le caract\`ere est un symbole (-,+,/,*, etc.), l'action a
  effectu\'ee d\'epend de ce que  contient la pile.  Consid\'erons  le
  cas o\`u la cha\^\i{}ne de  d\'epart est~${1+1+1}$~; les  tableaux
  suivants~(1)  repr\'esente \`a  chaque   \'etape la   pile  SRC,~(2)
  repr\'esente la pile TMP et~(3) la la pile RES~:
\par\medskip
\begin{tabular}{ccccc}
  \begin{tabular}{ccc}
     1 &     &      \\
     + &     &      \\
     1 &     &      \\
     + &     &      \\
     1 &     &      \\
    (1) & (2) & (3) 
  \end{tabular} & 
  \begin{tabular}{ccc}
       &     &      \\
     + &     &      \\
     1 &     &      \\
     + &     &      \\
     1 &     &  1   \\
    (1) & (2) & (3) 
  \end{tabular} &
  \begin{tabular}{ccc}
       &     &      \\
       &     &      \\
     1 &     &      \\
     + &     &      \\
     1 &  +   &  1   \\
    (1) & (2) & (3) 
  \end{tabular} &
  \begin{tabular}{ccc}
       &     &      \\
       &     &      \\
       &     &      \\
     + &     &    1  \\
     1 &  +   &  1   \\
    (1) & (2) & (3) 
  \end{tabular} & 
\end{tabular}
\par
\begin{tabular}{ccccccc}
  \begin{tabular}{ccc}
       &     &      \\
       &     &      \\
       &     &    +  \\
       &     &    1  \\
     1 &  +   &  1   \\
    (1) & (2) & (3) 
  \end{tabular}  &
  \begin{tabular}{ccc}
       &     &      \\
       &     &    1 \\
       &     &    +  \\
       &     &    1  \\
       &  +   &  1   \\
    (1) & (2) & (3) 
  \end{tabular} &
  \begin{tabular}{ccc}
        &     &      \\
        &     &    +  \\
        &     &    1 \\
        &     &    +  \\
        &     &    1  \\
        & ,  &  1   \\
    (1) & (2) & (3) 
  \end{tabular} &  &&& 
  \begin{tabular}{cc}
    ( & 40 \\
    ) & 41 \\
    $\star$ & 42 
  \end{tabular}
  \begin{tabular}{cc}
    + & 43  \\
    , & 44 \\
    0 & 48 \\
    9 & 57 
  \end{tabular}
\end{tabular}
\par\bigskip
Le tableau suivant indique les  transitions effectu\'ees \`a partir de
l'\'etat  {\tt    analyse  et  d\'ecision}.   Il  est  malheureusement
incomplet~; n'y  figure  que les  transitions d\'eduites  des tableaux
pr\'ec\'edents.
\begin{figure}[htbp]
  \begin{center}
    \begin{tabular}{cc}
    sommet de TMP &    \begin{tabular}{ccccccccc}
      & \multicolumn{8}{c}{sommet de SRC}\\
                      & - & + & * & / & [ & ] & vide \\
              -       &   &   &   &   &   &   &      \\
              +       &   &   &   &   &   &   &      \\
              $\star$ &   &   &   &   &   &   &      \\
              /       &   &   &   &   &   &   &      \\
              \verb+[+       &   &   &   &   &   &   &      \\
              \verb+]+       &   &   &   &   &   &   &      \\
              vide    &   &   &   &   &   &   &
    \end{tabular}% \\
%    Sommet De Tmp &    \Begin{Tabular}{Ccccccccc}
%      & \Multicolumn{8}{C}{Sommet De Src}\\

%                      & - & + & * & / & [ & ] & Vide \\
%              -       &   &   &   &   & 1 &   &      \\
%              +       &   &   &   &   & 1 &   &      \\
%              $\Star$ &   &   &   &   & 1 &   &      \\
%              /       &   &   &   &   & 1 &   &      \\
%              [       &   &   &   &   & 1 &   &      \\
%              ]       &   &   &   &   & 1 &   &      \\
%              Vide    &   &   &   &   & 1 &   & 4
%    \End{Tabular}
    \end{tabular}
    \caption{Table de d\'ecisions utilis\'ees dans l'\'etat {\tt analyse et d\'ecision}}
    \label{fig:TableDeDecision}
  \end{center}
\end{figure}
\par
\textbf{Questions.}
\begin{itemize}
\item Compl\'etez le tableaux de d\'ecisions~;
\item Implantez  le programme de convertion.  On impose que  les piles
  soient des variables locales de la fonction \texttt{main}.
\item   On se propose maintenant  de  r\'ealiser une calculette.  Il  s'agit
  d'un programme qui prend en entr\'ee une cha\^\i{}ne de caract\`eres
  du type~${4*[3+5]}$ et qui retourne {\tt 32}.
\end{itemize}
\ifcorrection
\begin{correction}
  \input{Verbatim/infixe2postfixe.c.verb}
\end{correction}
\fi
\end{exercice}
%------------------------------------------------------------------------------
\section{Parcours de graphes \`a l'aide d'une pile}
\label{sec:ParcoursGraphes}
\subsection{Parcours de labyrinthe}
\label{sec:ParcoursDeLabyrinthe}
On se propose dans cette  section de parcourir  un labyrinthe que l'on
aura pr\'ealablement  repr\'esent\'e par  un tableau.  L'algorithme de
parcours repose sur l'utilisation d'une pile.
\subsubsection{Construction et affichage de labyrinthe}
\label{sec:ConstructionEtAffichageDeLabyrinthe}
Les  labyrinthes  que   nous  allons utiliser  sont   des  labyrinthes
rectangulaires,    compos\'es      de    cases   franchissables     ou
infranchissables. Les  cases du bord  seront toujours infranchissables
sauf en  haut \`a gauche (case de  coordonn\'ees~${(0,1)}$)  et en bas
\`a droite~: ce seront  les cases de d\'epart  et d'arriv\'ee de notre
labyrinthe.
\begin{exercice}[Affichage de labyrinthe]
  \'Ecrivez une fonction qui dessine le labyrinthe en mode texte.
  Pour ce faire, on d\'efinit quelques macros.
\begin{verbatim}
#define FERME  0
#define OUVERT 1
\end{verbatim}
  Vous pouvez tester cette fonction \`a l'aide de l'exemple suivant~:
  \input{Verbatim/LabyrintheExemple.h.verb}
  L'affichage devra correspondre \`a~:
\begin{verbatim}
XXXXX
    X
X X X
X X X
X X  
XXXXX
\end{verbatim}
  \ifcorrection
  \begin{correction}
    \input{Verbatim/LabyrintheAffichage.c.verb}
  \end{correction}
  \fi
\end{exercice}
Dans la suite, on convient que la longueur sera de~$70$ colonnes et la
largeur  de~$30$ colonnes. De  plus, ce labyrinthe sera repr\'esent\'e
par une variable globale.
\begin{exercice}[Cr\'eation du labyrinthe]
  \'Ecrivez une fonction qui prend en entr\'ee la probabilit\'e qu'une
  case soit franchissable  et affecte al\'eatoirement notre labyrinthe
  de   taille  longueur$\times$largeur.  On  rappelle que  la fonction
  \texttt{rand} permet d'obtenir un entier al\'eatoire.
  \par
  Cette fonction  devra  proposer des   labyrinthes \`a  l'utilisateur
  jusqu'\`a ce que celui-ci accepte l'un d'entre eux (n'oubliez pas de
  changer la graine de votre g\'en\'erateur d'entiers al\'eatoires avec la
  fonction \texttt{srand()}).
  \par
  Remarquez que cette derni\`ere fonctionnalit\'e permet de choisir un
  labyrinthe qui ne soit pas trivial \`a r\'esoudre.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/LabyrintheConstruire.c.verb}
  \end{correction}
  \fi
\end{exercice}
%------------------------------------------------------------------------------
\subsubsection{Une pile de pas}
\label{sec:PilePas}\index{Pile}
Pour parcourir le labyrinthe, nous allons utiliser une pile de pas. Un
pas  correspond  \`a~$4$   coordonn\'ees~: les  deux coordonn\'ees~$x$
et~$y$ du point de d\'epart du pas et  les coordonn\'ees~$z$ et~$t$ de
son point d'arriv\'ee.   La pile contiendra  les pas  \'el\'ementaires
entre  deux cases  contig\"ues  \`a  explorer~;  les coordonn\'ees  de
d\'epart nous permettrons d'afficher ais\'ement les pas.
\begin{exercice}[Structure de la pile]
  Implantez une pile globale \`a l'aide  d'un tableau et \'ecrivez les
  fonctions classiques de manipulations  de pile  (empiler, d\'epiler,
  etc.).
  \ifcorrection
  \begin{correction}
    \input{Verbatim/LabyrinthePile.c.verb}
  \end{correction}
  \fi
\end{exercice}
%------------------------------------------------------------------------------
\subsubsection{Algorithme de parcours de labyrinthe}
\label{sec:AlgorithmeDeParcoursDeLabyrinthe}
Pour  parcourir  notre labyrinthe, nous   allons utiliser une variable
globale   repr\'esentant  notre pile et qui    contiendra  les pas \`a
explorer.   Au d\'ebut du parcours, elle  ne  contient que le seul pas
allant de~${(0,1)}$ \`a~${(1,1)}$.
\par
Tant que notre pile n'est pas  vide, on retire le  pas de t\^ete. S'il
est possible, on  r\'eaffiche le labyrinthe en  prenant soin de  marquer
d'un signe les cases  d\'ej\`a visit\'ees pour  ne pas boucler.  Puis on
ajoute \`a la pile   tous les pas   possibles (pour lesquels  la  case
d'arriv\'ee est franchissable) \`a partir  du point d'arriv\'ee du pas
consid\'er\'e. Par convention, on ne se d\'eplace pas en diagonale.
\par
Il suffit d'it\'erer ce qui pr\'ec\`ede pour sortir du labyrinthe.
\begin{exercice}[Implantation de l'algorithme de parcours]
  Implantez une fonction \texttt{parcourir} qui parcourt le labyrinthe
  selon  la m\'ethode  d\'ecrite  plus   haut.  Attention, tous    les
  labyrinthes n'ont pas forc\'ement une sortie~!
  \ifcorrection
  \begin{correction}
    \input{Verbatim/Labyrinthe.c.verb}
  \end{correction}
  \fi
\end{exercice}
\paragraph{Remarque.}
Notez que le parcours  ainsi  obtenu n'est en  rien optimal.   Pour ce
faire,     il  nous faudrait   utiliser non   pas  une   pile  mais une
\textit{file}.  L'\'etude de cette  structure de  donn\'ee n\'ecessite
l'introduction de \textit{structure auto-r\'ef\'erenc\'ee} et d\'epasse
le cadre de cette section (cf.~\ref{cha:StructuresAutoreferencees}).
%------------------------------------------------------------------------------
\subsection{Jeu de la lettre qui saute}
\label{sec:JeuDeLaLettreQuiSaute}
Le but du jeu est de passer d'un mot à un  autre par une suite de mots
tels qu'un   mot et  le suivant   ne diff\`erent que  d'une lettre.  Par
exemple, on peut passer de \texttt{lion}  à \texttt{peur} par la suite
de mots :
\begin{verbatim}
lion -> pion -> paon -> pain -> paix -> poix -> poux -> pour -> peur
\end{verbatim}
Le jeu consiste \`a se donner deux mots et  \`a voir s'il est possible
de passer de l'un \`a l'autre en respectant les r\`egles.
\par
Nous allons  mod\'eliser ce  jeu par un  \textit{graphe}~: deux  mots sont
reli\'es s'il ne diff\'erent que d'une lettre. Une suite  de mot telle que
ci-dessus est donc  un chemin  dans le   graphe. L'ensemble des   mots
auxquels peut mener un mot constitue une composante connexe.
On peut visualiser ces d\'efinitions comme suit~:
%HEVEA \epsfbox{res2}
\par
On appellera \textit{successeurs} d'un mot les mots qui ne diff\'erent
que d'une   lettre  de  ce mot.    Par exemple, les   successeurs   de
\texttt{lion}  sont  \texttt{pion}     et \texttt{lien},    ceux    de
\texttt{lien}   sont  \texttt{rien}, \texttt{bien},     \texttt{sien},
\texttt{lieu},    \texttt{lier},  \texttt{lied},        \texttt{lion},
\texttt{tien} et \texttt{mien}.
\par
Pour jouer,   on se propose  d'utiliser le  dictionnaire des   mots de
quatres lettres que nous   avons d\'ej\`a utilis\'e pour  nous exercer
aux tris~:
\input{Verbatim/dico4lettres.h.verb}
\subsubsection{Repr\'esentation d'un graphe}
La  repr\'esentation la plus  directe d'un graphe  \`a~$n$ sommets est
celle par \textit{matrice  d'adjacence}~: on utilise un tableau~$M$ de
taille~${n\times n}$ o\`u~$M[i][j]$ est \'egal \`a~$1$ s'il existe une
ar\^ete entre le sommet~$i$ et le sommet~$j$, et \`a~$0$ sinon.
\par
Dans notre cas, les sommets correspondent \`a des mots. On d\'ecide de
repr\'esenter  chaque   mot  par  son  indice   dans   le dictionnaire
\texttt{dico}. Il est donc judicieux de trier ce dictionnaire afin de pouvoir
d\'eterminer par une recherche dichotomique l'indice associ\'e \`a un mot.
\begin{exercice}[Construction de la matrice d'adjacence]
  Construisez   une  fonction  qui   prenne  en  entr\'ee une  matrice
  d'adjacence.  Cette fonction devra construire la matrice d'adjacence
  associ\'ee  au dictionnaire d\'efini  globalement et la stocker dans
  la matrice d'adjacence pass\'ee en argument.
  \par 
  Pour ce  faire,  on  peut  construire  une  fonction  qui prend   en
  arguments deux cha\^\i{}nes de caract\`eres  et qui retourne~$1$  s'il
  s'agit de successeurs et~$0$ sinon.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/MatriceAdjacence.c.verb}
  \end{correction}
  \fi
\end{exercice}
\subsubsection{Parcours en profondeur de notre graphe}
Nous pouvons maintenant  aborder  le jeu  proprement dit.   Deux  mots
\'etant donn\'es, il nous faut parcourir  notre graphe \`a partir d'un
sommet (premier mot) jusqu'\`a ce que~:
\begin{itemize}
\item soit on rencontre le second mot (un sommet donn\'e)~;
\item  soit on termine  le parcours sans  faire  cette rencontre et on
  d\'emontre ainsi qu'il n'est  pas possible de  passer du premier mot
  au second en respectant les r\`egles.
\end{itemize}
Cette   d\'emarche nous  rappelle  celle  utilis\'ee lors  du parcours   de
labyrinthe. Nous pouvons donc utiliser le m\^eme type de solution.
\begin{exercice}[Parcours du graphe des mots]
  \`A l'aide d'une pile, implanter une fonction  qui prend en argument
  une matrice d'adjacence et deux cha\^\i{}nes de caract\`eres~; cette
  fonction  retourne~$1$ s'il  est  possible de passer  du premier  au
  second en respectant les r\`egles de notre jeu.
  \par
  Pour ce  faire, il   nous faut convertir   les mots  en les  indices
  associ\'es  qui  vont repr\'esenter les  sommets.  Cette op\'eration
  n\'ecessite une fonction de recherche dichotomique.
  \ifcorrection
  \begin{correction}
    \input{Verbatim/jeu.c.verb}
  \end{correction}
  \fi
\end{exercice}
\paragraph{Remarques~:}
dans cet exercice, nous n'avons  pas donn\'e le chemin existant  entre
deux mots. De   plus,  on pourrait demander    de fournir toutes   les
composantes connexes de ce graphe.
\par
Ce genre  d'\'etude est facilement   r\'ealisable du moment  que  l'on
dispose de \textit{listes  cha\^\i{}n\'es} ou  \textit{d'arbres}.  Ces
deux structures  de  donn\'ees n'ont pas  \'et\'e  abord\'ee jusqu'\`a
pr\'esent.
%------------------------------------------------------------------------------



