\section{Premier programme en~C}
\label{sec:PremiersPas}
Commen\c{c}ons  par un  grand  classique.  Ainsi, on  se propose  tout
d'abord  d'afficher  quelque chose  \`a  l'\'ecran.   Le  bout de code
suivant    va          r\'ealiser        cette     t\^ache.            
\input{Verbatim/helloword.c.verb}   
Dans cette exemple, on peut remarquer que les expressions en C se
terminent par un point-virgule et qu'un commentaire commence par /* et
se termine par */. Ainsi, on peut placer la ligne
suivante\index{Commentaire}
\begin{verbatim}
/*  Ceci est un commentaire */
\end{verbatim}
dans un programme~C sans affecter son comportement.
\par
Avant d'ex\'ecuter notre programme, pr\'ecisons quelques points de
th\'eorie.
\subsection{C est un langage compil\'e}
\label{sec:Compilation}
Cela signifie  qu'un  programme~C est d\'ecrit  par un  fichier  texte
appel\'e fichier \textit{source}.  Ce  fichier n'est pas  ex\'ecutable
par le microprocesseur, il faut le  traduire en langage machine. Cette
op\'eration      est    effectu\'ee  par     un   programme   appel\'e
\textit{compilateur}.   La compilation  se  d\'ecompose en~$4$  phases
successives~:
\begin{enumerate}
\item   \textbf{Le traitement   par  le pr\'eprocesseur~:}%
  le  fichier   source  est analys\'e     par   un programme  appel\'e
  \textit{pr\'eprocesseur} qui  effectue des transformations  purement
  textuelles (remplacement de  cha\^\i{}nes de caract\`eres, inclusion
  d'autres fichiers source, etc.)~;
\item \textbf{La compilation~:} au cours  de cette \'etape, le fichier
  engendr\'e  par     le     pr\'eprocesseur   est       traduit    en
  \textit{assembleur}, c'est \`a dire en  une suite d'instructions qui
  sont     chacunes     associ\'ees  \`a    une   fonctionnalit\'e  du
  microprocesseur (faire une addition, une comparaison, etc.)~;
\item \textbf{L'assemblage~:} cette  op\'eration  transforme  le  code
  assembleur  en un    fichier \textit{binaire},  c'est  \`a  dire  en
  instructions  directement  compr\'ehensibles  par  le processeur. Le
  fichier   produit    par   l'assemblage    est    appel\'e   fichier
  \textit{objet}~;
\item  \textbf{L'\'edition de    liens~:} un   programme  est  souvent
  s\'epar\'e en plusieurs fichiers  source (ceci permet d'utiliser des
  librairies de fonctions standard     d\'ej\`a \'ecrites comme    les
  fonctions   d'affichage   par exemple).    Une fois   le code source
  assembl\'e,  il faut donc   \textit{lier} entre eux les diff\'erents
  fichiers  objets.  L'\'edition  de liens  produit  alors un  fichier
  \textit{ex\'ecutable}.
\end{enumerate}
Comme rien  ne vaut la  pratique, nous   allons  effectuer les  t\^aches
d\'ecrites ci-dessus.
\subsection{Compilation par la pratique}
\label{sec:CompilationPratique}
\paragraph{\'Edition du fichier source}
Pour  \'editer le  fichier  source, nous  allons utiliser  le logiciel
\texttt{emacs}      que l'on  lance    depuis     le   shell par la    commande
\texttt{\$~emacs}.
\par
Pour \'editer un fichier source, utiliser la barre de menu d'emacs~:
\par
\centerline{File  -$>$  Open,}
\par 
puis indiquer un nom  de fichier avec la  lettre c pour extension  ---
\texttt{foo.c} par exemple.   Emacs vous pr\'esente un \textit{buffer}
dans lequel vous pouvez cr\'eer votre fichier  source (dans notre cas,
il   s'agit de   la proc\'edure permettant   l'affichage  d'un message
pr\'esent\'e en d\'ebut de section~\ref{sec:PremiersPas})
\paragraph{Compilation.}
Une fois que l'\'edition de  votre fichier source est termin\'ee, vous
pouvez le compiler.  Dans  notre  cas, nous utilisons le   compilateur
\texttt{gcc}.   On utilise dans le   shell la commande \texttt{\$  gcc
  foo.c} et  on    obtient    directement  le    fichier  ex\'ecutable
\texttt{a.out}.   Le  nom    du fichier   ex\'ecutable  peut    \^etre
sp\'ecifi\'e  en   utilisant   l'option \texttt{-o}    du  compilateur
(\texttt{gcc -o  nom\_de\_l\_executable  foo.c}).   De plus,  l'option
\texttt{-Wall} permet d'afficher tous les avertissements \'emis par le
compilateur. Les  options \texttt{-ansi -pedantic} permettent de faire
signaler tout ce qui s'\'ecarte de la norme dans votre programme.
\paragraph{Ex\'ecution.}
Enfin pour  finir, on peut ex\'ecuter \`a  partir  du shell le fichier
r\'esultant par la commande \texttt{\$ a.out}.
\paragraph{Exp\'erimentation}
On peut suivre les \'etapes de la compilation en utilisant les options
ad\'equates du gnu c compiler. Ainsi.
\begin{itemize}
\item Pour  constater   le  travail du   pr\'eprocesseur,  utilisez la
  commande \texttt{gcc  -E foo.c  >  res.txt} et  \'editez le  fichier
  \texttt{res.txt}.
\item Pour interrompre la   compilation avant l'assemblage,  il suffit
  d'utiliser  l'option   \texttt{-S}   du   compilateur.   Un  fichier
  \texttt{foo.s} est engendr\'e et  on  peut en lire l'assembleur   en
  l'\'editant.
\item  Pour obtenir, un fichier   objet --- \texttt{foo.o} dans  notre
  exemple  --- on peut utiliser  l'option  \texttt{-c} du compilateur. 
  L'utilitaire \texttt{objdump} permet de d\'ecoder  le fichier objet. 
  Ainsi, la  commande \texttt{objdump -S  foo.o} affiche la succession
  d'octets  hexad\'ecimals constituant le fichier  et leur traduction en
  langage assembleur.
\end{itemize}
Plus g\'en\'eralement, la commande  \texttt{man gcc} fournit le manuel
du compilateur gnu.
\par
\textbf{Remarque.}  En guise de conclusion, il   faut bien retenir que
seuls les fichiers source doivent \^etre archiv\'es.
%\subsection{D\'epot des travaux pratiques}
%\label{sec:FinDeSeance}
%Au cours des TP,  je vous pris  de  d\'eposer vos programmes  dans un
%r\'epertoire. Vous devrez pr\'esenter  ainsi votre travail  \`a chaque
%fin de s\'eance.  Pour ce faire, cr\'eer un r\'epertoire \`a votre nom
%dans  le   r\'epertoire~: 
%\par
%\centerline{home/sedoglav/GMI1/Depot/}
%\par
%Vous copierez  vos  fichiers source   dans ce  r\'epertoire au fur  et
%mesure de l'avanc\'e du TP.

\begin{exercice}[Valeur de retour]
  Consid\'erons le programme~: %
  \input{Verbatim/return.c.verb} %
  Ce programme est uniquement constitu\'e par la fonction principale
  \verb?main? qui ne prend aucun param\`etre et retourne l'entier~$5$.
  \par
  Compiler ce programme afin d'obtenir un fichier
  ex\'ecutable~\texttt{foo}. Vous pouvez lancer son ex\'ecution depuis
  le shell et r\'ecup\'erer sa valeur de retour par la commande
  interne \texttt{echo} en affichant la variable \texttt{?}.
\begin{verbatim}
% foo 
% echo $?
\end{verbatim}
  Que constatez vous~? Confirmez votre intuition en faisant varier la
  valeur de retour.
\end{exercice}

\begin{exercice}[\'Etapes de la compilation]
Nous allons utiliser le programme suivant~:
\begin{verbatim}
#include <stdio.h>
#define MAX 3
const int bar_constante = MAX ;
int foo_global = 1 ;

extern int bar ;

int main(void) {
  int foo_local = 2 ;
  printf("Salut le monde~: %d \n",bar + foo_global + foo_local) ; 
  return 0 ;
}
\end{verbatim}
La compilation se fait avec gcc dont l'aide est disponible en ligne.
Cette aide est structur\'ee en section~; les informations nous
int\'eressant dans cet exercice se trouvent dans la section
\texttt{OPTIONS}, sous-section \texttt{Options contr\^olant le type de
  sortie} apr\`es la description des options concernant les langages
compris par~gcc.
\paragraph{Questions.}
\begin{enumerate}
\item Combien de lignes non vide le pr\'eprocesseur a-t-il ajout\'e
  \`a votre code~? (Ne comptez pas, utilisez des outils shell dont wc).
\item Qu'est devenu la ligne \verb?#include <stdio.h>?~? Que sont
  devenus les commentaires~? Comment a \'et\'e trait\'ee la cha\^\i{}ne
  ce caract\`eres~MAX~?
\item Pour examiner un fichier objet, vous pouvez utiliser
  \texttt{objdump} ou \texttt{nm}. Dans la table des symboles, quels
  sont les r\'ef\'erences qui seront r\'esolues par l'\'editeur de
  liens~? En utilisant l'utilitaire \texttt{ldd}, d\'eterminer quels
  sont les fichiers objets utilis\'es par votre ex\'ecutable~? (Pour
  achever la compilation supprimer la variable externe \texttt{bar} de
  votre code).
\end{enumerate}
\end{exercice}
%------------------------------------------------------------------------------
\section{Introduction aux variables, aux types simples et aux instructions}
\label{sec:Variable}\index{Variable}
%------------------------------------------------------------------------------
\subsection{Identificateurs en~C}
\label{sec:Identificateurs}
\begin{exercice}[Identificateurs]
  Le programme suivant tente de d\'efinir des variables locales de
  type entier~: \input{Verbatim/identificateurs.c.verb}
  Malheureusement, certains identificateurs ne sont pas licites.
  Corriger ce programme en modifiant les identificateurs qui ne
  devraient pas \^etre utilis\'es (expliciter \`a chaque fois l'erreur
  commise).
\end{exercice}
\subsection{Variables et types des variables}
\label{sec:Variables}
Sch\'ematiquement,   une variable  correspond  \`a  un  emplacement en
m\'emoire contenant une   information.  Dans  le code source,    cette
information est manipul\'ee par l'entremise du nom de la variable.
\par\index{Type}
Le~C  est un langage    \textit{typ\'e}. Toute variable, constante  ou
fonction doit \^etre d'un type pr\'ecis. Le  type d'un objet d\'efinit
la   fa\c{c}on  dont  il  est   repr\'esent\'e  en  m\'emoire  et  les
manipulations qu'on peut faire avec lui.
\par
La   norme  ANSI sp\'ecifie  les types  et  les  op\'erations  sur les
variables suivants~:
\begin{itemize}
\item les sp\'ecificateurs de type 
  \begin{tabular}{llllll}
  \textbf{char} & \textbf{double} &  \textbf{enum} & \textbf{float} &
  \textbf{int} & \textbf{long} \\ \textbf{short} & \textbf{signed} &
  \textbf{struct} & \textbf{union} & \textbf{unsigned}& \textbf{void}
  \end{tabular} 
\item les qualificateurs de type 
  \quad \textbf{const}\qquad  \textbf{volatile} 
\item les op\'erateurs 
  \begin{tabular}{cccccccccc}
   (\ ) & [\ ] & -$>$ & ! & \~{} & ++ & $--$ & - & (type) & *() \\
   \&() &sizeof & , &  $*$ & / & \% & + & - & $>>$& $<<$\\
   $>$ & $<$ &$<$=&$>$=& == &  $<<$= & \& & \^{} & $|$ & \&\& \\
   $||$ & ?: & += & -= & *=  & /=&\%=& \^{}= & $|$= & $>>$=
  \end{tabular}
\end{itemize}
\par
Ainsi, on  d\'efinit un caract\`ere par  l'instruction~: \textbf{char}
\texttt{nom;}   et   on peut   lui   affecter  le  caract\`ere~A   par
l'instruction \texttt{nom='A';}. 
\par  
On   peut d\'efinir une variable  \texttt{foo}  stockant la cha\^\i{}ne de
caract\`eres \texttt{bar} par l'instruction \texttt{char *foo="bar";}.
\par
De m\^eme,   on  d\'efinit  un entier  et   un   flottant gr\^ace  aux
instructions                                          \textbf{int}
\texttt{nom}\textbf{=}\texttt{666}\textbf{;}                        et
\textbf{float} \texttt{nom}\textbf{=}\texttt{3.14}\textbf{;}.
\par
Le programme --- erron\'e ---  suivant devrait afficher le r\'esultat
de la multiplication de~$1500$ par~$6,55957$.
\begin{verbatim}
   #include "stdio.h"

   int main(void) {
          int  A ;
          int  B ;
          float  R   ;

          A = 1500    ;
          B = 6.55957 ;
          R = A*B     ;
         // pour l'affichage 
         printf("Le resultat de la multiplication est %f\n",R) ;

         return 1 ;
  }
\end{verbatim}
Ce  programme  compile mais  le  r\'esultat  est  erron\'e.  En effet,
l'affectation effectue une  conversion de type implicite~: quand c'est
possible l'expression de droite est convertie dans le type du terme de
gauche.
\begin{exercice}[Correction d'un programme]
  Corriger le programme.
  \paragraph{Indication~:} 
  pensez \`a afficher le contenu des variables. Comment expliquez vous
  la valeur de la variable~\texttt{r}.  
  \ifcorrection
  \begin{correction}
    \input{Verbatim/typageDeBase.c.verb}
  \end{correction}
  \fi
\end{exercice}
%Nous reviendrons plus en d\'etails  sur  le typage dans les  s\'eances
%suivantes~; mais pour   l'instant, nous allons  consid\'erer certaines
%commandes mises \`a notre disposition par le langage.
\paragraph{Remarque}
Il   n'est pas pertinent  d'inclure  dans  des programmes des  nombres
comme~$1500$ sans pr\'eciser leurs  significations et sans fournir  un
m\'ecanisme pour les modifier au besoin.
\par
En utilisant   la  commande  du  pr\'eprocesseur  \texttt{\#define}  en
d\'ebut      de fichier,   on  peut  d\'efinir      un  nom symbolique
(\texttt{\#define Somme 1500})    et   le r\'eutiliser par   la   suite
(\texttt{A   =   Somme}).   Le   pr\'eprocesseur  remplacera    le nom
\texttt{Somme} par \texttt{1500} chaque fois qu'il le rencontrera dans
le programme.
%------------------------------------------------------------------------------
\begin{exercice}[Typage implicite]
  Expliquer pourquoi le programme suivant~:
  \input{Verbatim/typageimplicite.c.verb}
  compile mais provoque une erreur d'ex\'ecution.
\end{exercice}
%------------------------------------------------------------------------------
\subsection{Le type char}
\label{sec:TypeChar}
En~C,  le type  \texttt{char} correspond aux  entiers sign\'es codables
sur~$1$ octet. Un bit \'etant r\'eserv\'e pour le signe, il s'agit des
entiers  compris      entre~${2^7-1(=127)}$    et~$-127$.  Le     type
\texttt{unsigned  char} d\'esigne  les  entiers non  sign\'es  codables
sur~$1$ octet (de~$0$ \`a~$255$).
\par
Puisque les variables  de types \texttt{char}  codent  des entiers, on
peut les convertir en ce type par la commande~:
\begin{verbatim}
char foo ='a' ;
int  bar = (int) foo ; /* (int) est un op\'erateur de convertion de type */
\end{verbatim}
\par
Par  le biais  d'une  table,  ces  entiers   sont associ\'es \`a   des
caract\`eres~; le standard  American   Standard Code  for  Information
Interchange est consultable dans le manuel (\texttt{man ascii}).
\par
La norme ISO~$8859$-$1$  compl\`ete   cette table  afin de  coder  les
lettres      accentu\'ees  utilis\'ees   en     Europe    de   l'ouest
(\texttt{man~iso\_8859\_1} pour plus de d\'etails).
\begin{exercice}[Les fonctions putchar et getchar]
  La fonction \verb?int putchar (int c);? prend en entr\'ee un entier
  repr\'esentant le code ascii d'en caract\`ere et affiche ce
  caract\`ere sur la sortie standard.
  \par
  La fonction \verb?int getchar (void);? r\'ecup\`ere un caract\`ere
  dans l'entr\'ee standard et le retourne.
  \par
  L'usage de ces fonctions n\'ecessite l'ajout de la directive
  \verb?#include <stdio.h>? \`a votre code.
  \par
  Construisez un programme qui permette \`a l'utilisateur de saisir
  une lettre minuscule au clavier et affiche la majuscule
  correspondante \`a l'\'ecran (ne vous occupez pas de la gestion
  d'erreur).
  \par
  M\^eme exercice mais la lettre est suppos\'ee \^etre stock\'ee dans
  un fichier et la majuscule doit \^etre stock\'ee dans un autre
  (utilisez les redirections du shell).
\end{exercice}
\begin{exercice}[S\'equence d'\'echappement]
  Les caract\`eres ASCII re\c{c}\`elent quelques suprises.
  D\'eternimez ce que provoque l'affichage des caract\`eres suivants~:
\begin{verbatim}'
'\n' '\t' '\b' '\r' '\"' '\\' '\0' '\a' '\?' '\'' '\v'
\end{verbatim}
\end{exercice}
\begin{exercice}[\'Etude du type char]
  En utilisant les  tables de codages des  caract\`eres et en  gardant
  \`a  l'esprit le codage d'un   entier  sur un  octet, pr\'evoyez  le
  r\'esultat du programme suivant~: \input{Verbatim/CharType.c.verb}
\end{exercice}

\begin{exercice}[Choix de typage]
  Traduisez les d\'eclarations suivantes en C, sachant que les
  variables sont destin\'ees \`a continir les ensembles de nombres
  indiqu\'es. Choisissez les types les plus \'economiques en terme
  d'espace m\'emoire, sans perdre en pr\'ecision.
\begin{verbatim}
entier COMPTEUR {0 ,..., 300}
entier X,Y {-120 ,..., 100}
entier MESURE {-10 ,..., 104}
r\'eel SURFACE1 {0.5 ,..., 150075}
r\'eel SURFACE2 {-12 ,..., 1500750.5}
entier N1 {0 ,..., 210}
entier N2 {-47 ,..., 47}
entier N3 {0 ,..., 326}
entier N4 {-1280 ,..., 1285}
bool\'een TROUVE {vrai, faux}
\end{verbatim}
\end{exercice}
\begin{exercice}[Les constantes]
  Quel(s) type(s) num\'erique(s) pouvez-vous utiliser pour les groupes
  de nombres suivants~?
\begin{verbatim}
  1  12   4  0   -125
  1  12  -4  0    250
  1  12   4  0    250
  1  12  -4  0.5  125
  -220    32000   0
  -3000005.000000001
  410    50000    2
  410    50000    -2
  3.14159265      1015
  2*107           10000001
  2*10-7          10000001
  -1.05*1050      0.0001
  305.122212  0   -12
  12332 23.4 345LU 34.5L -1.0
  0xeba  0123l '\n' 1.23ul -1.0e-1
  0xFE0  40000  40000u 70000u 1e1f
  '0'   ' \0'   0      'O'
  67e0  '\r'    01001   0.0l  0XEUL
\end{verbatim}
\end{exercice}
%------------------------------------------------------------------------------
\subsection{Expressions}
\label{sec:Expressions}
En~C, les expressions peuvent \^etre difficile \`a comprendre. Il est
donc vivement conseill\'e de ne pas abuser de la flexibilit\'e du
langage au d\'ebut de votre apprentissage.
\begin{exercice}[Affectation]
  Quel est le r\'esultat des instructions suivantes~:
  \input{Verbatim/affectation.c.verb}
\end{exercice}
\begin{exercice}[Suite d'expressions]
  \label{sec:SuiteExpression}
  L'op\'erateur virgule permet de d\'efinir une suite d'expressions~;
  ces derni\`eres sont \'evalu\'ees de la gauche vers la droite et la
  valeur de retour de la suite d'expressions est la derni\`ere
  expression \'evalu\'ee.

  Que retourne le programme suivant. Testez votre r\'eponse.
  \input{Verbatim/suiteexpressions.c.verb}
\end{exercice}
%------------------------------------------------------------------------------
%\section{Fonctions d'affichage et de saisie}
%\label{sec:AffichageEtSaisie}
%%------------------------------------------------------------------------------
%\subsection{Fonction \texttt{printf}}
%\label{sec:printf}\index{printf}
%Dans cette section, nous allons utiliser l'aide en ligne \texttt{man}.
%Ainsi, tapez l'instruction \texttt{man printf} dans votre shell.
%Vous devriez obtenir de l'aide sur une fonction avec en particulier le texte 
%suivant (peut \^etre en anglais)~:
%\begin{verbatim}
% printf  affiche  la  chaîne  de  caractères format, en interpr\'etant les
% directives `%' et les s\'equences d'\'echappement `\' de  la  même  manière
% que la fonction C printf(3).
%\end{verbatim}
%Ce n'est malheureusement pas la fonction qui nous int\'eresse. Mais, on nous indique par ce texte que l'aide se trouve dans la section~3 du manuel. Pour y acc\'eder, utilisez la commande \texttt{man -S 3 printf}.
%\begin{exercice}[Ordre de prise en compte des arguments]
%  Expliquez le comportement du programme suivant:
%  \input{Verbatim/printf.c.verb}
%  \paragraph{Indication~:} vous pouvez arr\^eter la compilation au niveau
%  de l'assemblage pour voir dans le code assembleur l'ordre d'empilement
%  des arguments de la fonction \texttt{printf} pour conna\^itre l'ordre
%  d'\'evaluation des arguments.
%\end{exercice}
%%------------------------------------------------------------------------------
%\subsection{Fonction \texttt{scanf}}
%\label{sec:scanf}\index{scanf}
%Nous donnerons   plus   de d\'etails  sur   ces  fonctions   dans   la
%section~\ref{sec:EcritureLectureFlot}.
%%------------------------------------------------------------------------------
%\section{Compl\'ement sur les types}
%\label{sec:TypageComplement}
%Puisque nous pouvons utiliser  la fonction printf pour exp\'erimenter,
%nous allons compl\'eter nos conna\^issances sur les types scalaires.


