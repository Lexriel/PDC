\documentclass{article}

\usepackage[utf8]{inputenc} 
\usepackage[french]{babel} 
\usepackage{portland} 
\usepackage{epsfig} 
\usepackage{url} 
\usepackage{hyperref} 
\usepackage{fancybox} 
\usepackage{pgf}

\pgfdeclareimage[height=12cm]{arbre}{arbre}
\pgfdeclareimage[width=\textwidth]{automate}{automate}

%\newtheorem{exemple}{Exemple} 
\newtheorem{definition}{Définition} 
%\newtheorem{remarque}{Remarque} 
%\newtheorem{question}{Question} 
%\newtheorem{notation}{Notation} 
%\newtheorem{remarques}{Remarques} 

\title{Grep : construire l'automate}

\begin{document}
\maketitle


\section{Construction d'un automate non déterministe à partir d'un arbre de syntaxe abstraite}

L'explication de la méthode se fera à l'aide d'un exemple. Soit l'expression rationnelle : 
$$(ab+c)^\star ab$$ correspondant à l'arbre de syntaxe de la figure \ref{as}.Le but de l'algorithme est de construire l'automate de la figure \ref{au}.
\begin{figure}[h]
\begin{center}
\pgfuseimage{arbre}
\caption{\label{as} Arbre syntaxique de l'expression rationnelle $(ab+c)^\star ab$}
\end{center}
\end{figure}


\begin{figure}[h]
\begin{center}
\pgfuseimage{automate}
\caption{\label{au} automate non déterministe construit à partir de l'expression rationnelle $(ab+c)^\star ab$}
\end{center}
\end{figure}

\begin{definition}
Etant donnée une expression rationnelle, on définit une position dans cette expression comme l'indice d'un des 
caractères alphabétiques la composant. 
Pour l'expression $(ab+c)^\star ab$, il y a cinq positions : 
\begin{itemize}
\item 1 : a
\item 2 : b
\item 3 : c
\item 4 : a
\item 5 : b
\end{itemize}
\end{definition}

Cet automate a les caractéristiques suivantes : 
\begin{itemize}
\item Un état initial $O$
\item Un état par caractère alphabétique de l'expression rationnelle.
\item Depuis l'état initial, on peut se rendre sur les états correspondant aux positions où peut commencer un mot vérifiant l'expression rationnelle (1,3 ou 4). 
\item Les états terminaux correspondent aux positions où cette expression peut se terminer. En l'occurence, l'expression considérée ne peut se terminer qu'après le 'b' final (position 5).
\end{itemize}

Informellement, l'automate pourrait se construire de la façon suivante : 

\begin{quote}
Lorsqu'on se trouve dans l'état $i$, quelle peut être la lettre suivante, et en quelle position m'amènera-t-elle ? 
\end{quote}

Par exemple, si on est dans l'état 2 (dans la lecture de l'expression rationnelle, on vient de lire le premier b) : 
\begin{itemize}
\item On peut lire un c (application de l'étoile, choix de c) et arriver en position 3.
\item On peut lire un a (application de l'étoile, choix de ab) et revenir en position 1. 
\item On peut lire un a (sortie de l'étoile, lecture du caractère suivant) et arriver en position 4. 
\end{itemize}
Chacune de ces options correspond à une transition dans l'automate, qui représente toutes les transitions possibles engendrées par ce raisonnement. 

Il faut maintenant automatiser le processus, et trouver un algorithme permettant de construire l'automate à partir
de l'expression rationnelle. 

Au vu de l'exemple, on peut dégager trois notions importantes : 
\begin{itemize}
\item Par quels caractères peut commencer un mot vérifiant une expression rationnelle donnée ? (ou dit autrement, par quelle position peut-on 'entrer' dans une expression rationnelle ?)
\item Par quels caractères (quelles positions) peut se terminer un mot vérifiant une expression rationnelle ? 
(par quelle position peut-on 'sortir' d'une expression rationnelle ? )
\item A partir d'une position donnée, quelles sont les positions accessibles ? 
\end{itemize}

Il existe une dernière notion à envisager, qui n'est pas visible sur l'exemple : 
\begin{quote}
A partir d'une position, peut-on reconnaître $\epsilon$, le mot vide ? 
\end{quote}

Ces quatre notions (indicateurs) seront nommées dans l'ordre : 
\begin{itemize}
\item $\mbox{first}(i)$ : ensemble des positions par lesquelles peut commencer une expression rationnelle. 
\item $\mbox{last}(i)$ : ensemble des positions où peut se terminer une expression rationnelle. 
\item $\mbox{follow}(i)$ : ensemble des positions accessibles depuis la position i.
\item $\mbox{nullable}(i)$ : vrai si $\epsilon$ est reconnu depuis cette position. 
\end{itemize}

\subsection{Calcul des indicateurs}
L'arbre de syntaxe découpe l'expression rationnelle en sous-expressions. Les quatre indicateurs peuvent donc  être définis en chaque n\oe ud de l'arbre, puisque chacun de ces n\oe uds est lui-même la racine d'une expression rationnelle. 

\subsection{Indicateurs pour les feuilles}
Les feuilles sont de trois types, et les valeurs des indicateurs pour chaque type de feuille se définissent facilement : 
\begin{itemize}
\item N\oe ud $\emptyset$ : $\mbox{nullable}=\mbox{false}$, $\mbox{first}=\mbox{last}=\mbox{follow}=\emptyset$
\item N\oe ud $\epsilon$ : $\mbox{nullable}=\mbox{true}$, $\mbox{first}=\mbox{last}=\mbox{follow}=\emptyset$
\item N\oe ud position $i$ : $\mbox{nullable}=\mbox{false}$, $\mbox{first}(i)=\mbox{last}(i)=\{i\}$ $\mbox{follow}(i)=\emptyset$
\end{itemize}


\subsection{Indicateurs pour les n\oe uds internes}
Il y a trois types de n\oe uds internes : concaténation, étoile, union. Pour chacun de ces types de n\oe ud, un peu de réflection permet de définir la façon d'en calculer les indicateurs, à partir des indicateurs de leur(s) descendant(s). 

\subsubsection{N\oe ud concatenation}
Un n\oe ud concaténation peut engendrer $\epsilon$ si à la fois son fils gauche (g)  et son fils droit (d) sont capables d'engendrer $\epsilon$ : 

$$\mbox{nullable}(g \bullet d)=\mbox{nullable}(g) \mbox{ et } \mbox{nullable}(d)$$



Pour un n\oe ud concaténation, les positions pouvant commencer un mot sont celles pouvant commencer son fils gauche, auxquelles il faut ajouter, seulement si son fils gauche peut engendrer $\epsilon$, les positions pouvant débuter un mot du fils droit : 


$$\mbox{first}(g\bullet d)=\left\{
\begin{array}{l}
\mbox{first}(g) \mbox{ si } \mbox{nullable}(g)= \mbox{false} \\
\mbox{first}(g)\cup \mbox{first}(d) \mbox{ si } \mbox{nullable}(g)=\mbox{true}\\
\end{array}
\right.
$$





Les positions susceptibles de terminer un mot d'un n\oe ud concaténation sont ceux qui peuvent terminer son fils droit, auxquelles on peut ajouter celles terminant son fils gauche, si le fils droit peut engendrer $\epsilon$

$$\mbox{last}(g\bullet d)=\mbox{last}(d) \mbox{ si } \mbox{nullable}(d)= \mbox{false}$$

$$\mbox{last}(g\bullet d)=\mbox{last}(g)\cup \mbox{last}(d) \mbox{ si } \mbox{nullable}(d)=\mbox{true}$$

$$\mbox{last}(g\bullet d)=\left\{
\begin{array}{l}
\mbox{last}(d) \mbox{ si } \mbox{nullable}(d)= \mbox{false}\\
\mbox{last}(g)\cup \mbox{last}(d) \mbox{ si } \mbox{nullable}(d)=\mbox{true}\\
\end{array}
\right.
$$

Soit $x$ une position dans $g\bullet d$. 
\begin{itemize}
\item Si $x$ est dans $d$, les positions qui peuvent lui succéder sont les mêmes que celles qui peuvent lui succeder dans $d$ : 

$$\mbox{follow}(g\bullet d,x)=\mbox{follow}(d,x)$$

\item Si $x$ est dans $g$, mais n'appartient pas à $\mbox{last}(g)$, les positions qui peuvent lui succéder sont les mêmes que celles qui peuvent lui succeder dans $g$ : 

$$\mbox{follow}(g\bullet d,x)=\mbox{follow}(g,x)$$

\item Si $x \in \mbox{last}(g)$, les positions suivant $x$ sont celles lui succédant dans $g$, auxquelles on ajoute toutes les positions pouvant commencer $d$ : 

$$\mbox{follow}(g\bullet d,x)=\mbox{follow}(g,x) \cup \mbox{first}(d)$$

\end{itemize}

\subsubsection{N\oe ud union}

Un n\oe ud union ($g+d$) permet d'engendrer $\epsilon$ si l'un de ses fils au moins peut le faire : 


$$\mbox{nullable}(g + d)=\mbox{nullable}(g) \mbox{or} \mbox{nullable}(d)$$


Les positions pouvant commencer un mot défini par un n\oe ud union sont celles permettant de commencer un mot de $g$, plus celles pouvant comencrer un mot de $d$ : 

$$\mbox{first}(g + d)=\mbox{first}(g) \cup \mbox{first}(d)$$ 

Même raisonnement pour les fins de mots  : 

$$\mbox{last}(g + d)=\mbox{last}(g) \cup \mbox{last}(d)$$ 

Si $x$ est une position de $g + d$, elle est soit une position de $g$, soit une position de $d$. On a donc simplement : 


$$\mbox{follow}(g +d,x)=\left\{
\begin{array}{ll}
\mbox{follow}(g,x)&  \mbox{ si }x \in g\\
\mbox{follow}(d,x)& \mbox{ si } x \in d\\
\end{array}
\right.$$

\subsubsection{N\oe ud étoile}

Une expression à l'étoile peut engendrer epsilon : 

$$\mbox{nullable}(\star)=\mbox{true}$$

Les positions pouvant commencer un mot correspondant à une expression à l'étoile sont exactement celles qui permettent de commencer un mod du langage de base. Idem pour les positions en fin d'expression : 

$$\mbox{first}(g^\star)=\mbox{first}(g)$$
$$\mbox{last}(g^\star)=\mbox{last}(g)$$

Si $x \not\in \mbox{last}(g)$, alosr les positions qui peuvent lui succéder sont celles qui pouvaient lui succéder dans $g$.
Sinon, il faut y ajouter les débuts possibles de mots de $g$, qui viendront se concaténer derrière $x$ : 

$$\mbox{follow}(g^\star,x)=\left\{
\begin{array}{ll}
\mbox{follow}(g,x)& \mbox{ si } x \not\in \mbox{last}(g) \\
\mbox{follow}(g,x)\cup \mbox{first}(g)& \mbox{ si } x \in \mbox{last}(g) \\
\end{array}
\right.
$$

\subsection{Exemple d'application}

On reprend l'arbre de syntaxe dze la figure \ref{as}, où figurent les numéros des positions. 
Nous partons des feuilles pouir remonter à la racine. Lorsque vous le programmerez, une parroche récursive sera plus facile à concevoir. 

Pour la position 1 : 

$$\begin{array}{lcl}
\mbox{nullable}(1)&=&\mbox{false}\\
\mbox{first}(1)&=&\{1\}\\
\mbox{last}(1)&=&\{1\}\\
\mbox{follow}(1)&=&\emptyset\\
\end{array}
$$

Pour la position 2 : 

$$\begin{array}{lcl}
\mbox{nullable}(2)&=&\mbox{false}\\
\mbox{first}(2)&=&\{2\}\\
\mbox{last}(2)&=&\{2\}\\
\mbox{follow}(2)&=&\emptyset\\
\end{array}
$$

Pour le n\oe ud interne $1\bullet \alpha2$ : 
$$\begin{array}{lcl}
\mbox{nullable}&=&\mbox{false}\\
\mbox{first}&=&\{1\}\\
\mbox{last}&=&\{2\}\\
\mbox{follow}(1)&=&\{2\}\\
\mbox{follow}(2)&=&\emptyset\\
\end{array}
$$

Pour la position 3 : 

$$\begin{array}{lcl}
\mbox{nullable}(3)&=&\mbox{false}\\
\mbox{first}(3)&=&\{3\}\\
\mbox{last}(3)&=&\{3\}\\
\mbox{follow}(3)&=&\emptyset\\
\end{array}
$$

Pour le n\oe ud $+$ : 
$$\begin{array}{lcl}
\mbox{nullable}&=&\mbox{false}\\
\mbox{first}&=&\{1,3\}\\
\mbox{last}&=&\{2,3\}\\
\mbox{follow}(1)&=&\{2\}\\
\mbox{follow}(2)&=&\emptyset\\
\mbox{follow}(3)&=&\emptyset\\
\end{array}
$$

Pour le n\oe ud interne $1\star2$ : 
$$\begin{array}{lcl}
\mbox{nullable}&=&\mbox{true}\\
\mbox{first}&=&\{1,3\}\\
\mbox{last}&=&\{2,3\}\\
\mbox{follow}(1)&=&\{2\}\\
\mbox{follow}(2)&=&\{1,3\}\\
\mbox{follow}(3)&=&\{1,3\}\\
\end{array}
$$

Pour la position 4: 

$$\begin{array}{lcl}
\mbox{nullable}(4)&=&\mbox{false}\\
\mbox{first}(4)&=&\{4\}\\
\mbox{last}(4)&=&\{4\}\\
\mbox{follow}(4)&=&\emptyset\\
\end{array}
$$

Pour le n\oe ud interne $1\bullet \beta2$ : 
$$\begin{array}{lcl}
\mbox{nullable}&=&\mbox{false}\\
\mbox{first}&=&\{1,3,4\}\\
\mbox{last}&=&\{4\}\\
\mbox{follow}(1)&=&\{2\}\\
\mbox{follow}(2)&=&\{1,3,4\}\\
\mbox{follow}(3)&=&\{1,3,4\}\\
\mbox{follow}(4)&=&\emptyset\\
\end{array}
$$

Pour la position 5: 

$$\begin{array}{lcl}
\mbox{nullable}(5)&=&\mbox{false}\\
\mbox{first}(5)&=&\{5\}\\
\mbox{last}(5)&=&\{5\}\\
\mbox{follow}(5)&=&\emptyset\\
\end{array}
$$


Enfin, au sommet de l'arbre, pour la position $\bullet \delta$

$$\begin{array}{lcl}
\mbox{nullable}&=&\mbox{false}\\
\mbox{first}&=&\{1,3,4\}\\
\mbox{last}&=&\{5\}\\
\mbox{follow}(1)&=&\{2\}\\
\mbox{follow}(2)&=&\{1,3,4\}\\
\mbox{follow}(3)&=&\{1,3,4\}\\
\mbox{follow}(4)&=&\{5\}\\
\mbox{follow}(5)&=&\emptyset\\
\end{array}
$$


Ces dernières informations permettent de définir entièrement l'automate : 
\begin{itemize}
\item L'état initial n'est pas final (le n\oe ud au sommet de l'arbre n'est pas $\mbox{nullable}$)
\item $\mbox{follow}$ fournit la table de transition de l'automate, aidé par $\mbox{first}$ qui décrit les transitions depuis l'état initial. 
\item $\mbox{last}$ donne la liste, ici réduite à un seul état, des états terminaux. 
\end{itemize}


Il vous reste encore à définir une structure de données pour l'automate, ainsi que les fonctions permettant de s'y déplacer. 

Attention, l'automate est non déterministe  : vous devrez gérer une liste d'états accessibles : un mot sera reconnu si un état final appartient à cette liste lorsque le mot aura été complètement lu. 
\end{document}


