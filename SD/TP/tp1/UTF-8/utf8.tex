\documentclass[12pt]{article}
\usepackage{xunicode}
\usepackage{fontspec}
\usepackage{xltxtra}
\usepackage{url}
\usepackage[francais]{babel}
\usepackage{fullpage}


\newtheorem{definition}{DÃ©finition}

\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}

%% \Section{intitulÃ©} -> rajoute Ã  l'intitulÃ© la somme des points des 
%%    questions qui figurent dans la section (faire deux compilations).

\newcounter{question_counter}
\setcounter{question_counter}{0}
\newcommand{\question}{\addtocounter{question_counter}1 %
    \paragraph{\bf Question \arabic{question_counter}.}}
\newcommand{\questiondiff}{\addtocounter{question_counter}1 %
    \paragraph{\bf Question \arabic{question_counter} (plus difficile).}}

\newcounter{points_counter}
\newcounter{section_points_counter}
\newcommand{\Question}[1]{\addtocounter{question_counter}1 %
    \addtocounter{points_counter}{#1} %
    \addtocounter{section_points_counter}{#1} %
    \typeout{Question \arabic{question_counter}. Total des points \arabic{points_counter}} %
    \typeout{points_counter_\Alph{section} \arabic{section_points_counter}} %
    \paragraph{\bf Question \arabic{question_counter}}{[#1\,\ifnum #1 = 1 pt\else pts\fi]}.}

\newcommand{\Section}[1]{\setcounter{section_points_counter}0 %
    \section{{#1} (\ref{points_counter_\Alph{section}} points)}}

\title{Polytech-Lille \\ Le codage UTF-8}
\author{FranÃ§ois Boulier}

\begin{document}
\maketitle

\section{Travail Ã  rÃ©aliser}

Ã‰crire un programme C qui vÃ©rifie qu'un fichier texte vÃ©rifie
bien le format UTF-8. Le nom du fichier Ã  tester doit Ãªtre rÃ©cupÃ©rÃ©
sur la ligne de commande. Il peut Ã©ventuellement Ãªtre prÃ©cÃ©dÃ© de
l'option Â«~{\tt -v}~Â» pour provoquer un affichage Â«~verbeux~Â».

Si l'option Â«~{\tt -v}~Â» n'est pas prÃ©cisÃ©e, le programme doit
recopier le contenu du fichier sur la sortie standard et imprimer
un Â«~{\tt replacement character}~Â» (codage UTF-8 {\tt 0xef 0xbf 0xbd},
valeur {\tt 0xfffd}) Ã  la place de tout caractÃ¨re non UTF-8.
Le programme doit retourner~$0$ si aucune erreur n'a Ã©tÃ© dÃ©tectÃ©e,~$1$
sinon.

Si l'option Â«~{\tt -v}~Â» est prÃ©cisÃ©e, le programme doit
recopier le contenu du fichier sur la sortie standard et imprimer
davantage d'informations en cas d'erreur (le codage hexadÃ©cimal
de la sÃ©quence d'octets fautive et une raison pour laquelle
la sÃ©quence est considÃ©rÃ©e comme fautive). De plus, en fin d'analyse,
le programme doit imprimer le nombre d'erreurs rencontrÃ©es ainsi
qu'un caractÃ¨re UTF-8 rencontrÃ© parmi ceux qui comportent le
plus d'octets.

Voici quelques exemples.
\begin{verbatim}
# Message Ã  afficher si le nombre d'arguments est incorrect
boulier@ciney:~/utf8$ ./a.out 
usage: ./a.out [-v] file-name

# Le programme Ã  rÃ©aliser
boulier@ciney:~/utf8$ ./a.out -v utf8-tester.c 
[...]
longest encoding: 3 bytes [â‚¬]  e2 82 ac
number of errors: 0

# Un fichier plein d'erreurs
./a.out -v UTF-8-test.txt 
[...]
5.3.2  U+FFFF = ef bf bf = "[noncharacter: ef bf bf]"                                                |
                                                                              |
THE END                                                                       |
longest encoding: 4 bytes [ğ€€]  f0 90 80 80
number of errors: 216

# Le mÃªme sans l'option -v (le Â« replacement character Â» apparaÃ®t)
5.3.2  U+FFFF = ef bf bf = "ï¿½"                                                |
                                                                              |
THE END                                                                       |
boulier@ciney:~/utf8$ echo $?
1
\end{verbatim}

\section{Consignes}

Lors de la lecture du fichier, on demande que chaque caractÃ¨re lu
soit stockÃ© dans une variable du type suivant. On demande aussi 
d'implanter les fonctions dont les prototypes suivent.
\begin{verbatim}
/* 
 * Structure pour stocker un caractÃ¨re UTF-8 
 */

#define NBMAX_BYTES 8
struct character
{   unsigned char bytes [NBMAX_BYTES]; /* les octets */
    int nbbytes;                       /* le nombre d'octets */
};

/* initialisation Ã  la sÃ©quence vide */
void init_character (struct character* c);

/* ajout d'un nouvel octet en fin de sÃ©quence */
void append_byte (struct character* c, unsigned char byte);

/* imprime la sÃ©quence d'octets, c'est-Ã -dire, le caractÃ¨re */
void print_character (struct character* c);

/* imprime la sÃ©quence d'octets en hexadÃ©cimal */
void dump_character (struct character* c);
\end{verbatim}

\section{Le codage UTF-8}

Un caractÃ¨re UTF-8 est codÃ© sur $1$ Ã  $4$ octets.
Il a une {\em valeur} comprise entre {\tt 0x00} et {\tt 0x10ffff}.

Un caractÃ¨re codÃ© sur $1$ octet est un code ASCII. Sa valeur
est donc comprise entre {\tt 0x00} et {\tt 0x7f}.

Si un caractÃ¨re est codÃ© sur $2$, $3$ ou $4$ octets, alors chaque
octet est composÃ© d'une suite de bits de contrÃ´le, puis de
bits destinÃ©s Ã  former la valeur du caractÃ¨re.

Soit un caractÃ¨re codÃ© par $n$ octets ($2 \leq n \leq 4$).
Le premier octet commence par $n$ bits Ã  $1$, suivi d'un bit Ã  $0$, 
suivi de $7-n$ bits de valeur. Les autres octets commencent par les deux
bits $10$, suivi de $6$ bits de valeur.
La valeur du caractÃ¨re s'obtient en concatÃ©nant les bits de valeur.
Exemple~:
\begin{itemize}
\item
$2$ octets. Codage~: {\tt 110xxxxx 10yyyyyy}. Valeur~: {\tt xxx xxyyyyyy}.
\item
$3$ octets. Codage~: {\tt 1110xxxx 10yyyyyy 10zzzzzz}. 
	Valeur~: {\tt xxxxyyyy yyzzzzzz}.
\item
$4$ octets. Codage~: {\tt 11110xxx 10yyyyyy 10zzzzzz 10wwwwww}.
          Valeur~: {\tt xxxyy yyyyzzzz zzwwwwww}.
\end{itemize}
Certains codages sont interdits:
\begin{itemize}
\item
le codage d'une valeur doit se faire sur un nombre minimal d'octets~:
\begin{enumerate}
\item
les premiers octets {\tt 0xc0} et {\tt 0xc1} sont interdits (ils 
	donneraient lieu Ã  un code ASCII sur deux octets)~;
\item
si le premier octet est {\tt 0xe0}, la valeur finale doit Ãªtre 
supÃ©rieure ou Ã©gale Ã  {\tt 0x800}~;
\item
si le premier octet est {\tt 0xf0}, la valeur finale doit Ãªtre 
supÃ©rieure ou Ã©gale Ã  {\tt 0x10000}.
\end{enumerate}
\item
la valeur ne doit pas dÃ©passer {\tt 0x10ffff}~;
\item
les valeurs comprises entre {\tt 0xd800} et {\tt 0xdfff} sont rÃ©servÃ©es 
pour coder de l'UTF-16 et ne correspondent Ã  aucun caractÃ¨re UTF-8~;
\item
il existe $66$ valeurs pour des Â«~non-caractÃ¨res~Â»~: les valeurs
comprises entre {\tt 0xfdd0} et {\tt 0xfdef} ainsi que les $34$
valeurs terminant par {\tt 0xfffe} et {\tt 0xffff} (de 
{\tt 0xfffe}, {\tt 0xffff} Ã  {\tt 0x10fffe}, {\tt 0x10fff}). 
\end{itemize}


\bibliographystyle{plain}
\bibliography{reecriture}
\end{document}
